// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package relabeler_test

import (
	"context"
	"github.com/google/uuid"
	"github.com/prometheus/prometheus/pp/go/cppbridge"
	"github.com/prometheus/prometheus/pp/go/frames"
	"github.com/prometheus/prometheus/pp/go/relabeler"
	"io"
	"sync"
)

// Ensure, that DialerMock does implement relabeler.Dialer.
// If this is not the case, regenerate this file with moq.
var _ relabeler.Dialer = &DialerMock{}

// DialerMock is a mock implementation of relabeler.Dialer.
//
//	func TestSomethingThatUsesDialer(t *testing.T) {
//
//		// make and configure a mocked relabeler.Dialer
//		mockedDialer := &DialerMock{
//			ConnDialerFunc: func() relabeler.ConnDialer {
//				panic("mock out the ConnDialer method")
//			},
//			DialFunc: func(ctx context.Context, shardMeta relabeler.ShardMeta) (relabeler.Transport, error) {
//				panic("mock out the Dial method")
//			},
//			EqualFunc: func(config *relabeler.DialerConfig) bool {
//				panic("mock out the Equal method")
//			},
//			SendRefillFunc: func(ctx context.Context, r io.Reader, shardMeta relabeler.ShardMeta) error {
//				panic("mock out the SendRefill method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//		}
//
//		// use mockedDialer in code that requires relabeler.Dialer
//		// and then make assertions.
//
//	}
type DialerMock struct {
	// ConnDialerFunc mocks the ConnDialer method.
	ConnDialerFunc func() relabeler.ConnDialer

	// DialFunc mocks the Dial method.
	DialFunc func(ctx context.Context, shardMeta relabeler.ShardMeta) (relabeler.Transport, error)

	// EqualFunc mocks the Equal method.
	EqualFunc func(config *relabeler.DialerConfig) bool

	// SendRefillFunc mocks the SendRefill method.
	SendRefillFunc func(ctx context.Context, r io.Reader, shardMeta relabeler.ShardMeta) error

	// StringFunc mocks the String method.
	StringFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// ConnDialer holds details about calls to the ConnDialer method.
		ConnDialer []struct {
		}
		// Dial holds details about calls to the Dial method.
		Dial []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ShardMeta is the shardMeta argument value.
			ShardMeta relabeler.ShardMeta
		}
		// Equal holds details about calls to the Equal method.
		Equal []struct {
			// Config is the config argument value.
			Config *relabeler.DialerConfig
		}
		// SendRefill holds details about calls to the SendRefill method.
		SendRefill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R io.Reader
			// ShardMeta is the shardMeta argument value.
			ShardMeta relabeler.ShardMeta
		}
		// String holds details about calls to the String method.
		String []struct {
		}
	}
	lockConnDialer sync.RWMutex
	lockDial       sync.RWMutex
	lockEqual      sync.RWMutex
	lockSendRefill sync.RWMutex
	lockString     sync.RWMutex
}

// ConnDialer calls ConnDialerFunc.
func (mock *DialerMock) ConnDialer() relabeler.ConnDialer {
	if mock.ConnDialerFunc == nil {
		panic("DialerMock.ConnDialerFunc: method is nil but Dialer.ConnDialer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConnDialer.Lock()
	mock.calls.ConnDialer = append(mock.calls.ConnDialer, callInfo)
	mock.lockConnDialer.Unlock()
	return mock.ConnDialerFunc()
}

// ConnDialerCalls gets all the calls that were made to ConnDialer.
// Check the length with:
//
//	len(mockedDialer.ConnDialerCalls())
func (mock *DialerMock) ConnDialerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConnDialer.RLock()
	calls = mock.calls.ConnDialer
	mock.lockConnDialer.RUnlock()
	return calls
}

// Dial calls DialFunc.
func (mock *DialerMock) Dial(ctx context.Context, shardMeta relabeler.ShardMeta) (relabeler.Transport, error) {
	if mock.DialFunc == nil {
		panic("DialerMock.DialFunc: method is nil but Dialer.Dial was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ShardMeta relabeler.ShardMeta
	}{
		Ctx:       ctx,
		ShardMeta: shardMeta,
	}
	mock.lockDial.Lock()
	mock.calls.Dial = append(mock.calls.Dial, callInfo)
	mock.lockDial.Unlock()
	return mock.DialFunc(ctx, shardMeta)
}

// DialCalls gets all the calls that were made to Dial.
// Check the length with:
//
//	len(mockedDialer.DialCalls())
func (mock *DialerMock) DialCalls() []struct {
	Ctx       context.Context
	ShardMeta relabeler.ShardMeta
} {
	var calls []struct {
		Ctx       context.Context
		ShardMeta relabeler.ShardMeta
	}
	mock.lockDial.RLock()
	calls = mock.calls.Dial
	mock.lockDial.RUnlock()
	return calls
}

// Equal calls EqualFunc.
func (mock *DialerMock) Equal(config *relabeler.DialerConfig) bool {
	if mock.EqualFunc == nil {
		panic("DialerMock.EqualFunc: method is nil but Dialer.Equal was just called")
	}
	callInfo := struct {
		Config *relabeler.DialerConfig
	}{
		Config: config,
	}
	mock.lockEqual.Lock()
	mock.calls.Equal = append(mock.calls.Equal, callInfo)
	mock.lockEqual.Unlock()
	return mock.EqualFunc(config)
}

// EqualCalls gets all the calls that were made to Equal.
// Check the length with:
//
//	len(mockedDialer.EqualCalls())
func (mock *DialerMock) EqualCalls() []struct {
	Config *relabeler.DialerConfig
} {
	var calls []struct {
		Config *relabeler.DialerConfig
	}
	mock.lockEqual.RLock()
	calls = mock.calls.Equal
	mock.lockEqual.RUnlock()
	return calls
}

// SendRefill calls SendRefillFunc.
func (mock *DialerMock) SendRefill(ctx context.Context, r io.Reader, shardMeta relabeler.ShardMeta) error {
	if mock.SendRefillFunc == nil {
		panic("DialerMock.SendRefillFunc: method is nil but Dialer.SendRefill was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		R         io.Reader
		ShardMeta relabeler.ShardMeta
	}{
		Ctx:       ctx,
		R:         r,
		ShardMeta: shardMeta,
	}
	mock.lockSendRefill.Lock()
	mock.calls.SendRefill = append(mock.calls.SendRefill, callInfo)
	mock.lockSendRefill.Unlock()
	return mock.SendRefillFunc(ctx, r, shardMeta)
}

// SendRefillCalls gets all the calls that were made to SendRefill.
// Check the length with:
//
//	len(mockedDialer.SendRefillCalls())
func (mock *DialerMock) SendRefillCalls() []struct {
	Ctx       context.Context
	R         io.Reader
	ShardMeta relabeler.ShardMeta
} {
	var calls []struct {
		Ctx       context.Context
		R         io.Reader
		ShardMeta relabeler.ShardMeta
	}
	mock.lockSendRefill.RLock()
	calls = mock.calls.SendRefill
	mock.lockSendRefill.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *DialerMock) String() string {
	if mock.StringFunc == nil {
		panic("DialerMock.StringFunc: method is nil but Dialer.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedDialer.StringCalls())
func (mock *DialerMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Ensure, that ManagerEncoderMock does implement relabeler.ManagerEncoder.
// If this is not the case, regenerate this file with moq.
var _ relabeler.ManagerEncoder = &ManagerEncoderMock{}

// ManagerEncoderMock is a mock implementation of relabeler.ManagerEncoder.
//
//	func TestSomethingThatUsesManagerEncoder(t *testing.T) {
//
//		// make and configure a mocked relabeler.ManagerEncoder
//		mockedManagerEncoder := &ManagerEncoderMock{
//			AddInnerSeriesFunc: func(ctx context.Context, innerSeries []*cppbridge.InnerSeries) (cppbridge.SegmentStats, error) {
//				panic("mock out the AddInnerSeries method")
//			},
//			AddRelabeledSeriesFunc: func(ctx context.Context, relabeledSeries *cppbridge.RelabeledSeries, relabelerStateUpdate *cppbridge.RelabelerStateUpdate) (cppbridge.SegmentStats, error) {
//				panic("mock out the AddRelabeledSeries method")
//			},
//			FinalizeFunc: func(contextMoqParam context.Context) (cppbridge.SegmentKey, cppbridge.Segment, error) {
//				panic("mock out the Finalize method")
//			},
//			LastEncodedSegmentFunc: func() uint32 {
//				panic("mock out the LastEncodedSegment method")
//			},
//		}
//
//		// use mockedManagerEncoder in code that requires relabeler.ManagerEncoder
//		// and then make assertions.
//
//	}
type ManagerEncoderMock struct {
	// AddInnerSeriesFunc mocks the AddInnerSeries method.
	AddInnerSeriesFunc func(ctx context.Context, innerSeries []*cppbridge.InnerSeries) (cppbridge.SegmentStats, error)

	// AddRelabeledSeriesFunc mocks the AddRelabeledSeries method.
	AddRelabeledSeriesFunc func(ctx context.Context, relabeledSeries *cppbridge.RelabeledSeries, relabelerStateUpdate *cppbridge.RelabelerStateUpdate) (cppbridge.SegmentStats, error)

	// FinalizeFunc mocks the Finalize method.
	FinalizeFunc func(contextMoqParam context.Context) (cppbridge.SegmentKey, cppbridge.Segment, error)

	// LastEncodedSegmentFunc mocks the LastEncodedSegment method.
	LastEncodedSegmentFunc func() uint32

	// calls tracks calls to the methods.
	calls struct {
		// AddInnerSeries holds details about calls to the AddInnerSeries method.
		AddInnerSeries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// InnerSeries is the innerSeries argument value.
			InnerSeries []*cppbridge.InnerSeries
		}
		// AddRelabeledSeries holds details about calls to the AddRelabeledSeries method.
		AddRelabeledSeries []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RelabeledSeries is the relabeledSeries argument value.
			RelabeledSeries *cppbridge.RelabeledSeries
			// RelabelerStateUpdate is the relabelerStateUpdate argument value.
			RelabelerStateUpdate *cppbridge.RelabelerStateUpdate
		}
		// Finalize holds details about calls to the Finalize method.
		Finalize []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// LastEncodedSegment holds details about calls to the LastEncodedSegment method.
		LastEncodedSegment []struct {
		}
	}
	lockAddInnerSeries     sync.RWMutex
	lockAddRelabeledSeries sync.RWMutex
	lockFinalize           sync.RWMutex
	lockLastEncodedSegment sync.RWMutex
}

// AddInnerSeries calls AddInnerSeriesFunc.
func (mock *ManagerEncoderMock) AddInnerSeries(ctx context.Context, innerSeries []*cppbridge.InnerSeries) (cppbridge.SegmentStats, error) {
	if mock.AddInnerSeriesFunc == nil {
		panic("ManagerEncoderMock.AddInnerSeriesFunc: method is nil but ManagerEncoder.AddInnerSeries was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		InnerSeries []*cppbridge.InnerSeries
	}{
		Ctx:         ctx,
		InnerSeries: innerSeries,
	}
	mock.lockAddInnerSeries.Lock()
	mock.calls.AddInnerSeries = append(mock.calls.AddInnerSeries, callInfo)
	mock.lockAddInnerSeries.Unlock()
	return mock.AddInnerSeriesFunc(ctx, innerSeries)
}

// AddInnerSeriesCalls gets all the calls that were made to AddInnerSeries.
// Check the length with:
//
//	len(mockedManagerEncoder.AddInnerSeriesCalls())
func (mock *ManagerEncoderMock) AddInnerSeriesCalls() []struct {
	Ctx         context.Context
	InnerSeries []*cppbridge.InnerSeries
} {
	var calls []struct {
		Ctx         context.Context
		InnerSeries []*cppbridge.InnerSeries
	}
	mock.lockAddInnerSeries.RLock()
	calls = mock.calls.AddInnerSeries
	mock.lockAddInnerSeries.RUnlock()
	return calls
}

// AddRelabeledSeries calls AddRelabeledSeriesFunc.
func (mock *ManagerEncoderMock) AddRelabeledSeries(ctx context.Context, relabeledSeries *cppbridge.RelabeledSeries, relabelerStateUpdate *cppbridge.RelabelerStateUpdate) (cppbridge.SegmentStats, error) {
	if mock.AddRelabeledSeriesFunc == nil {
		panic("ManagerEncoderMock.AddRelabeledSeriesFunc: method is nil but ManagerEncoder.AddRelabeledSeries was just called")
	}
	callInfo := struct {
		Ctx                  context.Context
		RelabeledSeries      *cppbridge.RelabeledSeries
		RelabelerStateUpdate *cppbridge.RelabelerStateUpdate
	}{
		Ctx:                  ctx,
		RelabeledSeries:      relabeledSeries,
		RelabelerStateUpdate: relabelerStateUpdate,
	}
	mock.lockAddRelabeledSeries.Lock()
	mock.calls.AddRelabeledSeries = append(mock.calls.AddRelabeledSeries, callInfo)
	mock.lockAddRelabeledSeries.Unlock()
	return mock.AddRelabeledSeriesFunc(ctx, relabeledSeries, relabelerStateUpdate)
}

// AddRelabeledSeriesCalls gets all the calls that were made to AddRelabeledSeries.
// Check the length with:
//
//	len(mockedManagerEncoder.AddRelabeledSeriesCalls())
func (mock *ManagerEncoderMock) AddRelabeledSeriesCalls() []struct {
	Ctx                  context.Context
	RelabeledSeries      *cppbridge.RelabeledSeries
	RelabelerStateUpdate *cppbridge.RelabelerStateUpdate
} {
	var calls []struct {
		Ctx                  context.Context
		RelabeledSeries      *cppbridge.RelabeledSeries
		RelabelerStateUpdate *cppbridge.RelabelerStateUpdate
	}
	mock.lockAddRelabeledSeries.RLock()
	calls = mock.calls.AddRelabeledSeries
	mock.lockAddRelabeledSeries.RUnlock()
	return calls
}

// Finalize calls FinalizeFunc.
func (mock *ManagerEncoderMock) Finalize(contextMoqParam context.Context) (cppbridge.SegmentKey, cppbridge.Segment, error) {
	if mock.FinalizeFunc == nil {
		panic("ManagerEncoderMock.FinalizeFunc: method is nil but ManagerEncoder.Finalize was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockFinalize.Lock()
	mock.calls.Finalize = append(mock.calls.Finalize, callInfo)
	mock.lockFinalize.Unlock()
	return mock.FinalizeFunc(contextMoqParam)
}

// FinalizeCalls gets all the calls that were made to Finalize.
// Check the length with:
//
//	len(mockedManagerEncoder.FinalizeCalls())
func (mock *ManagerEncoderMock) FinalizeCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockFinalize.RLock()
	calls = mock.calls.Finalize
	mock.lockFinalize.RUnlock()
	return calls
}

// LastEncodedSegment calls LastEncodedSegmentFunc.
func (mock *ManagerEncoderMock) LastEncodedSegment() uint32 {
	if mock.LastEncodedSegmentFunc == nil {
		panic("ManagerEncoderMock.LastEncodedSegmentFunc: method is nil but ManagerEncoder.LastEncodedSegment was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLastEncodedSegment.Lock()
	mock.calls.LastEncodedSegment = append(mock.calls.LastEncodedSegment, callInfo)
	mock.lockLastEncodedSegment.Unlock()
	return mock.LastEncodedSegmentFunc()
}

// LastEncodedSegmentCalls gets all the calls that were made to LastEncodedSegment.
// Check the length with:
//
//	len(mockedManagerEncoder.LastEncodedSegmentCalls())
func (mock *ManagerEncoderMock) LastEncodedSegmentCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLastEncodedSegment.RLock()
	calls = mock.calls.LastEncodedSegment
	mock.lockLastEncodedSegment.RUnlock()
	return calls
}

// Ensure, that ManagerRefillMock does implement relabeler.ManagerRefill.
// If this is not the case, regenerate this file with moq.
var _ relabeler.ManagerRefill = &ManagerRefillMock{}

// ManagerRefillMock is a mock implementation of relabeler.ManagerRefill.
//
//	func TestSomethingThatUsesManagerRefill(t *testing.T) {
//
//		// make and configure a mocked relabeler.ManagerRefill
//		mockedManagerRefill := &ManagerRefillMock{
//			AckFunc: func(segmentKey cppbridge.SegmentKey, s string)  {
//				panic("mock out the Ack method")
//			},
//			BlockIDFunc: func() uuid.UUID {
//				panic("mock out the BlockID method")
//			},
//			DestinationsFunc: func() int {
//				panic("mock out the Destinations method")
//			},
//			GetFunc: func(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey) (relabeler.Segment, error) {
//				panic("mock out the Get method")
//			},
//			IntermediateRenameFunc: func() error {
//				panic("mock out the IntermediateRename method")
//			},
//			IsContinuableFunc: func() bool {
//				panic("mock out the IsContinuable method")
//			},
//			LastSegmentFunc: func(v uint16, s string) uint32 {
//				panic("mock out the LastSegment method")
//			},
//			RejectFunc: func(segmentKey cppbridge.SegmentKey, s string)  {
//				panic("mock out the Reject method")
//			},
//			ShardsFunc: func() int {
//				panic("mock out the Shards method")
//			},
//			ShutdownFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the Shutdown method")
//			},
//			WriteAckStatusFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the WriteAckStatus method")
//			},
//			WriteSegmentFunc: func(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey, segment relabeler.Segment) error {
//				panic("mock out the WriteSegment method")
//			},
//		}
//
//		// use mockedManagerRefill in code that requires relabeler.ManagerRefill
//		// and then make assertions.
//
//	}
type ManagerRefillMock struct {
	// AckFunc mocks the Ack method.
	AckFunc func(segmentKey cppbridge.SegmentKey, s string)

	// BlockIDFunc mocks the BlockID method.
	BlockIDFunc func() uuid.UUID

	// DestinationsFunc mocks the Destinations method.
	DestinationsFunc func() int

	// GetFunc mocks the Get method.
	GetFunc func(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey) (relabeler.Segment, error)

	// IntermediateRenameFunc mocks the IntermediateRename method.
	IntermediateRenameFunc func() error

	// IsContinuableFunc mocks the IsContinuable method.
	IsContinuableFunc func() bool

	// LastSegmentFunc mocks the LastSegment method.
	LastSegmentFunc func(v uint16, s string) uint32

	// RejectFunc mocks the Reject method.
	RejectFunc func(segmentKey cppbridge.SegmentKey, s string)

	// ShardsFunc mocks the Shards method.
	ShardsFunc func() int

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func(contextMoqParam context.Context) error

	// WriteAckStatusFunc mocks the WriteAckStatus method.
	WriteAckStatusFunc func(contextMoqParam context.Context) error

	// WriteSegmentFunc mocks the WriteSegment method.
	WriteSegmentFunc func(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey, segment relabeler.Segment) error

	// calls tracks calls to the methods.
	calls struct {
		// Ack holds details about calls to the Ack method.
		Ack []struct {
			// SegmentKey is the segmentKey argument value.
			SegmentKey cppbridge.SegmentKey
			// S is the s argument value.
			S string
		}
		// BlockID holds details about calls to the BlockID method.
		BlockID []struct {
		}
		// Destinations holds details about calls to the Destinations method.
		Destinations []struct {
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SegmentKey is the segmentKey argument value.
			SegmentKey cppbridge.SegmentKey
		}
		// IntermediateRename holds details about calls to the IntermediateRename method.
		IntermediateRename []struct {
		}
		// IsContinuable holds details about calls to the IsContinuable method.
		IsContinuable []struct {
		}
		// LastSegment holds details about calls to the LastSegment method.
		LastSegment []struct {
			// V is the v argument value.
			V uint16
			// S is the s argument value.
			S string
		}
		// Reject holds details about calls to the Reject method.
		Reject []struct {
			// SegmentKey is the segmentKey argument value.
			SegmentKey cppbridge.SegmentKey
			// S is the s argument value.
			S string
		}
		// Shards holds details about calls to the Shards method.
		Shards []struct {
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// WriteAckStatus holds details about calls to the WriteAckStatus method.
		WriteAckStatus []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// WriteSegment holds details about calls to the WriteSegment method.
		WriteSegment []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// SegmentKey is the segmentKey argument value.
			SegmentKey cppbridge.SegmentKey
			// Segment is the segment argument value.
			Segment relabeler.Segment
		}
	}
	lockAck                sync.RWMutex
	lockBlockID            sync.RWMutex
	lockDestinations       sync.RWMutex
	lockGet                sync.RWMutex
	lockIntermediateRename sync.RWMutex
	lockIsContinuable      sync.RWMutex
	lockLastSegment        sync.RWMutex
	lockReject             sync.RWMutex
	lockShards             sync.RWMutex
	lockShutdown           sync.RWMutex
	lockWriteAckStatus     sync.RWMutex
	lockWriteSegment       sync.RWMutex
}

// Ack calls AckFunc.
func (mock *ManagerRefillMock) Ack(segmentKey cppbridge.SegmentKey, s string) {
	if mock.AckFunc == nil {
		panic("ManagerRefillMock.AckFunc: method is nil but ManagerRefill.Ack was just called")
	}
	callInfo := struct {
		SegmentKey cppbridge.SegmentKey
		S          string
	}{
		SegmentKey: segmentKey,
		S:          s,
	}
	mock.lockAck.Lock()
	mock.calls.Ack = append(mock.calls.Ack, callInfo)
	mock.lockAck.Unlock()
	mock.AckFunc(segmentKey, s)
}

// AckCalls gets all the calls that were made to Ack.
// Check the length with:
//
//	len(mockedManagerRefill.AckCalls())
func (mock *ManagerRefillMock) AckCalls() []struct {
	SegmentKey cppbridge.SegmentKey
	S          string
} {
	var calls []struct {
		SegmentKey cppbridge.SegmentKey
		S          string
	}
	mock.lockAck.RLock()
	calls = mock.calls.Ack
	mock.lockAck.RUnlock()
	return calls
}

// BlockID calls BlockIDFunc.
func (mock *ManagerRefillMock) BlockID() uuid.UUID {
	if mock.BlockIDFunc == nil {
		panic("ManagerRefillMock.BlockIDFunc: method is nil but ManagerRefill.BlockID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBlockID.Lock()
	mock.calls.BlockID = append(mock.calls.BlockID, callInfo)
	mock.lockBlockID.Unlock()
	return mock.BlockIDFunc()
}

// BlockIDCalls gets all the calls that were made to BlockID.
// Check the length with:
//
//	len(mockedManagerRefill.BlockIDCalls())
func (mock *ManagerRefillMock) BlockIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBlockID.RLock()
	calls = mock.calls.BlockID
	mock.lockBlockID.RUnlock()
	return calls
}

// Destinations calls DestinationsFunc.
func (mock *ManagerRefillMock) Destinations() int {
	if mock.DestinationsFunc == nil {
		panic("ManagerRefillMock.DestinationsFunc: method is nil but ManagerRefill.Destinations was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDestinations.Lock()
	mock.calls.Destinations = append(mock.calls.Destinations, callInfo)
	mock.lockDestinations.Unlock()
	return mock.DestinationsFunc()
}

// DestinationsCalls gets all the calls that were made to Destinations.
// Check the length with:
//
//	len(mockedManagerRefill.DestinationsCalls())
func (mock *ManagerRefillMock) DestinationsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDestinations.RLock()
	calls = mock.calls.Destinations
	mock.lockDestinations.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *ManagerRefillMock) Get(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey) (relabeler.Segment, error) {
	if mock.GetFunc == nil {
		panic("ManagerRefillMock.GetFunc: method is nil but ManagerRefill.Get was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		SegmentKey      cppbridge.SegmentKey
	}{
		ContextMoqParam: contextMoqParam,
		SegmentKey:      segmentKey,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(contextMoqParam, segmentKey)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedManagerRefill.GetCalls())
func (mock *ManagerRefillMock) GetCalls() []struct {
	ContextMoqParam context.Context
	SegmentKey      cppbridge.SegmentKey
} {
	var calls []struct {
		ContextMoqParam context.Context
		SegmentKey      cppbridge.SegmentKey
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// IntermediateRename calls IntermediateRenameFunc.
func (mock *ManagerRefillMock) IntermediateRename() error {
	if mock.IntermediateRenameFunc == nil {
		panic("ManagerRefillMock.IntermediateRenameFunc: method is nil but ManagerRefill.IntermediateRename was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIntermediateRename.Lock()
	mock.calls.IntermediateRename = append(mock.calls.IntermediateRename, callInfo)
	mock.lockIntermediateRename.Unlock()
	return mock.IntermediateRenameFunc()
}

// IntermediateRenameCalls gets all the calls that were made to IntermediateRename.
// Check the length with:
//
//	len(mockedManagerRefill.IntermediateRenameCalls())
func (mock *ManagerRefillMock) IntermediateRenameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIntermediateRename.RLock()
	calls = mock.calls.IntermediateRename
	mock.lockIntermediateRename.RUnlock()
	return calls
}

// IsContinuable calls IsContinuableFunc.
func (mock *ManagerRefillMock) IsContinuable() bool {
	if mock.IsContinuableFunc == nil {
		panic("ManagerRefillMock.IsContinuableFunc: method is nil but ManagerRefill.IsContinuable was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsContinuable.Lock()
	mock.calls.IsContinuable = append(mock.calls.IsContinuable, callInfo)
	mock.lockIsContinuable.Unlock()
	return mock.IsContinuableFunc()
}

// IsContinuableCalls gets all the calls that were made to IsContinuable.
// Check the length with:
//
//	len(mockedManagerRefill.IsContinuableCalls())
func (mock *ManagerRefillMock) IsContinuableCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsContinuable.RLock()
	calls = mock.calls.IsContinuable
	mock.lockIsContinuable.RUnlock()
	return calls
}

// LastSegment calls LastSegmentFunc.
func (mock *ManagerRefillMock) LastSegment(v uint16, s string) uint32 {
	if mock.LastSegmentFunc == nil {
		panic("ManagerRefillMock.LastSegmentFunc: method is nil but ManagerRefill.LastSegment was just called")
	}
	callInfo := struct {
		V uint16
		S string
	}{
		V: v,
		S: s,
	}
	mock.lockLastSegment.Lock()
	mock.calls.LastSegment = append(mock.calls.LastSegment, callInfo)
	mock.lockLastSegment.Unlock()
	return mock.LastSegmentFunc(v, s)
}

// LastSegmentCalls gets all the calls that were made to LastSegment.
// Check the length with:
//
//	len(mockedManagerRefill.LastSegmentCalls())
func (mock *ManagerRefillMock) LastSegmentCalls() []struct {
	V uint16
	S string
} {
	var calls []struct {
		V uint16
		S string
	}
	mock.lockLastSegment.RLock()
	calls = mock.calls.LastSegment
	mock.lockLastSegment.RUnlock()
	return calls
}

// Reject calls RejectFunc.
func (mock *ManagerRefillMock) Reject(segmentKey cppbridge.SegmentKey, s string) {
	if mock.RejectFunc == nil {
		panic("ManagerRefillMock.RejectFunc: method is nil but ManagerRefill.Reject was just called")
	}
	callInfo := struct {
		SegmentKey cppbridge.SegmentKey
		S          string
	}{
		SegmentKey: segmentKey,
		S:          s,
	}
	mock.lockReject.Lock()
	mock.calls.Reject = append(mock.calls.Reject, callInfo)
	mock.lockReject.Unlock()
	mock.RejectFunc(segmentKey, s)
}

// RejectCalls gets all the calls that were made to Reject.
// Check the length with:
//
//	len(mockedManagerRefill.RejectCalls())
func (mock *ManagerRefillMock) RejectCalls() []struct {
	SegmentKey cppbridge.SegmentKey
	S          string
} {
	var calls []struct {
		SegmentKey cppbridge.SegmentKey
		S          string
	}
	mock.lockReject.RLock()
	calls = mock.calls.Reject
	mock.lockReject.RUnlock()
	return calls
}

// Shards calls ShardsFunc.
func (mock *ManagerRefillMock) Shards() int {
	if mock.ShardsFunc == nil {
		panic("ManagerRefillMock.ShardsFunc: method is nil but ManagerRefill.Shards was just called")
	}
	callInfo := struct {
	}{}
	mock.lockShards.Lock()
	mock.calls.Shards = append(mock.calls.Shards, callInfo)
	mock.lockShards.Unlock()
	return mock.ShardsFunc()
}

// ShardsCalls gets all the calls that were made to Shards.
// Check the length with:
//
//	len(mockedManagerRefill.ShardsCalls())
func (mock *ManagerRefillMock) ShardsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockShards.RLock()
	calls = mock.calls.Shards
	mock.lockShards.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *ManagerRefillMock) Shutdown(contextMoqParam context.Context) error {
	if mock.ShutdownFunc == nil {
		panic("ManagerRefillMock.ShutdownFunc: method is nil but ManagerRefill.Shutdown was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	return mock.ShutdownFunc(contextMoqParam)
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedManagerRefill.ShutdownCalls())
func (mock *ManagerRefillMock) ShutdownCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}

// WriteAckStatus calls WriteAckStatusFunc.
func (mock *ManagerRefillMock) WriteAckStatus(contextMoqParam context.Context) error {
	if mock.WriteAckStatusFunc == nil {
		panic("ManagerRefillMock.WriteAckStatusFunc: method is nil but ManagerRefill.WriteAckStatus was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockWriteAckStatus.Lock()
	mock.calls.WriteAckStatus = append(mock.calls.WriteAckStatus, callInfo)
	mock.lockWriteAckStatus.Unlock()
	return mock.WriteAckStatusFunc(contextMoqParam)
}

// WriteAckStatusCalls gets all the calls that were made to WriteAckStatus.
// Check the length with:
//
//	len(mockedManagerRefill.WriteAckStatusCalls())
func (mock *ManagerRefillMock) WriteAckStatusCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockWriteAckStatus.RLock()
	calls = mock.calls.WriteAckStatus
	mock.lockWriteAckStatus.RUnlock()
	return calls
}

// WriteSegment calls WriteSegmentFunc.
func (mock *ManagerRefillMock) WriteSegment(contextMoqParam context.Context, segmentKey cppbridge.SegmentKey, segment relabeler.Segment) error {
	if mock.WriteSegmentFunc == nil {
		panic("ManagerRefillMock.WriteSegmentFunc: method is nil but ManagerRefill.WriteSegment was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		SegmentKey      cppbridge.SegmentKey
		Segment         relabeler.Segment
	}{
		ContextMoqParam: contextMoqParam,
		SegmentKey:      segmentKey,
		Segment:         segment,
	}
	mock.lockWriteSegment.Lock()
	mock.calls.WriteSegment = append(mock.calls.WriteSegment, callInfo)
	mock.lockWriteSegment.Unlock()
	return mock.WriteSegmentFunc(contextMoqParam, segmentKey, segment)
}

// WriteSegmentCalls gets all the calls that were made to WriteSegment.
// Check the length with:
//
//	len(mockedManagerRefill.WriteSegmentCalls())
func (mock *ManagerRefillMock) WriteSegmentCalls() []struct {
	ContextMoqParam context.Context
	SegmentKey      cppbridge.SegmentKey
	Segment         relabeler.Segment
} {
	var calls []struct {
		ContextMoqParam context.Context
		SegmentKey      cppbridge.SegmentKey
		Segment         relabeler.Segment
	}
	mock.lockWriteSegment.RLock()
	calls = mock.calls.WriteSegment
	mock.lockWriteSegment.RUnlock()
	return calls
}

// Ensure, that ManagerRefillSenderMock does implement relabeler.ManagerRefillSender.
// If this is not the case, regenerate this file with moq.
var _ relabeler.ManagerRefillSender = &ManagerRefillSenderMock{}

// ManagerRefillSenderMock is a mock implementation of relabeler.ManagerRefillSender.
//
//	func TestSomethingThatUsesManagerRefillSender(t *testing.T) {
//
//		// make and configure a mocked relabeler.ManagerRefillSender
//		mockedManagerRefillSender := &ManagerRefillSenderMock{
//			ResetToFunc: func(workingDir string, dialers []relabeler.Dialer, rsmCfg *relabeler.RefillSendManagerConfig)  {
//				panic("mock out the ResetTo method")
//			},
//			RunFunc: func(contextMoqParam context.Context)  {
//				panic("mock out the Run method")
//			},
//			ShutdownFunc: func(ctx context.Context) error {
//				panic("mock out the Shutdown method")
//			},
//		}
//
//		// use mockedManagerRefillSender in code that requires relabeler.ManagerRefillSender
//		// and then make assertions.
//
//	}
type ManagerRefillSenderMock struct {
	// ResetToFunc mocks the ResetTo method.
	ResetToFunc func(workingDir string, dialers []relabeler.Dialer, rsmCfg *relabeler.RefillSendManagerConfig)

	// RunFunc mocks the Run method.
	RunFunc func(contextMoqParam context.Context)

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// ResetTo holds details about calls to the ResetTo method.
		ResetTo []struct {
			// WorkingDir is the workingDir argument value.
			WorkingDir string
			// Dialers is the dialers argument value.
			Dialers []relabeler.Dialer
			// RsmCfg is the rsmCfg argument value.
			RsmCfg *relabeler.RefillSendManagerConfig
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockResetTo  sync.RWMutex
	lockRun      sync.RWMutex
	lockShutdown sync.RWMutex
}

// ResetTo calls ResetToFunc.
func (mock *ManagerRefillSenderMock) ResetTo(workingDir string, dialers []relabeler.Dialer, rsmCfg *relabeler.RefillSendManagerConfig) {
	if mock.ResetToFunc == nil {
		panic("ManagerRefillSenderMock.ResetToFunc: method is nil but ManagerRefillSender.ResetTo was just called")
	}
	callInfo := struct {
		WorkingDir string
		Dialers    []relabeler.Dialer
		RsmCfg     *relabeler.RefillSendManagerConfig
	}{
		WorkingDir: workingDir,
		Dialers:    dialers,
		RsmCfg:     rsmCfg,
	}
	mock.lockResetTo.Lock()
	mock.calls.ResetTo = append(mock.calls.ResetTo, callInfo)
	mock.lockResetTo.Unlock()
	mock.ResetToFunc(workingDir, dialers, rsmCfg)
}

// ResetToCalls gets all the calls that were made to ResetTo.
// Check the length with:
//
//	len(mockedManagerRefillSender.ResetToCalls())
func (mock *ManagerRefillSenderMock) ResetToCalls() []struct {
	WorkingDir string
	Dialers    []relabeler.Dialer
	RsmCfg     *relabeler.RefillSendManagerConfig
} {
	var calls []struct {
		WorkingDir string
		Dialers    []relabeler.Dialer
		RsmCfg     *relabeler.RefillSendManagerConfig
	}
	mock.lockResetTo.RLock()
	calls = mock.calls.ResetTo
	mock.lockResetTo.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *ManagerRefillSenderMock) Run(contextMoqParam context.Context) {
	if mock.RunFunc == nil {
		panic("ManagerRefillSenderMock.RunFunc: method is nil but ManagerRefillSender.Run was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	mock.RunFunc(contextMoqParam)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedManagerRefillSender.RunCalls())
func (mock *ManagerRefillSenderMock) RunCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *ManagerRefillSenderMock) Shutdown(ctx context.Context) error {
	if mock.ShutdownFunc == nil {
		panic("ManagerRefillSenderMock.ShutdownFunc: method is nil but ManagerRefillSender.Shutdown was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	return mock.ShutdownFunc(ctx)
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedManagerRefillSender.ShutdownCalls())
func (mock *ManagerRefillSenderMock) ShutdownCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}

// Ensure, that TransportMock does implement relabeler.Transport.
// If this is not the case, regenerate this file with moq.
var _ relabeler.Transport = &TransportMock{}

// TransportMock is a mock implementation of relabeler.Transport.
//
//	func TestSomethingThatUsesTransport(t *testing.T) {
//
//		// make and configure a mocked relabeler.Transport
//		mockedTransport := &TransportMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ListenFunc: func(ctx context.Context)  {
//				panic("mock out the Listen method")
//			},
//			OnAckFunc: func(fn func(uint32))  {
//				panic("mock out the OnAck method")
//			},
//			OnReadErrorFunc: func(fn func(err error))  {
//				panic("mock out the OnReadError method")
//			},
//			OnRejectFunc: func(fn func(uint32))  {
//				panic("mock out the OnReject method")
//			},
//			SendFunc: func(contextMoqParam context.Context, frameWriter frames.FrameWriter) error {
//				panic("mock out the Send method")
//			},
//		}
//
//		// use mockedTransport in code that requires relabeler.Transport
//		// and then make assertions.
//
//	}
type TransportMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ListenFunc mocks the Listen method.
	ListenFunc func(ctx context.Context)

	// OnAckFunc mocks the OnAck method.
	OnAckFunc func(fn func(uint32))

	// OnReadErrorFunc mocks the OnReadError method.
	OnReadErrorFunc func(fn func(err error))

	// OnRejectFunc mocks the OnReject method.
	OnRejectFunc func(fn func(uint32))

	// SendFunc mocks the Send method.
	SendFunc func(contextMoqParam context.Context, frameWriter frames.FrameWriter) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Listen holds details about calls to the Listen method.
		Listen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// OnAck holds details about calls to the OnAck method.
		OnAck []struct {
			// Fn is the fn argument value.
			Fn func(uint32)
		}
		// OnReadError holds details about calls to the OnReadError method.
		OnReadError []struct {
			// Fn is the fn argument value.
			Fn func(err error)
		}
		// OnReject holds details about calls to the OnReject method.
		OnReject []struct {
			// Fn is the fn argument value.
			Fn func(uint32)
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// FrameWriter is the frameWriter argument value.
			FrameWriter frames.FrameWriter
		}
	}
	lockClose       sync.RWMutex
	lockListen      sync.RWMutex
	lockOnAck       sync.RWMutex
	lockOnReadError sync.RWMutex
	lockOnReject    sync.RWMutex
	lockSend        sync.RWMutex
}

// Close calls CloseFunc.
func (mock *TransportMock) Close() error {
	if mock.CloseFunc == nil {
		panic("TransportMock.CloseFunc: method is nil but Transport.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedTransport.CloseCalls())
func (mock *TransportMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Listen calls ListenFunc.
func (mock *TransportMock) Listen(ctx context.Context) {
	if mock.ListenFunc == nil {
		panic("TransportMock.ListenFunc: method is nil but Transport.Listen was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListen.Lock()
	mock.calls.Listen = append(mock.calls.Listen, callInfo)
	mock.lockListen.Unlock()
	mock.ListenFunc(ctx)
}

// ListenCalls gets all the calls that were made to Listen.
// Check the length with:
//
//	len(mockedTransport.ListenCalls())
func (mock *TransportMock) ListenCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListen.RLock()
	calls = mock.calls.Listen
	mock.lockListen.RUnlock()
	return calls
}

// OnAck calls OnAckFunc.
func (mock *TransportMock) OnAck(fn func(uint32)) {
	if mock.OnAckFunc == nil {
		panic("TransportMock.OnAckFunc: method is nil but Transport.OnAck was just called")
	}
	callInfo := struct {
		Fn func(uint32)
	}{
		Fn: fn,
	}
	mock.lockOnAck.Lock()
	mock.calls.OnAck = append(mock.calls.OnAck, callInfo)
	mock.lockOnAck.Unlock()
	mock.OnAckFunc(fn)
}

// OnAckCalls gets all the calls that were made to OnAck.
// Check the length with:
//
//	len(mockedTransport.OnAckCalls())
func (mock *TransportMock) OnAckCalls() []struct {
	Fn func(uint32)
} {
	var calls []struct {
		Fn func(uint32)
	}
	mock.lockOnAck.RLock()
	calls = mock.calls.OnAck
	mock.lockOnAck.RUnlock()
	return calls
}

// OnReadError calls OnReadErrorFunc.
func (mock *TransportMock) OnReadError(fn func(err error)) {
	if mock.OnReadErrorFunc == nil {
		panic("TransportMock.OnReadErrorFunc: method is nil but Transport.OnReadError was just called")
	}
	callInfo := struct {
		Fn func(err error)
	}{
		Fn: fn,
	}
	mock.lockOnReadError.Lock()
	mock.calls.OnReadError = append(mock.calls.OnReadError, callInfo)
	mock.lockOnReadError.Unlock()
	mock.OnReadErrorFunc(fn)
}

// OnReadErrorCalls gets all the calls that were made to OnReadError.
// Check the length with:
//
//	len(mockedTransport.OnReadErrorCalls())
func (mock *TransportMock) OnReadErrorCalls() []struct {
	Fn func(err error)
} {
	var calls []struct {
		Fn func(err error)
	}
	mock.lockOnReadError.RLock()
	calls = mock.calls.OnReadError
	mock.lockOnReadError.RUnlock()
	return calls
}

// OnReject calls OnRejectFunc.
func (mock *TransportMock) OnReject(fn func(uint32)) {
	if mock.OnRejectFunc == nil {
		panic("TransportMock.OnRejectFunc: method is nil but Transport.OnReject was just called")
	}
	callInfo := struct {
		Fn func(uint32)
	}{
		Fn: fn,
	}
	mock.lockOnReject.Lock()
	mock.calls.OnReject = append(mock.calls.OnReject, callInfo)
	mock.lockOnReject.Unlock()
	mock.OnRejectFunc(fn)
}

// OnRejectCalls gets all the calls that were made to OnReject.
// Check the length with:
//
//	len(mockedTransport.OnRejectCalls())
func (mock *TransportMock) OnRejectCalls() []struct {
	Fn func(uint32)
} {
	var calls []struct {
		Fn func(uint32)
	}
	mock.lockOnReject.RLock()
	calls = mock.calls.OnReject
	mock.lockOnReject.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *TransportMock) Send(contextMoqParam context.Context, frameWriter frames.FrameWriter) error {
	if mock.SendFunc == nil {
		panic("TransportMock.SendFunc: method is nil but Transport.Send was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		FrameWriter     frames.FrameWriter
	}{
		ContextMoqParam: contextMoqParam,
		FrameWriter:     frameWriter,
	}
	mock.lockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	mock.lockSend.Unlock()
	return mock.SendFunc(contextMoqParam, frameWriter)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//
//	len(mockedTransport.SendCalls())
func (mock *TransportMock) SendCalls() []struct {
	ContextMoqParam context.Context
	FrameWriter     frames.FrameWriter
} {
	var calls []struct {
		ContextMoqParam context.Context
		FrameWriter     frames.FrameWriter
	}
	mock.lockSend.RLock()
	calls = mock.calls.Send
	mock.lockSend.RUnlock()
	return calls
}

// Ensure, that RejectNotifyerMock does implement relabeler.RejectNotifyer.
// If this is not the case, regenerate this file with moq.
var _ relabeler.RejectNotifyer = &RejectNotifyerMock{}

// RejectNotifyerMock is a mock implementation of relabeler.RejectNotifyer.
//
//	func TestSomethingThatUsesRejectNotifyer(t *testing.T) {
//
//		// make and configure a mocked relabeler.RejectNotifyer
//		mockedRejectNotifyer := &RejectNotifyerMock{
//			NotifyOnRejectFunc: func()  {
//				panic("mock out the NotifyOnReject method")
//			},
//		}
//
//		// use mockedRejectNotifyer in code that requires relabeler.RejectNotifyer
//		// and then make assertions.
//
//	}
type RejectNotifyerMock struct {
	// NotifyOnRejectFunc mocks the NotifyOnReject method.
	NotifyOnRejectFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// NotifyOnReject holds details about calls to the NotifyOnReject method.
		NotifyOnReject []struct {
		}
	}
	lockNotifyOnReject sync.RWMutex
}

// NotifyOnReject calls NotifyOnRejectFunc.
func (mock *RejectNotifyerMock) NotifyOnReject() {
	if mock.NotifyOnRejectFunc == nil {
		panic("RejectNotifyerMock.NotifyOnRejectFunc: method is nil but RejectNotifyer.NotifyOnReject was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNotifyOnReject.Lock()
	mock.calls.NotifyOnReject = append(mock.calls.NotifyOnReject, callInfo)
	mock.lockNotifyOnReject.Unlock()
	mock.NotifyOnRejectFunc()
}

// NotifyOnRejectCalls gets all the calls that were made to NotifyOnReject.
// Check the length with:
//
//	len(mockedRejectNotifyer.NotifyOnRejectCalls())
func (mock *RejectNotifyerMock) NotifyOnRejectCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNotifyOnReject.RLock()
	calls = mock.calls.NotifyOnReject
	mock.lockNotifyOnReject.RUnlock()
	return calls
}

// Ensure, that SourceMock does implement relabeler.Source.
// If this is not the case, regenerate this file with moq.
var _ relabeler.Source = &SourceMock{}

// SourceMock is a mock implementation of relabeler.Source.
//
//	func TestSomethingThatUsesSource(t *testing.T) {
//
//		// make and configure a mocked relabeler.Source
//		mockedSource := &SourceMock{
//			AckFunc: func(key cppbridge.SegmentKey, dest string)  {
//				panic("mock out the Ack method")
//			},
//			GetFunc: func(ctx context.Context, key cppbridge.SegmentKey) (relabeler.Segment, error) {
//				panic("mock out the Get method")
//			},
//			RejectFunc: func(key cppbridge.SegmentKey, dest string)  {
//				panic("mock out the Reject method")
//			},
//		}
//
//		// use mockedSource in code that requires relabeler.Source
//		// and then make assertions.
//
//	}
type SourceMock struct {
	// AckFunc mocks the Ack method.
	AckFunc func(key cppbridge.SegmentKey, dest string)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, key cppbridge.SegmentKey) (relabeler.Segment, error)

	// RejectFunc mocks the Reject method.
	RejectFunc func(key cppbridge.SegmentKey, dest string)

	// calls tracks calls to the methods.
	calls struct {
		// Ack holds details about calls to the Ack method.
		Ack []struct {
			// Key is the key argument value.
			Key cppbridge.SegmentKey
			// Dest is the dest argument value.
			Dest string
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key cppbridge.SegmentKey
		}
		// Reject holds details about calls to the Reject method.
		Reject []struct {
			// Key is the key argument value.
			Key cppbridge.SegmentKey
			// Dest is the dest argument value.
			Dest string
		}
	}
	lockAck    sync.RWMutex
	lockGet    sync.RWMutex
	lockReject sync.RWMutex
}

// Ack calls AckFunc.
func (mock *SourceMock) Ack(key cppbridge.SegmentKey, dest string) {
	if mock.AckFunc == nil {
		panic("SourceMock.AckFunc: method is nil but Source.Ack was just called")
	}
	callInfo := struct {
		Key  cppbridge.SegmentKey
		Dest string
	}{
		Key:  key,
		Dest: dest,
	}
	mock.lockAck.Lock()
	mock.calls.Ack = append(mock.calls.Ack, callInfo)
	mock.lockAck.Unlock()
	mock.AckFunc(key, dest)
}

// AckCalls gets all the calls that were made to Ack.
// Check the length with:
//
//	len(mockedSource.AckCalls())
func (mock *SourceMock) AckCalls() []struct {
	Key  cppbridge.SegmentKey
	Dest string
} {
	var calls []struct {
		Key  cppbridge.SegmentKey
		Dest string
	}
	mock.lockAck.RLock()
	calls = mock.calls.Ack
	mock.lockAck.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *SourceMock) Get(ctx context.Context, key cppbridge.SegmentKey) (relabeler.Segment, error) {
	if mock.GetFunc == nil {
		panic("SourceMock.GetFunc: method is nil but Source.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key cppbridge.SegmentKey
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedSource.GetCalls())
func (mock *SourceMock) GetCalls() []struct {
	Ctx context.Context
	Key cppbridge.SegmentKey
} {
	var calls []struct {
		Ctx context.Context
		Key cppbridge.SegmentKey
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Reject calls RejectFunc.
func (mock *SourceMock) Reject(key cppbridge.SegmentKey, dest string) {
	if mock.RejectFunc == nil {
		panic("SourceMock.RejectFunc: method is nil but Source.Reject was just called")
	}
	callInfo := struct {
		Key  cppbridge.SegmentKey
		Dest string
	}{
		Key:  key,
		Dest: dest,
	}
	mock.lockReject.Lock()
	mock.calls.Reject = append(mock.calls.Reject, callInfo)
	mock.lockReject.Unlock()
	mock.RejectFunc(key, dest)
}

// RejectCalls gets all the calls that were made to Reject.
// Check the length with:
//
//	len(mockedSource.RejectCalls())
func (mock *SourceMock) RejectCalls() []struct {
	Key  cppbridge.SegmentKey
	Dest string
} {
	var calls []struct {
		Key  cppbridge.SegmentKey
		Dest string
	}
	mock.lockReject.RLock()
	calls = mock.calls.Reject
	mock.lockReject.RUnlock()
	return calls
}
