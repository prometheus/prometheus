// Copyright 2025 The Prometheus Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build ignore

package main

import (
	"bytes"
	"embed"
	"go/format"
	"io/fs"
	"iter"
	"log"
	"maps"
	"os"
	"regexp"
	"slices"
	"strings"
	"text/template"

	"github.com/prometheus/prometheus/promql"
	"github.com/prometheus/prometheus/promql/parser"
)

//go:embed promqltest/testdata
var testsFs embed.FS

// querySeq returns an iterator that yields all query strings found in the test file content.
func findQueries(testFile string) iter.Seq[string] {
	evalRegex := regexp.MustCompile(`^(\s*eval\s+(?:instant at \d+m?|range from \d+m? to \d+m? step \d+m?) )(.*)$`)
	return func(yield func(string) bool) {
		lines := strings.Split(testFile, "\n")
		for _, line := range lines {
			matches := evalRegex.FindStringSubmatch(line)
			// Group 2 is the query part
			if len(matches) == 3 {
				if !yield(matches[2]) {
					return
				}
			}
		}
	}
}

type queryCase struct {
	Source, Query, Piped, SinglePiped string
}

func main() {
	parser.EnableExperimentalFunctions = true
	parser.ExperimentalDurationExpr = true
	parser.EnableExtendedRangeSelectors = true

	files, err := fs.Glob(testsFs, "promqltest/testdata/*.test")
	if err != nil {
		log.Fatal(err)
	}

	queries := map[string]queryCase{}
	for _, fn := range files {
		content, err := fs.ReadFile(testsFs, fn)
		if err != nil {
			log.Fatal(err)
		}

		for query := range findQueries(string(content)) {
			piped, err := promql.ToPiped(query)
			if err != nil {
				// Best effort, caller will fix it.
				piped = err.Error()
			}
			queries[query] = queryCase{Source: fn, Query: query, Piped: piped}
		}
	}

	sortedQueries := slices.SortedFunc(maps.Values(queries), func(a, b queryCase) int {
		cmp := strings.Compare(a.Source, b.Source)
		if cmp == 0 {
			return strings.Compare(a.Query, b.Query)
		}
		return cmp
	})

	// Generate code.
	var buf bytes.Buffer
	err = testFile.Execute(&buf, struct {
		Queries []queryCase
	}{
		Queries: sortedQueries,
	})
	if err != nil {
		log.Fatalf("executing template: %v", err)
	}

	// Format it.
	result, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("formating code: %v", err)
	}

	// Write it to a file.
	if err := os.WriteFile("pipe_cases_test.go", result, 0o644); err != nil {
		log.Fatalf("writing file: %v", err)
	}
}

var testFile = template.Must(template.New("testFile").Parse(`// Code generated by pipe_cases_test.gen.go; DO NOT EDIT.
//go:generate go run pipe_cases_test.gen.go

package promql_test

type pipedCase struct {
	query, piped string
}

var pipedCases = []pipedCase{
{{ range .Queries -}}
	{
		// Source: {{ .Source }}
		query: ` + "`" + `{{ .Query }}` + "`" + `,
		piped: ` + "`" + `{{ .Piped }}` + "`" + `,
	},
{{end}}
}
`))
