# Two histograms with 4 buckets each (x_sum and x_count not included,
# only buckets). Lowest bucket for one histogram < 0, for the other >
# 0. They have the same name, just separated by label. Not useful in
# practice, but can happen (if clients change bucketing), and the
# server has to cope with it.

# Test histogram.
load 5m
# buckets contains a list of lists
# Each set of observations represents a stream of observations:
# {{ buckets: [0 1 1 10 5 2, 14 25 13]}}
# This will represent
# an observation of 0 an 14 at t=0
# an observation of 1 and 25 at t=1
# an observation of 1 and 23 at t=2
# etc.
	testsparsehistogram{start="positive"} {{ schema: 0, buckets:[5x10,0+7x10,0+11x10,0+12x10] }}
	#testsparsehistogram{start="positive"} {{ buckets:[5+0x10,0+7x10,0+11x10,0+12x10] }}
	#testhistogram_bucket{le=".2", start="positive"}
	#testhistogram_bucket{le="1e0", start="positive"}
	#testhistogram_bucket{le="+Inf", start="positive"}

#	testhistogram_bucket{le="-.2", start="negative"}	0+1x10
#	testhistogram_bucket{le="-0.1", start="negative"}	0+2x10
#	testhistogram_bucket{le="0.3", start="negative"}	0+2x10
#	testhistogram_bucket{le="+Inf", start="negative"}	0+3x10

# Another test histogram, where q(1/6), q(1/2), and q(5/6) are each in
# the middle of a bucket and should therefore be 1, 3, and 5,
# respectively.
#load 5m
#	testhistogram2_bucket{le="0"}	 0+0x10
#	testhistogram2_bucket{le="2"}	 0+1x10
#	testhistogram2_bucket{le="4"}    0+2x10
#	testhistogram2_bucket{le="6"}	 0+3x10
#	testhistogram2_bucket{le="+Inf"} 0+3x10
#
## Now a more realistic histogram per job and instance to test aggregation.
#load 5m
#	request_duration_seconds_bucket{job="job1", instance="ins1", le="0.1"}	0+1x10
#	request_duration_seconds_bucket{job="job1", instance="ins1", le="0.2"}	0+3x10
#	request_duration_seconds_bucket{job="job1", instance="ins1", le="+Inf"}	0+4x10
#	request_duration_seconds_bucket{job="job1", instance="ins2", le="0.1"}	0+2x10
#	request_duration_seconds_bucket{job="job1", instance="ins2", le="0.2"}	0+5x10
#	request_duration_seconds_bucket{job="job1", instance="ins2", le="+Inf"}	0+6x10
#	request_duration_seconds_bucket{job="job2", instance="ins1", le="0.1"}	0+3x10
#	request_duration_seconds_bucket{job="job2", instance="ins1", le="0.2"}	0+4x10
#	request_duration_seconds_bucket{job="job2", instance="ins1", le="+Inf"}	0+6x10
#	request_duration_seconds_bucket{job="job2", instance="ins2", le="0.1"}	0+4x10
#	request_duration_seconds_bucket{job="job2", instance="ins2", le="0.2"}	0+7x10
#	request_duration_seconds_bucket{job="job2", instance="ins2", le="+Inf"}	0+9x10
#
## Different le representations in one histogram.
#load 5m
#	http_request_duration_seconds{job="job1"}       [0,1,0,0,1,1,0,0]+1x10
#
#########
##
##
## START
##
##
#########
#eval instant at 5m histogram_sum(rate(http_request_duration_seconds[10m])) / histogram_count(rate(http_request_duration_seconds[10m]))
#        {job="job1"} 50
#########
## END
#########
#
## Quantile too low.
#eval instant at 50m histogram_quantile(-0.1, testhistogram_bucket)
#	{start="positive"} -Inf
#	{start="negative"} -Inf
#
## Quantile too high.
#eval instant at 50m histogram_quantile(1.01, testhistogram_bucket)
#	{start="positive"} +Inf
#	{start="negative"} +Inf
#
## Quantile invalid.
#eval instant at 50m histogram_quantile(NaN, testhistogram_bucket)
#	{start="positive"} NaN
#	{start="negative"} NaN
#
## Quantile value in lowest bucket, which is positive.
#eval instant at 50m histogram_quantile(0, testhistogram_bucket{start="positive"})
#	{start="positive"} 0
#
## Quantile value in lowest bucket, which is negative.
#eval instant at 50m histogram_quantile(0, testhistogram_bucket{start="negative"})
#	{start="negative"} -0.2
#
## Aggregated histogram: Everything in one. Now with avg, which does not change anything.
#eval instant at 50m histogram_quantile(0.3, avg(rate(request_duration_seconds_bucket[5m])) by (le))
#	{} 0.075
#
#eval instant at 50m histogram_quantile(0.5, avg(rate(request_duration_seconds_bucket[5m])) by (le))
#	{} 0.12777777777777778
#
## Aggregated histogram: By instance.
#eval instant at 50m histogram_quantile(0.3, sum(rate(request_duration_seconds_bucket[5m])) by (le, instance))
#	{instance="ins1"} 0.075
#	{instance="ins2"} 0.075
#
#eval instant at 50m histogram_quantile(0.5, sum(rate(request_duration_seconds_bucket[5m])) by (le, instance))
#	{instance="ins1"} 0.1333333333
#	{instance="ins2"} 0.125
## A histogram with nonmonotonic bucket counts. This may happen when recording
## rule evaluation or federation races scrape ingestion, causing some buckets
## counts to be derived from fewer samples.
#
#load 5m
#    nonmonotonic_bucket{le="0.1"}   0+2x10
#    nonmonotonic_bucket{le="1"}     0+1x10
#    nonmonotonic_bucket{le="10"}    0+5x10
#    nonmonotonic_bucket{le="100"}   0+4x10
#    nonmonotonic_bucket{le="1000"}  0+9x10
#    nonmonotonic_bucket{le="+Inf"}  0+8x10
#
## Buckets with different representations of the same upper bound.
#eval instant at 50m histogram_quantile(0.5, rate(mixed_bucket[5m]))
#	{instance="ins1", job="job1"} 0.15
#	{instance="ins2", job="job1"} NaN
#
#eval instant at 50m histogram_quantile(0.75, rate(mixed_bucket[5m]))
#	{instance="ins1", job="job1"} 0.2
#	{instance="ins2", job="job1"} NaN
#
#eval instant at 50m histogram_quantile(1, rate(mixed_bucket[5m]))
#	{instance="ins1", job="job1"} 0.2
#	{instance="ins2", job="job1"} NaN
#
#load 5m
#	empty_bucket{le="0.1", job="job1", instance="ins1"}    0x10
#	empty_bucket{le="0.2", job="job1", instance="ins1"}    0x10
#	empty_bucket{le="+Inf", job="job1", instance="ins1"}   0x10
#
#eval instant at 50m histogram_quantile(0.2, rate(empty_bucket[5m]))
#	{instance="ins1", job="job1"} NaN
#
## Load a duplicate histogram with a different name to test failure scenario on multiple histograms with the same label set
## https://github.com/prometheus/prometheus/issues/9910
#load 5m
#	request_duration_seconds2_bucket{job="job1", instance="ins1", le="0.1"}	0+1x10
#	request_duration_seconds2_bucket{job="job1", instance="ins1", le="0.2"}	0+3x10
#	request_duration_seconds2_bucket{job="job1", instance="ins1", le="+Inf"}	0+4x10
#
#eval_fail instant at 50m histogram_quantile(0.99, {__name__=~"request_duration.*"})
