// Package servicefabric implements the Azure ARM Servicefabric service API version 6.1.2.
//
// Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
package servicefabric

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/satori/go.uuid"
	"net/http"
)

const (
	// DefaultBaseURI is the default URI used for the service Servicefabric
	DefaultBaseURI = "http://localhost:19080"
)

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// BaseClient is the base client for Servicefabric.
type BaseClient struct {
	autorest.Client
	BaseURI string
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// New creates an instance of the BaseClient client.
func New() BaseClient {
	return NewWithBaseURI(DefaultBaseURI)
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string) BaseClient {
	return BaseClient{
		Client:  autorest.NewClientWithUserAgent(UserAgent()),
		BaseURI: baseURI,
	}
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CancelOperation the following is a list of APIs that start fault operations that may be cancelled using
// CancelOperation -
// - StartDataLoss
// - StartQuorumLoss
// - StartPartitionRestart
// - StartNodeTransition
//
// If force is false, then the specified user-induced operation will be gracefully stopped and cleaned up.  If force is
// true, the command will be aborted, and some internal state
// may be left behind.  Specifying force as true should be used with care.  Calling this API with force set to true is
// not allowed until this API has already
// been called on the same test command with force set to false first, or unless the test command already has an
// OperationState of OperationState.RollingBack.
// Clarification: OperationState.RollingBack means that the system will/is be cleaning up internal system state caused
// by executing the command.  It will not restore data if the
// test command was to cause data loss.  For example, if you call StartDataLoss then call this API, the system will
// only clean up internal state from running the command.
// It will not restore the target partition's data, if the command progressed far enough to cause data loss.
//
// Important note:  if this API is invoked with force==true, internal state may be left behind.
// Parameters:
// operationID - a GUID that identifies a call of this API.  This is passed into the corresponding GetProgress
// API
// force - indicates whether to gracefully rollback and clean up internal system state modified by executing
// the user-induced operation.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) CancelOperation(ctx context.Context, operationID uuid.UUID, force bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "CancelOperation", err.Error())
	}

	req, err := client.CancelOperationPreparer(ctx, operationID, force, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelOperation", nil, "Failure preparing request")
		return
	}

	resp, err := client.CancelOperationSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelOperation", resp, "Failure sending request")
		return
	}

	result, err = client.CancelOperationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelOperation", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CancelOperationPreparer prepares the CancelOperation request.
func (client BaseClient) CancelOperationPreparer(ctx context.Context, operationID uuid.UUID, force bool, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"Force":       autorest.Encode("query", force),
		"OperationId": autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Faults/$/Cancel"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CancelOperationSender sends the CancelOperation request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CancelOperationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CancelOperationResponder handles the response to the CancelOperation request. The method always
// closes the http.Response Body.
func (client BaseClient) CancelOperationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CancelRepairTask this API supports the Service Fabric platform; it is not meant to be used directly from your code.
// Parameters:
// repairTaskCancelDescription - describes the repair task to be cancelled.
func (client BaseClient) CancelRepairTask(ctx context.Context, repairTaskCancelDescription RepairTaskCancelDescription) (result RepairTaskUpdateInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTaskCancelDescription,
			Constraints: []validation.Constraint{{Target: "repairTaskCancelDescription.TaskID", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "CancelRepairTask", err.Error())
	}

	req, err := client.CancelRepairTaskPreparer(ctx, repairTaskCancelDescription)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelRepairTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.CancelRepairTaskSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelRepairTask", resp, "Failure sending request")
		return
	}

	result, err = client.CancelRepairTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CancelRepairTask", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CancelRepairTaskPreparer prepares the CancelRepairTask request.
func (client BaseClient) CancelRepairTaskPreparer(ctx context.Context, repairTaskCancelDescription RepairTaskCancelDescription) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/CancelRepairTask"),
		autorest.WithJSON(repairTaskCancelDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CancelRepairTaskSender sends the CancelRepairTask request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CancelRepairTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CancelRepairTaskResponder handles the response to the CancelRepairTask request. The method always
// closes the http.Response Body.
func (client BaseClient) CancelRepairTaskResponder(resp *http.Response) (result RepairTaskUpdateInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CommitImageStoreUploadSession when all file chunks have been uploaded, the upload session needs to be committed
// explicitly to complete the upload. Image store preserves the upload session until the expiration time, which is 30
// minutes after the last chunk received.
// Parameters:
// sessionID - a GUID generated by the user for a file uploading. It identifies an image store upload session
// which keeps track of all file chunks until it is committed.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) CommitImageStoreUploadSession(ctx context.Context, sessionID uuid.UUID, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "CommitImageStoreUploadSession", err.Error())
	}

	req, err := client.CommitImageStoreUploadSessionPreparer(ctx, sessionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CommitImageStoreUploadSession", nil, "Failure preparing request")
		return
	}

	resp, err := client.CommitImageStoreUploadSessionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CommitImageStoreUploadSession", resp, "Failure sending request")
		return
	}

	result, err = client.CommitImageStoreUploadSessionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CommitImageStoreUploadSession", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CommitImageStoreUploadSessionPreparer prepares the CommitImageStoreUploadSession request.
func (client BaseClient) CommitImageStoreUploadSessionPreparer(ctx context.Context, sessionID uuid.UUID, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"session-id":  autorest.Encode("query", sessionID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ImageStore/$/CommitUploadSession"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CommitImageStoreUploadSessionSender sends the CommitImageStoreUploadSession request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CommitImageStoreUploadSessionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CommitImageStoreUploadSessionResponder handles the response to the CommitImageStoreUploadSession request. The method always
// closes the http.Response Body.
func (client BaseClient) CommitImageStoreUploadSessionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CopyImageStoreContent copies the image store content from the source image store relative path to the destination
// image store relative path.
// Parameters:
// imageStoreCopyDescription - describes the copy description for the image store.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) CopyImageStoreContent(ctx context.Context, imageStoreCopyDescription ImageStoreCopyDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: imageStoreCopyDescription,
			Constraints: []validation.Constraint{{Target: "imageStoreCopyDescription.RemoteSource", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "imageStoreCopyDescription.RemoteDestination", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "CopyImageStoreContent", err.Error())
	}

	req, err := client.CopyImageStoreContentPreparer(ctx, imageStoreCopyDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CopyImageStoreContent", nil, "Failure preparing request")
		return
	}

	resp, err := client.CopyImageStoreContentSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CopyImageStoreContent", resp, "Failure sending request")
		return
	}

	result, err = client.CopyImageStoreContentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CopyImageStoreContent", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CopyImageStoreContentPreparer prepares the CopyImageStoreContent request.
func (client BaseClient) CopyImageStoreContentPreparer(ctx context.Context, imageStoreCopyDescription ImageStoreCopyDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ImageStore/$/Copy"),
		autorest.WithJSON(imageStoreCopyDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CopyImageStoreContentSender sends the CopyImageStoreContent request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CopyImageStoreContentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CopyImageStoreContentResponder handles the response to the CopyImageStoreContent request. The method always
// closes the http.Response Body.
func (client BaseClient) CopyImageStoreContentResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateApplication creates a Service Fabric application using the specified description.
// Parameters:
// applicationDescription - description for creating an application.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) CreateApplication(ctx context.Context, applicationDescription ApplicationDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: applicationDescription,
			Constraints: []validation.Constraint{{Target: "applicationDescription.Name", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "applicationDescription.TypeName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "applicationDescription.TypeVersion", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "applicationDescription.ApplicationCapacity", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "applicationDescription.ApplicationCapacity.MinimumNodes", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "applicationDescription.ApplicationCapacity.MinimumNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}},
						{Target: "applicationDescription.ApplicationCapacity.MaximumNodes", Name: validation.Null, Rule: false,
							Chain: []validation.Constraint{{Target: "applicationDescription.ApplicationCapacity.MaximumNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}},
					}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "CreateApplication", err.Error())
	}

	req, err := client.CreateApplicationPreparer(ctx, applicationDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateApplication", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateApplicationSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateApplication", resp, "Failure sending request")
		return
	}

	result, err = client.CreateApplicationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateApplication", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateApplicationPreparer prepares the CreateApplication request.
func (client BaseClient) CreateApplicationPreparer(ctx context.Context, applicationDescription ApplicationDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Applications/$/Create"),
		autorest.WithJSON(applicationDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateApplicationSender sends the CreateApplication request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateApplicationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateApplicationResponder handles the response to the CreateApplication request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateComposeDeployment compose is a file format that describes multi-container applications. This API allows
// deploying container based applications defined in compose format in a Service Fabric cluster. Once the deployment is
// created it's status can be tracked via `GetComposeDeploymentStatus` API.
// Parameters:
// createComposeDeploymentDescription - describes the compose deployment that needs to be created.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) CreateComposeDeployment(ctx context.Context, createComposeDeploymentDescription CreateComposeDeploymentDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: createComposeDeploymentDescription,
			Constraints: []validation.Constraint{{Target: "createComposeDeploymentDescription.DeploymentName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "createComposeDeploymentDescription.ComposeFileContent", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "CreateComposeDeployment", err.Error())
	}

	req, err := client.CreateComposeDeploymentPreparer(ctx, createComposeDeploymentDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateComposeDeployment", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateComposeDeploymentSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateComposeDeployment", resp, "Failure sending request")
		return
	}

	result, err = client.CreateComposeDeploymentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateComposeDeployment", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateComposeDeploymentPreparer prepares the CreateComposeDeployment request.
func (client BaseClient) CreateComposeDeploymentPreparer(ctx context.Context, createComposeDeploymentDescription CreateComposeDeploymentDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ComposeDeployments/$/Create"),
		autorest.WithJSON(createComposeDeploymentDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateComposeDeploymentSender sends the CreateComposeDeployment request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateComposeDeploymentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateComposeDeploymentResponder handles the response to the CreateComposeDeployment request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateComposeDeploymentResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateName creates the specified Service Fabric name.
// Parameters:
// nameDescription - describes the Service Fabric name to be created.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) CreateName(ctx context.Context, nameDescription NameDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: nameDescription,
			Constraints: []validation.Constraint{{Target: "nameDescription.Name", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "CreateName", err.Error())
	}

	req, err := client.CreateNamePreparer(ctx, nameDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateName", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateNameSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateName", resp, "Failure sending request")
		return
	}

	result, err = client.CreateNameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateName", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateNamePreparer prepares the CreateName request.
func (client BaseClient) CreateNamePreparer(ctx context.Context, nameDescription NameDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Names/$/Create"),
		autorest.WithJSON(nameDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateNameSender sends the CreateName request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateNameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateNameResponder handles the response to the CreateName request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateNameResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateRepairTask for clusters that have the Repair Manager Service configured,
// this API provides a way to create repair tasks that run automatically or manually.
// For repair tasks that run automatically, an appropriate repair executor
// must be running for each repair action to run automatically.
// These are currently only available in specially-configured Azure Cloud Services.
//
// To create a manual repair task, provide the set of impacted node names and the
// expected impact. When the state of the created repair task changes to approved,
// you can safely perform repair actions on those nodes.
//
// This API supports the Service Fabric platform; it is not meant to be used directly from your code.
// Parameters:
// repairTask - describes the repair task to be created or updated.
func (client BaseClient) CreateRepairTask(ctx context.Context, repairTask RepairTask) (result RepairTaskUpdateInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTask,
			Constraints: []validation.Constraint{{Target: "repairTask.TaskID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "repairTask.Action", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "CreateRepairTask", err.Error())
	}

	req, err := client.CreateRepairTaskPreparer(ctx, repairTask)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateRepairTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateRepairTaskSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateRepairTask", resp, "Failure sending request")
		return
	}

	result, err = client.CreateRepairTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateRepairTask", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateRepairTaskPreparer prepares the CreateRepairTask request.
func (client BaseClient) CreateRepairTaskPreparer(ctx context.Context, repairTask RepairTask) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/CreateRepairTask"),
		autorest.WithJSON(repairTask),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateRepairTaskSender sends the CreateRepairTask request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateRepairTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateRepairTaskResponder handles the response to the CreateRepairTask request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateRepairTaskResponder(resp *http.Response) (result RepairTaskUpdateInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateService this api allows creating a new Service Fabric stateless or stateful service under a specified Service
// Fabric application. The description for creating the service includes partitioning information and optional
// properties for placement and load balancing. Some of the properties can later be modified using `UpdateService` API.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// serviceDescription - the information necessary to create a service.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) CreateService(ctx context.Context, applicationID string, serviceDescription BasicServiceDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: serviceDescription,
			Constraints: []validation.Constraint{{Target: "serviceDescription.ServiceName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "serviceDescription.ServiceTypeName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "serviceDescription.PartitionDescription", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "CreateService", err.Error())
	}

	req, err := client.CreateServicePreparer(ctx, applicationID, serviceDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateService", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateServiceSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateService", resp, "Failure sending request")
		return
	}

	result, err = client.CreateServiceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateService", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateServicePreparer prepares the CreateService request.
func (client BaseClient) CreateServicePreparer(ctx context.Context, applicationID string, serviceDescription BasicServiceDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetServices/$/Create", pathParameters),
		autorest.WithJSON(serviceDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateServiceSender sends the CreateService request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateServiceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateServiceResponder handles the response to the CreateService request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateServiceResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateServiceFromTemplate creates a Service Fabric service from the service template defined in the application
// manifest. A service template contains the properties that will be same for the service instance of the same type.
// The API allows overriding the properties that are usually different for different services of the same service type.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// serviceFromTemplateDescription - describes the service that needs to be created from the template defined in
// the application manifest.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) CreateServiceFromTemplate(ctx context.Context, applicationID string, serviceFromTemplateDescription ServiceFromTemplateDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: serviceFromTemplateDescription,
			Constraints: []validation.Constraint{{Target: "serviceFromTemplateDescription.ApplicationName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "serviceFromTemplateDescription.ServiceName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "serviceFromTemplateDescription.ServiceTypeName", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "CreateServiceFromTemplate", err.Error())
	}

	req, err := client.CreateServiceFromTemplatePreparer(ctx, applicationID, serviceFromTemplateDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateServiceFromTemplate", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateServiceFromTemplateSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateServiceFromTemplate", resp, "Failure sending request")
		return
	}

	result, err = client.CreateServiceFromTemplateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "CreateServiceFromTemplate", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateServiceFromTemplatePreparer prepares the CreateServiceFromTemplate request.
func (client BaseClient) CreateServiceFromTemplatePreparer(ctx context.Context, applicationID string, serviceFromTemplateDescription ServiceFromTemplateDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetServices/$/CreateFromTemplate", pathParameters),
		autorest.WithJSON(serviceFromTemplateDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateServiceFromTemplateSender sends the CreateServiceFromTemplate request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateServiceFromTemplateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// CreateServiceFromTemplateResponder handles the response to the CreateServiceFromTemplate request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateServiceFromTemplateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteApplication deletes an existing Service Fabric application. An application must be created before it can be
// deleted. Deleting an application will delete all services that are part of that application. By default Service
// Fabric will try to close service replicas in a graceful manner and then delete the service. However if service is
// having issues closing the replica gracefully, the delete operation may take a long time or get stuck. Use the
// optional ForceRemove flag to skip the graceful close sequence and forcefully delete the application and all of the
// its services.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// forceRemove - remove a Service Fabric application or service forcefully without going through the graceful
// shutdown sequence. This parameter can be used to forcefully delete an application or service for which
// delete is timing out due to issues in the service code that prevents graceful close of replicas.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) DeleteApplication(ctx context.Context, applicationID string, forceRemove *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "DeleteApplication", err.Error())
	}

	req, err := client.DeleteApplicationPreparer(ctx, applicationID, forceRemove, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteApplication", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteApplicationSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteApplication", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteApplicationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteApplication", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteApplicationPreparer prepares the DeleteApplication request.
func (client BaseClient) DeleteApplicationPreparer(ctx context.Context, applicationID string, forceRemove *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if forceRemove != nil {
		queryParameters["ForceRemove"] = autorest.Encode("query", *forceRemove)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/Delete", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteApplicationSender sends the DeleteApplication request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteApplicationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteApplicationResponder handles the response to the DeleteApplication request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteApplicationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteImageStoreContent deletes existing image store content being found within the given image store relative path.
// This can be used to delete uploaded application packages once they are provisioned.
// Parameters:
// contentPath - relative path to file or folder in the image store from its root.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) DeleteImageStoreContent(ctx context.Context, contentPath string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "DeleteImageStoreContent", err.Error())
	}

	req, err := client.DeleteImageStoreContentPreparer(ctx, contentPath, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteImageStoreContent", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteImageStoreContentSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteImageStoreContent", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteImageStoreContentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteImageStoreContent", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteImageStoreContentPreparer prepares the DeleteImageStoreContent request.
func (client BaseClient) DeleteImageStoreContentPreparer(ctx context.Context, contentPath string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"contentPath": autorest.Encode("path", contentPath),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ImageStore/{contentPath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteImageStoreContentSender sends the DeleteImageStoreContent request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteImageStoreContentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteImageStoreContentResponder handles the response to the DeleteImageStoreContent request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteImageStoreContentResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteImageStoreUploadSession the DELETE request will cause the existing upload session to expire and remove any
// previously uploaded file chunks.
// Parameters:
// sessionID - a GUID generated by the user for a file uploading. It identifies an image store upload session
// which keeps track of all file chunks until it is committed.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) DeleteImageStoreUploadSession(ctx context.Context, sessionID uuid.UUID, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "DeleteImageStoreUploadSession", err.Error())
	}

	req, err := client.DeleteImageStoreUploadSessionPreparer(ctx, sessionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteImageStoreUploadSession", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteImageStoreUploadSessionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteImageStoreUploadSession", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteImageStoreUploadSessionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteImageStoreUploadSession", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteImageStoreUploadSessionPreparer prepares the DeleteImageStoreUploadSession request.
func (client BaseClient) DeleteImageStoreUploadSessionPreparer(ctx context.Context, sessionID uuid.UUID, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"session-id":  autorest.Encode("query", sessionID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ImageStore/$/DeleteUploadSession"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteImageStoreUploadSessionSender sends the DeleteImageStoreUploadSession request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteImageStoreUploadSessionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteImageStoreUploadSessionResponder handles the response to the DeleteImageStoreUploadSession request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteImageStoreUploadSessionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteName deletes the specified Service Fabric name. A name must be created before it can be deleted. Deleting a
// name with child properties will fail.
// Parameters:
// nameID - the Service Fabric name, without the 'fabric:' URI scheme.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) DeleteName(ctx context.Context, nameID string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "DeleteName", err.Error())
	}

	req, err := client.DeleteNamePreparer(ctx, nameID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteName", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteNameSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteName", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteNameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteName", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteNamePreparer prepares the DeleteName request.
func (client BaseClient) DeleteNamePreparer(ctx context.Context, nameID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteNameSender sends the DeleteName request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteNameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteNameResponder handles the response to the DeleteName request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteNameResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteProperty deletes the specified Service Fabric property under a given name. A property must be created before
// it can be deleted.
// Parameters:
// nameID - the Service Fabric name, without the 'fabric:' URI scheme.
// propertyName - specifies the name of the property to get.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) DeleteProperty(ctx context.Context, nameID string, propertyName string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "DeleteProperty", err.Error())
	}

	req, err := client.DeletePropertyPreparer(ctx, nameID, propertyName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteProperty", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeletePropertySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteProperty", resp, "Failure sending request")
		return
	}

	result, err = client.DeletePropertyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteProperty", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeletePropertyPreparer prepares the DeleteProperty request.
func (client BaseClient) DeletePropertyPreparer(ctx context.Context, nameID string, propertyName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":  APIVersion,
		"PropertyName": autorest.Encode("query", propertyName),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetProperty", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeletePropertySender sends the DeleteProperty request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeletePropertySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeletePropertyResponder handles the response to the DeleteProperty request. The method always
// closes the http.Response Body.
func (client BaseClient) DeletePropertyResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteRepairTask this API supports the Service Fabric platform; it is not meant to be used directly from your code.
// Parameters:
// repairTaskDeleteDescription - describes the repair task to be deleted.
func (client BaseClient) DeleteRepairTask(ctx context.Context, repairTaskDeleteDescription RepairTaskDeleteDescription) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTaskDeleteDescription,
			Constraints: []validation.Constraint{{Target: "repairTaskDeleteDescription.TaskID", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "DeleteRepairTask", err.Error())
	}

	req, err := client.DeleteRepairTaskPreparer(ctx, repairTaskDeleteDescription)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteRepairTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteRepairTaskSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteRepairTask", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteRepairTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteRepairTask", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteRepairTaskPreparer prepares the DeleteRepairTask request.
func (client BaseClient) DeleteRepairTaskPreparer(ctx context.Context, repairTaskDeleteDescription RepairTaskDeleteDescription) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/DeleteRepairTask"),
		autorest.WithJSON(repairTaskDeleteDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteRepairTaskSender sends the DeleteRepairTask request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteRepairTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteRepairTaskResponder handles the response to the DeleteRepairTask request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteRepairTaskResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteService deletes an existing Service Fabric service. A service must be created before it can be deleted. By
// default Service Fabric will try to close service replicas in a graceful manner and then delete the service. However
// if service is having issues closing the replica gracefully, the delete operation may take a long time or get stuck.
// Use the optional ForceRemove flag to skip the graceful close sequence and forcefully delete the service.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// forceRemove - remove a Service Fabric application or service forcefully without going through the graceful
// shutdown sequence. This parameter can be used to forcefully delete an application or service for which
// delete is timing out due to issues in the service code that prevents graceful close of replicas.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) DeleteService(ctx context.Context, serviceID string, forceRemove *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "DeleteService", err.Error())
	}

	req, err := client.DeleteServicePreparer(ctx, serviceID, forceRemove, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteService", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteServiceSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteService", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteServiceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeleteService", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteServicePreparer prepares the DeleteService request.
func (client BaseClient) DeleteServicePreparer(ctx context.Context, serviceID string, forceRemove *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if forceRemove != nil {
		queryParameters["ForceRemove"] = autorest.Encode("query", *forceRemove)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/Delete", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteServiceSender sends the DeleteService request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteServiceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeleteServiceResponder handles the response to the DeleteService request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteServiceResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeployedServicePackageToNode this API provides a way to download code packages including the container images on a
// specific node outside of the normal application deployment and upgrade path. This is useful for the large code
// packages and container iamges to be present on the node before the actual application deployment and upgrade, thus
// significantly reducing the total time required for the deployment or upgrade.
// Parameters:
// nodeName - the name of the node.
// deployServicePackageToNodeDescription - describes information for deploying a service package to a Service
// Fabric node.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) DeployedServicePackageToNode(ctx context.Context, nodeName string, deployServicePackageToNodeDescription DeployServicePackageToNodeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: deployServicePackageToNodeDescription,
			Constraints: []validation.Constraint{{Target: "deployServicePackageToNodeDescription.ServiceManifestName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "deployServicePackageToNodeDescription.ApplicationTypeName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "deployServicePackageToNodeDescription.ApplicationTypeVersion", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "deployServicePackageToNodeDescription.NodeName", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "DeployedServicePackageToNode", err.Error())
	}

	req, err := client.DeployedServicePackageToNodePreparer(ctx, nodeName, deployServicePackageToNodeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeployedServicePackageToNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeployedServicePackageToNodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeployedServicePackageToNode", resp, "Failure sending request")
		return
	}

	result, err = client.DeployedServicePackageToNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DeployedServicePackageToNode", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeployedServicePackageToNodePreparer prepares the DeployedServicePackageToNode request.
func (client BaseClient) DeployedServicePackageToNodePreparer(ctx context.Context, nodeName string, deployServicePackageToNodeDescription DeployServicePackageToNodeDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/DeployServicePackage", pathParameters),
		autorest.WithJSON(deployServicePackageToNodeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeployedServicePackageToNodeSender sends the DeployedServicePackageToNode request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeployedServicePackageToNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DeployedServicePackageToNodeResponder handles the response to the DeployedServicePackageToNode request. The method always
// closes the http.Response Body.
func (client BaseClient) DeployedServicePackageToNodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DisableNode deactivate a Service Fabric cluster node with the specified deactivation intent. Once the deactivation
// is in progress, the deactivation intent can be increased, but not decreased (for example, a node which is was
// deactivated with the Pause intent can be deactivated further with Restart, but not the other way around. Nodes may
// be reactivated using the Activate a node operation any time after they are deactivated. If the deactivation is not
// complete this will cancel the deactivation. A node which goes down and comes back up while deactivated will still
// need to be reactivated before services will be placed on that node.
// Parameters:
// nodeName - the name of the node.
// deactivationIntentDescription - describes the intent or reason for deactivating the node.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) DisableNode(ctx context.Context, nodeName string, deactivationIntentDescription DeactivationIntentDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "DisableNode", err.Error())
	}

	req, err := client.DisableNodePreparer(ctx, nodeName, deactivationIntentDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DisableNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.DisableNodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DisableNode", resp, "Failure sending request")
		return
	}

	result, err = client.DisableNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "DisableNode", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DisableNodePreparer prepares the DisableNode request.
func (client BaseClient) DisableNodePreparer(ctx context.Context, nodeName string, deactivationIntentDescription DeactivationIntentDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/Deactivate", pathParameters),
		autorest.WithJSON(deactivationIntentDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DisableNodeSender sends the DisableNode request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DisableNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// DisableNodeResponder handles the response to the DisableNode request. The method always
// closes the http.Response Body.
func (client BaseClient) DisableNodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// EnableNode activates a Service Fabric cluster node which is currently deactivated. Once activated, the node will
// again become a viable target for placing new replicas, and any deactivated replicas remaining on the node will be
// reactivated.
// Parameters:
// nodeName - the name of the node.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) EnableNode(ctx context.Context, nodeName string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "EnableNode", err.Error())
	}

	req, err := client.EnableNodePreparer(ctx, nodeName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "EnableNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.EnableNodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "EnableNode", resp, "Failure sending request")
		return
	}

	result, err = client.EnableNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "EnableNode", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// EnableNodePreparer prepares the EnableNode request.
func (client BaseClient) EnableNodePreparer(ctx context.Context, nodeName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/Activate", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// EnableNodeSender sends the EnableNode request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) EnableNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// EnableNodeResponder handles the response to the EnableNode request. The method always
// closes the http.Response Body.
func (client BaseClient) EnableNodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ForceApproveRepairTask this API supports the Service Fabric platform; it is not meant to be used directly from your
// code.
// Parameters:
// repairTaskApproveDescription - describes the repair task to be approved.
func (client BaseClient) ForceApproveRepairTask(ctx context.Context, repairTaskApproveDescription RepairTaskApproveDescription) (result RepairTaskUpdateInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTaskApproveDescription,
			Constraints: []validation.Constraint{{Target: "repairTaskApproveDescription.TaskID", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ForceApproveRepairTask", err.Error())
	}

	req, err := client.ForceApproveRepairTaskPreparer(ctx, repairTaskApproveDescription)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ForceApproveRepairTask", nil, "Failure preparing request")
		return
	}

	resp, err := client.ForceApproveRepairTaskSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ForceApproveRepairTask", resp, "Failure sending request")
		return
	}

	result, err = client.ForceApproveRepairTaskResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ForceApproveRepairTask", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ForceApproveRepairTaskPreparer prepares the ForceApproveRepairTask request.
func (client BaseClient) ForceApproveRepairTaskPreparer(ctx context.Context, repairTaskApproveDescription RepairTaskApproveDescription) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/ForceApproveRepairTask"),
		autorest.WithJSON(repairTaskApproveDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ForceApproveRepairTaskSender sends the ForceApproveRepairTask request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ForceApproveRepairTaskSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ForceApproveRepairTaskResponder handles the response to the ForceApproveRepairTask request. The method always
// closes the http.Response Body.
func (client BaseClient) ForceApproveRepairTaskResponder(resp *http.Response) (result RepairTaskUpdateInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetAadMetadata gets the Azure Active Directory metadata used for secured connection to cluster.
// This API is not supposed to be called separately. It provides information needed to set up an Azure Active Directory
// secured connection with a Service Fabric cluster.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetAadMetadata(ctx context.Context, timeout *int64) (result AadMetadataObject, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetAadMetadata", err.Error())
	}

	req, err := client.GetAadMetadataPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetAadMetadata", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetAadMetadataSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetAadMetadata", resp, "Failure sending request")
		return
	}

	result, err = client.GetAadMetadataResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetAadMetadata", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetAadMetadataPreparer prepares the GetAadMetadata request.
func (client BaseClient) GetAadMetadataPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetAadMetadata"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetAadMetadataSender sends the GetAadMetadata request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetAadMetadataSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetAadMetadataResponder handles the response to the GetAadMetadata request. The method always
// closes the http.Response Body.
func (client BaseClient) GetAadMetadataResponder(resp *http.Response) (result AadMetadataObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationHealth returns the heath state of the service fabric application. The response reports either Ok,
// Error or Warning health state. If the entity is not found in the health store, it will return Error.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// deployedApplicationsHealthStateFilter - allows filtering of the deployed applications health state objects
// returned in the result of application health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states. Only
// deployed applications that match the filter will be returned.
// All deployed applications are used to evaluate the aggregated health state. If not specified, all entries
// are returned.
// The state values are flag based enumeration, so the value could be a combination of these value obtained
// using bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of deployed applications with HealthState value of
// OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// servicesHealthStateFilter - allows filtering of the services health state objects returned in the result of
// services health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only services that match the filter are returned. All services are used to evaluate the aggregated health
// state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value
// obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services
// with HealthState value of OK (2) and Warning (4) will be returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// excludeHealthStatistics - indicates whether the health statistics should be returned as part of the query
// result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetApplicationHealth(ctx context.Context, applicationID string, eventsHealthStateFilter *int32, deployedApplicationsHealthStateFilter *int32, servicesHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (result ApplicationHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetApplicationHealth", err.Error())
	}

	req, err := client.GetApplicationHealthPreparer(ctx, applicationID, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationHealthPreparer prepares the GetApplicationHealth request.
func (client BaseClient) GetApplicationHealthPreparer(ctx context.Context, applicationID string, eventsHealthStateFilter *int32, deployedApplicationsHealthStateFilter *int32, servicesHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if deployedApplicationsHealthStateFilter != nil {
		queryParameters["DeployedApplicationsHealthStateFilter"] = autorest.Encode("query", *deployedApplicationsHealthStateFilter)
	} else {
		queryParameters["DeployedApplicationsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if servicesHealthStateFilter != nil {
		queryParameters["ServicesHealthStateFilter"] = autorest.Encode("query", *servicesHealthStateFilter)
	} else {
		queryParameters["ServicesHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	} else {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationHealthSender sends the GetApplicationHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationHealthResponder handles the response to the GetApplicationHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationHealthResponder(resp *http.Response) (result ApplicationHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationHealthUsingPolicy gets the health of a Service Fabric application. Use EventsHealthStateFilter to
// filter the collection of health events reported on the node based on the health state. Use ClusterHealthPolicies to
// override the health policies used to evaluate the health.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// deployedApplicationsHealthStateFilter - allows filtering of the deployed applications health state objects
// returned in the result of application health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states. Only
// deployed applications that match the filter will be returned.
// All deployed applications are used to evaluate the aggregated health state. If not specified, all entries
// are returned.
// The state values are flag based enumeration, so the value could be a combination of these value obtained
// using bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of deployed applications with HealthState value of
// OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// servicesHealthStateFilter - allows filtering of the services health state objects returned in the result of
// services health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only services that match the filter are returned. All services are used to evaluate the aggregated health
// state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value
// obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of services
// with HealthState value of OK (2) and Warning (4) will be returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// excludeHealthStatistics - indicates whether the health statistics should be returned as part of the query
// result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// applicationHealthPolicy - describes the health policies used to evaluate the health of an application or one
// of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health
// policy.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetApplicationHealthUsingPolicy(ctx context.Context, applicationID string, eventsHealthStateFilter *int32, deployedApplicationsHealthStateFilter *int32, servicesHealthStateFilter *int32, excludeHealthStatistics *bool, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (result ApplicationHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetApplicationHealthUsingPolicy", err.Error())
	}

	req, err := client.GetApplicationHealthUsingPolicyPreparer(ctx, applicationID, eventsHealthStateFilter, deployedApplicationsHealthStateFilter, servicesHealthStateFilter, excludeHealthStatistics, applicationHealthPolicy, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationHealthUsingPolicyPreparer prepares the GetApplicationHealthUsingPolicy request.
func (client BaseClient) GetApplicationHealthUsingPolicyPreparer(ctx context.Context, applicationID string, eventsHealthStateFilter *int32, deployedApplicationsHealthStateFilter *int32, servicesHealthStateFilter *int32, excludeHealthStatistics *bool, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if deployedApplicationsHealthStateFilter != nil {
		queryParameters["DeployedApplicationsHealthStateFilter"] = autorest.Encode("query", *deployedApplicationsHealthStateFilter)
	} else {
		queryParameters["DeployedApplicationsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if servicesHealthStateFilter != nil {
		queryParameters["ServicesHealthStateFilter"] = autorest.Encode("query", *servicesHealthStateFilter)
	} else {
		queryParameters["ServicesHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	} else {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationHealthUsingPolicySender sends the GetApplicationHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationHealthUsingPolicyResponder handles the response to the GetApplicationHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationHealthUsingPolicyResponder(resp *http.Response) (result ApplicationHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationInfo returns the information about the application that was created or in the process of being created
// in the Service Fabric cluster and whose name matches the one specified as the parameter. The response includes the
// name, type, status, parameters and other details about the application.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// excludeApplicationParameters - the flag that specifies whether application parameters will be excluded from
// the result.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetApplicationInfo(ctx context.Context, applicationID string, excludeApplicationParameters *bool, timeout *int64) (result ApplicationInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetApplicationInfo", err.Error())
	}

	req, err := client.GetApplicationInfoPreparer(ctx, applicationID, excludeApplicationParameters, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationInfoPreparer prepares the GetApplicationInfo request.
func (client BaseClient) GetApplicationInfoPreparer(ctx context.Context, applicationID string, excludeApplicationParameters *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if excludeApplicationParameters != nil {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", *excludeApplicationParameters)
	} else {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationInfoSender sends the GetApplicationInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationInfoResponder handles the response to the GetApplicationInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationInfoResponder(resp *http.Response) (result ApplicationInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationInfoList gets the information about the applications that were created or in the process of being
// created in the Service Fabric cluster and match filters specified as the parameter. The response includes the name,
// type, status, parameters and other details about the application. If the applications do not fit in a page, one page
// of results is returned as well as a continuation token which can be used to get the next page. Filters
// ApplicationTypeName and ApplicationDefinitionKindFilter cannot be specified at the same time.
// Parameters:
// applicationDefinitionKindFilter - used to filter on ApplicationDefinitionKind which is the mechanism used to
// define a Service Fabric application.
// - Default - Default value, which performs the same function as selecting "All". The value is 0.
// - All - Filter that matches input with any ApplicationDefinitionKind value. The value is 65535.
// - ServiceFabricApplicationDescription - Filter that matches input with ApplicationDefinitionKind value
// ServiceFabricApplicationDescription. The value is 1.
// - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value is 2.
// applicationTypeName - the application type name used to filter the applications to query for. This value
// should not contain the application type version.
// excludeApplicationParameters - the flag that specifies whether application parameters will be excluded from
// the result.
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// maxResults - the maximum number of results to be returned as part of the paged queries. This parameter
// defines the upper bound on the number of results returned. The results returned can be less than the
// specified maximum results if they do not fit in the message as per the max message size restrictions defined
// in the configuration. If this parameter is zero or not specified, the paged queries includes as much results
// as possible that fit in the return message.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetApplicationInfoList(ctx context.Context, applicationDefinitionKindFilter *int32, applicationTypeName string, excludeApplicationParameters *bool, continuationToken string, maxResults *int64, timeout *int64) (result PagedApplicationInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: maxResults,
			Constraints: []validation.Constraint{{Target: "maxResults", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "maxResults", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetApplicationInfoList", err.Error())
	}

	req, err := client.GetApplicationInfoListPreparer(ctx, applicationDefinitionKindFilter, applicationTypeName, excludeApplicationParameters, continuationToken, maxResults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationInfoListPreparer prepares the GetApplicationInfoList request.
func (client BaseClient) GetApplicationInfoListPreparer(ctx context.Context, applicationDefinitionKindFilter *int32, applicationTypeName string, excludeApplicationParameters *bool, continuationToken string, maxResults *int64, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.1"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if applicationDefinitionKindFilter != nil {
		queryParameters["ApplicationDefinitionKindFilter"] = autorest.Encode("query", *applicationDefinitionKindFilter)
	} else {
		queryParameters["ApplicationDefinitionKindFilter"] = autorest.Encode("query", 0)
	}
	if len(applicationTypeName) > 0 {
		queryParameters["ApplicationTypeName"] = autorest.Encode("query", applicationTypeName)
	}
	if excludeApplicationParameters != nil {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", *excludeApplicationParameters)
	} else {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", false)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if maxResults != nil {
		queryParameters["MaxResults"] = autorest.Encode("query", *maxResults)
	} else {
		queryParameters["MaxResults"] = autorest.Encode("query", 0)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Applications"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationInfoListSender sends the GetApplicationInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationInfoListResponder handles the response to the GetApplicationInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationInfoListResponder(resp *http.Response) (result PagedApplicationInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationLoadInfo returns the load information about the application that was created or in the process of
// being created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response
// includes the name, minimum nodes, maximum nodes, the number of nodes the app is occupying currently, and application
// load metric information about the application.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetApplicationLoadInfo(ctx context.Context, applicationID string, timeout *int64) (result ApplicationLoadInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetApplicationLoadInfo", err.Error())
	}

	req, err := client.GetApplicationLoadInfoPreparer(ctx, applicationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationLoadInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationLoadInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationLoadInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationLoadInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationLoadInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationLoadInfoPreparer prepares the GetApplicationLoadInfo request.
func (client BaseClient) GetApplicationLoadInfoPreparer(ctx context.Context, applicationID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetLoadInformation", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationLoadInfoSender sends the GetApplicationLoadInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationLoadInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationLoadInfoResponder handles the response to the GetApplicationLoadInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationLoadInfoResponder(resp *http.Response) (result ApplicationLoadInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationManifest gets the manifest describing an application type. The response contains the application
// manifest XML as a string.
// Parameters:
// applicationTypeName - the name of the application type.
// applicationTypeVersion - the version of the application type.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetApplicationManifest(ctx context.Context, applicationTypeName string, applicationTypeVersion string, timeout *int64) (result ApplicationTypeManifest, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetApplicationManifest", err.Error())
	}

	req, err := client.GetApplicationManifestPreparer(ctx, applicationTypeName, applicationTypeVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationManifest", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationManifestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationManifest", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationManifestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationManifest", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationManifestPreparer prepares the GetApplicationManifest request.
func (client BaseClient) GetApplicationManifestPreparer(ctx context.Context, applicationTypeName string, applicationTypeVersion string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationTypeName": autorest.Encode("path", applicationTypeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":            APIVersion,
		"ApplicationTypeVersion": autorest.Encode("query", applicationTypeVersion),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ApplicationTypes/{applicationTypeName}/$/GetApplicationManifest", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationManifestSender sends the GetApplicationManifest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationManifestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationManifestResponder handles the response to the GetApplicationManifest request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationManifestResponder(resp *http.Response) (result ApplicationTypeManifest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationNameInfo the GetApplicationName endpoint returns the name of the application for the specified
// service.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetApplicationNameInfo(ctx context.Context, serviceID string, timeout *int64) (result ApplicationNameInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetApplicationNameInfo", err.Error())
	}

	req, err := client.GetApplicationNameInfoPreparer(ctx, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationNameInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationNameInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationNameInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationNameInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationNameInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationNameInfoPreparer prepares the GetApplicationNameInfo request.
func (client BaseClient) GetApplicationNameInfoPreparer(ctx context.Context, serviceID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/GetApplicationName", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationNameInfoSender sends the GetApplicationNameInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationNameInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationNameInfoResponder handles the response to the GetApplicationNameInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationNameInfoResponder(resp *http.Response) (result ApplicationNameInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationTypeInfoList returns the information about the application types that are provisioned or in the
// process of being provisioned in the Service Fabric cluster. Each version of an application type is returned as one
// application type. The response includes the name, version, status and other details about the application type. This
// is a paged query, meaning that if not all of the application types fit in a page, one page of results is returned as
// well as a continuation token which can be used to get the next page. For example, if there are 10 application types
// but a page only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the
// rest of the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty
// continuation token is returned if there are no subsequent pages.
// Parameters:
// applicationTypeDefinitionKindFilter - used to filter on ApplicationTypeDefinitionKind which is the mechanism
// used to define a Service Fabric application type.
// - Default - Default value, which performs the same function as selecting "All". The value is 0.
// - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is 65535.
// - ServiceFabricApplicationPackage - Filter that matches input with ApplicationTypeDefinitionKind value
// ServiceFabricApplicationPackage. The value is 1.
// - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The value is 2.
// excludeApplicationParameters - the flag that specifies whether application parameters will be excluded from
// the result.
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// maxResults - the maximum number of results to be returned as part of the paged queries. This parameter
// defines the upper bound on the number of results returned. The results returned can be less than the
// specified maximum results if they do not fit in the message as per the max message size restrictions defined
// in the configuration. If this parameter is zero or not specified, the paged queries includes as much results
// as possible that fit in the return message.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetApplicationTypeInfoList(ctx context.Context, applicationTypeDefinitionKindFilter *int32, excludeApplicationParameters *bool, continuationToken string, maxResults *int64, timeout *int64) (result PagedApplicationTypeInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: maxResults,
			Constraints: []validation.Constraint{{Target: "maxResults", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "maxResults", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetApplicationTypeInfoList", err.Error())
	}

	req, err := client.GetApplicationTypeInfoListPreparer(ctx, applicationTypeDefinitionKindFilter, excludeApplicationParameters, continuationToken, maxResults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationTypeInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationTypeInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationTypeInfoListPreparer prepares the GetApplicationTypeInfoList request.
func (client BaseClient) GetApplicationTypeInfoListPreparer(ctx context.Context, applicationTypeDefinitionKindFilter *int32, excludeApplicationParameters *bool, continuationToken string, maxResults *int64, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if applicationTypeDefinitionKindFilter != nil {
		queryParameters["ApplicationTypeDefinitionKindFilter"] = autorest.Encode("query", *applicationTypeDefinitionKindFilter)
	} else {
		queryParameters["ApplicationTypeDefinitionKindFilter"] = autorest.Encode("query", 0)
	}
	if excludeApplicationParameters != nil {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", *excludeApplicationParameters)
	} else {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", false)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if maxResults != nil {
		queryParameters["MaxResults"] = autorest.Encode("query", *maxResults)
	} else {
		queryParameters["MaxResults"] = autorest.Encode("query", 0)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ApplicationTypes"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationTypeInfoListSender sends the GetApplicationTypeInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationTypeInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationTypeInfoListResponder handles the response to the GetApplicationTypeInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationTypeInfoListResponder(resp *http.Response) (result PagedApplicationTypeInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationTypeInfoListByName returns the information about the application types that are provisioned or in the
// process of being provisioned in the Service Fabric cluster. These results are of application types whose name match
// exactly the one specified as the parameter, and which comply with the given query parameters. All versions of the
// application type matching the application type name are returned, with each version returned as one application
// type. The response includes the name, version, status and other details about the application type. This is a paged
// query, meaning that if not all of the application types fit in a page, one page of results is returned as well as a
// continuation token which can be used to get the next page. For example, if there are 10 application types but a page
// only fits the first 3 application types, or if max results is set to 3, then 3 is returned. To access the rest of
// the results, retrieve subsequent pages by using the returned continuation token in the next query. An empty
// continuation token is returned if there are no subsequent pages.
// Parameters:
// applicationTypeName - the name of the application type.
// applicationTypeVersion - the version of the application type.
// excludeApplicationParameters - the flag that specifies whether application parameters will be excluded from
// the result.
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// maxResults - the maximum number of results to be returned as part of the paged queries. This parameter
// defines the upper bound on the number of results returned. The results returned can be less than the
// specified maximum results if they do not fit in the message as per the max message size restrictions defined
// in the configuration. If this parameter is zero or not specified, the paged queries includes as much results
// as possible that fit in the return message.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetApplicationTypeInfoListByName(ctx context.Context, applicationTypeName string, applicationTypeVersion string, excludeApplicationParameters *bool, continuationToken string, maxResults *int64, timeout *int64) (result PagedApplicationTypeInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: maxResults,
			Constraints: []validation.Constraint{{Target: "maxResults", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "maxResults", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetApplicationTypeInfoListByName", err.Error())
	}

	req, err := client.GetApplicationTypeInfoListByNamePreparer(ctx, applicationTypeName, applicationTypeVersion, excludeApplicationParameters, continuationToken, maxResults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoListByName", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationTypeInfoListByNameSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoListByName", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationTypeInfoListByNameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationTypeInfoListByName", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationTypeInfoListByNamePreparer prepares the GetApplicationTypeInfoListByName request.
func (client BaseClient) GetApplicationTypeInfoListByNamePreparer(ctx context.Context, applicationTypeName string, applicationTypeVersion string, excludeApplicationParameters *bool, continuationToken string, maxResults *int64, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationTypeName": autorest.Encode("path", applicationTypeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(applicationTypeVersion) > 0 {
		queryParameters["ApplicationTypeVersion"] = autorest.Encode("query", applicationTypeVersion)
	}
	if excludeApplicationParameters != nil {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", *excludeApplicationParameters)
	} else {
		queryParameters["ExcludeApplicationParameters"] = autorest.Encode("query", false)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if maxResults != nil {
		queryParameters["MaxResults"] = autorest.Encode("query", *maxResults)
	} else {
		queryParameters["MaxResults"] = autorest.Encode("query", 0)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ApplicationTypes/{applicationTypeName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationTypeInfoListByNameSender sends the GetApplicationTypeInfoListByName request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationTypeInfoListByNameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationTypeInfoListByNameResponder handles the response to the GetApplicationTypeInfoListByName request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationTypeInfoListByNameResponder(resp *http.Response) (result PagedApplicationTypeInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationUpgrade returns information about the state of the latest application upgrade along with details to
// aid debugging application health issues.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetApplicationUpgrade(ctx context.Context, applicationID string, timeout *int64) (result ApplicationUpgradeProgressInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetApplicationUpgrade", err.Error())
	}

	req, err := client.GetApplicationUpgradePreparer(ctx, applicationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetApplicationUpgradeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.GetApplicationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetApplicationUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationUpgradePreparer prepares the GetApplicationUpgrade request.
func (client BaseClient) GetApplicationUpgradePreparer(ctx context.Context, applicationID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetUpgradeProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationUpgradeSender sends the GetApplicationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetApplicationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetApplicationUpgradeResponder handles the response to the GetApplicationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) GetApplicationUpgradeResponder(resp *http.Response) (result ApplicationUpgradeProgressInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetChaosReport you can either specify the ContinuationToken to get the next segment of the Chaos report or you can
// specify the time-range
// through StartTimeUtc and EndTimeUtc, but you cannot specify both the ContinuationToken and the time-range in the
// same call.
// When there are more than 100 Chaos events, the Chaos report is returned in segments where a segment contains no more
// than 100 Chaos events.
// Parameters:
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// startTimeUtc - the Windows file time representing the start time of the time range for which a Chaos report
// is to be generated. Please consult [DateTime.ToFileTimeUtc
// Method](https://msdn.microsoft.com/en-us/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details.
// endTimeUtc - the Windows file time representing the end time of the time range for which a Chaos report is
// to be generated. Please consult [DateTime.ToFileTimeUtc
// Method](https://msdn.microsoft.com/en-us/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for details.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetChaosReport(ctx context.Context, continuationToken string, startTimeUtc string, endTimeUtc string, timeout *int64) (result ChaosReport, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetChaosReport", err.Error())
	}

	req, err := client.GetChaosReportPreparer(ctx, continuationToken, startTimeUtc, endTimeUtc, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetChaosReport", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetChaosReportSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetChaosReport", resp, "Failure sending request")
		return
	}

	result, err = client.GetChaosReportResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetChaosReport", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetChaosReportPreparer prepares the GetChaosReport request.
func (client BaseClient) GetChaosReportPreparer(ctx context.Context, continuationToken string, startTimeUtc string, endTimeUtc string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if len(startTimeUtc) > 0 {
		queryParameters["StartTimeUtc"] = autorest.Encode("query", startTimeUtc)
	}
	if len(endTimeUtc) > 0 {
		queryParameters["EndTimeUtc"] = autorest.Encode("query", endTimeUtc)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Tools/Chaos/$/Report"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetChaosReportSender sends the GetChaosReport request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetChaosReportSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetChaosReportResponder handles the response to the GetChaosReport request. The method always
// closes the http.Response Body.
func (client BaseClient) GetChaosReportResponder(resp *http.Response) (result ChaosReport, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterConfiguration get the Service Fabric standalone cluster configuration. The cluster configuration contains
// properties of the cluster that include different node types on the cluster,
// security configurations, fault and upgrade domain topologies etc.
// Parameters:
// configurationAPIVersion - the API version of the Standalone cluster json configuration.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetClusterConfiguration(ctx context.Context, configurationAPIVersion string, timeout *int64) (result ClusterConfiguration, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetClusterConfiguration", err.Error())
	}

	req, err := client.GetClusterConfigurationPreparer(ctx, configurationAPIVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfiguration", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterConfigurationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfiguration", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterConfigurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfiguration", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterConfigurationPreparer prepares the GetClusterConfiguration request.
func (client BaseClient) GetClusterConfigurationPreparer(ctx context.Context, configurationAPIVersion string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":             APIVersion,
		"ConfigurationApiVersion": autorest.Encode("query", configurationAPIVersion),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterConfiguration"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterConfigurationSender sends the GetClusterConfiguration request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterConfigurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterConfigurationResponder handles the response to the GetClusterConfiguration request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterConfigurationResponder(resp *http.Response) (result ClusterConfiguration, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterConfigurationUpgradeStatus get the cluster configuration upgrade status details of a Service Fabric
// standalone cluster.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetClusterConfigurationUpgradeStatus(ctx context.Context, timeout *int64) (result ClusterConfigurationUpgradeStatusInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetClusterConfigurationUpgradeStatus", err.Error())
	}

	req, err := client.GetClusterConfigurationUpgradeStatusPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfigurationUpgradeStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterConfigurationUpgradeStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfigurationUpgradeStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterConfigurationUpgradeStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterConfigurationUpgradeStatus", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterConfigurationUpgradeStatusPreparer prepares the GetClusterConfigurationUpgradeStatus request.
func (client BaseClient) GetClusterConfigurationUpgradeStatusPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterConfigurationUpgradeStatus"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterConfigurationUpgradeStatusSender sends the GetClusterConfigurationUpgradeStatus request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterConfigurationUpgradeStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterConfigurationUpgradeStatusResponder handles the response to the GetClusterConfigurationUpgradeStatus request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterConfigurationUpgradeStatusResponder(resp *http.Response) (result ClusterConfigurationUpgradeStatusInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealth gets the health of a Service Fabric cluster.
// Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health
// state.
// Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and
// applications returned based on their aggregated health state.
// Parameters:
// nodesHealthStateFilter - allows filtering of the node health state objects returned in the result of cluster
// health query
// based on their health state. The possible values for this parameter include integer value of one of the
// following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the
// aggregated health state.
// If not specified, all entries are returned.
// The state values are flag based enumeration, so the value could be a combination of these values obtained
// using bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and
// Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// applicationsHealthStateFilter - allows filtering of the application health state objects returned in the
// result of cluster health
// query based on their health state.
// The possible values for this parameter include integer value obtained from members or bitwise operations
// on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
// All applications are used to evaluate the aggregated health state. If not specified, all entries are
// returned.
// The state values are flag based enumeration, so the value could be a combination of these values obtained
// using bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of applications with HealthState value of OK (2)
// and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// excludeHealthStatistics - indicates whether the health statistics should be returned as part of the query
// result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// includeSystemApplicationHealthStatistics - indicates whether the health statistics should include the
// fabric:/System application health statistics. False by default.
// If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that
// belong to the fabric:/System application.
// Otherwise, the query result includes health statistics only for user applications.
// The health statistics must be included in the query result for this parameter to be applied.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetClusterHealth(ctx context.Context, nodesHealthStateFilter *int32, applicationsHealthStateFilter *int32, eventsHealthStateFilter *int32, excludeHealthStatistics *bool, includeSystemApplicationHealthStatistics *bool, timeout *int64) (result ClusterHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetClusterHealth", err.Error())
	}

	req, err := client.GetClusterHealthPreparer(ctx, nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthPreparer prepares the GetClusterHealth request.
func (client BaseClient) GetClusterHealthPreparer(ctx context.Context, nodesHealthStateFilter *int32, applicationsHealthStateFilter *int32, eventsHealthStateFilter *int32, excludeHealthStatistics *bool, includeSystemApplicationHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if nodesHealthStateFilter != nil {
		queryParameters["NodesHealthStateFilter"] = autorest.Encode("query", *nodesHealthStateFilter)
	} else {
		queryParameters["NodesHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if applicationsHealthStateFilter != nil {
		queryParameters["ApplicationsHealthStateFilter"] = autorest.Encode("query", *applicationsHealthStateFilter)
	} else {
		queryParameters["ApplicationsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	} else {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", false)
	}
	if includeSystemApplicationHealthStatistics != nil {
		queryParameters["IncludeSystemApplicationHealthStatistics"] = autorest.Encode("query", *includeSystemApplicationHealthStatistics)
	} else {
		queryParameters["IncludeSystemApplicationHealthStatistics"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterHealth"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthSender sends the GetClusterHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthResponder handles the response to the GetClusterHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterHealthResponder(resp *http.Response) (result ClusterHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthChunk gets the health of a Service Fabric cluster using health chunks. Includes the aggregated
// health state of the cluster, but none of the cluster entities.
// To expand the cluster health and get the health state of all or some of the entities, use the POST URI and specify
// the cluster health chunk query description.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetClusterHealthChunk(ctx context.Context, timeout *int64) (result ClusterHealthChunk, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetClusterHealthChunk", err.Error())
	}

	req, err := client.GetClusterHealthChunkPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunk", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterHealthChunkSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunk", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterHealthChunkResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunk", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthChunkPreparer prepares the GetClusterHealthChunk request.
func (client BaseClient) GetClusterHealthChunkPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterHealthChunk"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthChunkSender sends the GetClusterHealthChunk request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterHealthChunkSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthChunkResponder handles the response to the GetClusterHealthChunk request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterHealthChunkResponder(resp *http.Response) (result ClusterHealthChunk, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthChunkUsingPolicyAndAdvancedFilters gets the health of a Service Fabric cluster using health chunks.
// The health evaluation is done based on the input cluster health chunk query description.
// The query description allows users to specify health policies for evaluating the cluster and its children.
// Users can specify very flexible filters to select which cluster entities to return. The selection can be done based
// on the entities health state and based on the hierarchy.
// The query can return multi-level children of the entities based on the specified filters. For example, it can return
// one application with a specified name, and for this application, return
// only services that are in Error or Warning, and all partitions and replicas for one of these services.
// Parameters:
// clusterHealthChunkQueryDescription - describes the cluster and application health policies used to evaluate
// the cluster health and the filters to select which cluster entities to be returned.
// If the cluster health policy is present, it is used to evaluate the cluster events and the cluster nodes. If
// not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the
// default cluster health policy.
// By default, each application is evaluated using its specific application health policy, defined in the
// application manifest, or the default health policy, if no policy is defined in manifest.
// If the application health policy map is specified, and it has an entry for an application, the specified
// application health policy
// is used to evaluate the application health.
// Users can specify very flexible filters to select which cluster entities to include in response. The
// selection can be done based on the entities health state and based on the hierarchy.
// The query can return multi-level children of the entities based on the specified filters. For example, it
// can return one application with a specified name, and for this application, return
// only services that are in Error or Warning, and all partitions and replicas for one of these services.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetClusterHealthChunkUsingPolicyAndAdvancedFilters(ctx context.Context, clusterHealthChunkQueryDescription *ClusterHealthChunkQueryDescription, timeout *int64) (result ClusterHealthChunk, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetClusterHealthChunkUsingPolicyAndAdvancedFilters", err.Error())
	}

	req, err := client.GetClusterHealthChunkUsingPolicyAndAdvancedFiltersPreparer(ctx, clusterHealthChunkQueryDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunkUsingPolicyAndAdvancedFilters", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterHealthChunkUsingPolicyAndAdvancedFiltersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunkUsingPolicyAndAdvancedFilters", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterHealthChunkUsingPolicyAndAdvancedFiltersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthChunkUsingPolicyAndAdvancedFilters", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthChunkUsingPolicyAndAdvancedFiltersPreparer prepares the GetClusterHealthChunkUsingPolicyAndAdvancedFilters request.
func (client BaseClient) GetClusterHealthChunkUsingPolicyAndAdvancedFiltersPreparer(ctx context.Context, clusterHealthChunkQueryDescription *ClusterHealthChunkQueryDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterHealthChunk"),
		autorest.WithQueryParameters(queryParameters))
	if clusterHealthChunkQueryDescription != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(clusterHealthChunkQueryDescription))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthChunkUsingPolicyAndAdvancedFiltersSender sends the GetClusterHealthChunkUsingPolicyAndAdvancedFilters request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterHealthChunkUsingPolicyAndAdvancedFiltersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthChunkUsingPolicyAndAdvancedFiltersResponder handles the response to the GetClusterHealthChunkUsingPolicyAndAdvancedFilters request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterHealthChunkUsingPolicyAndAdvancedFiltersResponder(resp *http.Response) (result ClusterHealthChunk, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthUsingPolicy gets the health of a Service Fabric cluster.
// Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health
// state.
// Similarly, use NodesHealthStateFilter and ApplicationsHealthStateFilter to filter the collection of nodes and
// applications returned based on their aggregated health state.
// Use ClusterHealthPolicies to override the health policies used to evaluate the health.
// Parameters:
// nodesHealthStateFilter - allows filtering of the node health state objects returned in the result of cluster
// health query
// based on their health state. The possible values for this parameter include integer value of one of the
// following health states. Only nodes that match the filter are returned. All nodes are used to evaluate the
// aggregated health state.
// If not specified, all entries are returned.
// The state values are flag based enumeration, so the value could be a combination of these values obtained
// using bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of nodes with HealthState value of OK (2) and
// Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// applicationsHealthStateFilter - allows filtering of the application health state objects returned in the
// result of cluster health
// query based on their health state.
// The possible values for this parameter include integer value obtained from members or bitwise operations
// on members of HealthStateFilter enumeration. Only applications that match the filter are returned.
// All applications are used to evaluate the aggregated health state. If not specified, all entries are
// returned.
// The state values are flag based enumeration, so the value could be a combination of these values obtained
// using bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of applications with HealthState value of OK (2)
// and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// excludeHealthStatistics - indicates whether the health statistics should be returned as part of the query
// result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// includeSystemApplicationHealthStatistics - indicates whether the health statistics should include the
// fabric:/System application health statistics. False by default.
// If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the entities that
// belong to the fabric:/System application.
// Otherwise, the query result includes health statistics only for user applications.
// The health statistics must be included in the query result for this parameter to be applied.
// clusterHealthPolicies - describes the health policies used to evaluate the cluster health.
// If not present, the health evaluation uses the cluster health policy defined in the cluster manifest or the
// default cluster health policy.
// By default, each application is evaluated using its specific application health policy, defined in the
// application manifest, or the default health policy, if no policy is defined in manifest.
// If the application health policy map is specified, and it has an entry for an application, the specified
// application health policy
// is used to evaluate the application health.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetClusterHealthUsingPolicy(ctx context.Context, nodesHealthStateFilter *int32, applicationsHealthStateFilter *int32, eventsHealthStateFilter *int32, excludeHealthStatistics *bool, includeSystemApplicationHealthStatistics *bool, clusterHealthPolicies *ClusterHealthPolicies, timeout *int64) (result ClusterHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetClusterHealthUsingPolicy", err.Error())
	}

	req, err := client.GetClusterHealthUsingPolicyPreparer(ctx, nodesHealthStateFilter, applicationsHealthStateFilter, eventsHealthStateFilter, excludeHealthStatistics, includeSystemApplicationHealthStatistics, clusterHealthPolicies, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthUsingPolicyPreparer prepares the GetClusterHealthUsingPolicy request.
func (client BaseClient) GetClusterHealthUsingPolicyPreparer(ctx context.Context, nodesHealthStateFilter *int32, applicationsHealthStateFilter *int32, eventsHealthStateFilter *int32, excludeHealthStatistics *bool, includeSystemApplicationHealthStatistics *bool, clusterHealthPolicies *ClusterHealthPolicies, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if nodesHealthStateFilter != nil {
		queryParameters["NodesHealthStateFilter"] = autorest.Encode("query", *nodesHealthStateFilter)
	} else {
		queryParameters["NodesHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if applicationsHealthStateFilter != nil {
		queryParameters["ApplicationsHealthStateFilter"] = autorest.Encode("query", *applicationsHealthStateFilter)
	} else {
		queryParameters["ApplicationsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	} else {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", false)
	}
	if includeSystemApplicationHealthStatistics != nil {
		queryParameters["IncludeSystemApplicationHealthStatistics"] = autorest.Encode("query", *includeSystemApplicationHealthStatistics)
	} else {
		queryParameters["IncludeSystemApplicationHealthStatistics"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterHealth"),
		autorest.WithQueryParameters(queryParameters))
	if clusterHealthPolicies != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(clusterHealthPolicies))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthUsingPolicySender sends the GetClusterHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterHealthUsingPolicyResponder handles the response to the GetClusterHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterHealthUsingPolicyResponder(resp *http.Response) (result ClusterHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterManifest get the Service Fabric cluster manifest. The cluster manifest contains properties of the cluster
// that include different node types on the cluster,
// security configurations, fault and upgrade domain topologies etc.
//
// These properties are specified as part of the ClusterConfig.JSON file while deploying a stand alone cluster.
// However, most of the information in the cluster manifest
// is generated internally by service fabric during cluster deployment in other deployment scenarios (for e.g when
// using azure portal).
//
// The contents of the cluster manifest are for informational purposes only and users are not expected to take a
// dependency on the format of the file contents or its interpretation.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetClusterManifest(ctx context.Context, timeout *int64) (result ClusterManifest, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetClusterManifest", err.Error())
	}

	req, err := client.GetClusterManifestPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterManifest", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterManifestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterManifest", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterManifestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterManifest", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterManifestPreparer prepares the GetClusterManifest request.
func (client BaseClient) GetClusterManifestPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetClusterManifest"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterManifestSender sends the GetClusterManifest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterManifestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterManifestResponder handles the response to the GetClusterManifest request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterManifestResponder(resp *http.Response) (result ClusterManifest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterUpgradeProgress gets the current progress of the ongoing cluster upgrade. If no upgrade is currently in
// progress, gets the last state of the previous cluster upgrade.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetClusterUpgradeProgress(ctx context.Context, timeout *int64) (result ClusterUpgradeProgressObject, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetClusterUpgradeProgress", err.Error())
	}

	req, err := client.GetClusterUpgradeProgressPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterUpgradeProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetClusterUpgradeProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterUpgradeProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetClusterUpgradeProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetClusterUpgradeProgress", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterUpgradeProgressPreparer prepares the GetClusterUpgradeProgress request.
func (client BaseClient) GetClusterUpgradeProgressPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetUpgradeProgress"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterUpgradeProgressSender sends the GetClusterUpgradeProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetClusterUpgradeProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetClusterUpgradeProgressResponder handles the response to the GetClusterUpgradeProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetClusterUpgradeProgressResponder(resp *http.Response) (result ClusterUpgradeProgressObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentStatus returns the status of the compose deployment that was created or in the process of being
// created in the Service Fabric cluster and whose name matches the one specified as the parameter. The response
// includes the name, status and other details about the deployment.
// Parameters:
// deploymentName - the identity of the deployment.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetComposeDeploymentStatus(ctx context.Context, deploymentName string, timeout *int64) (result ComposeDeploymentStatusInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetComposeDeploymentStatus", err.Error())
	}

	req, err := client.GetComposeDeploymentStatusPreparer(ctx, deploymentName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetComposeDeploymentStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetComposeDeploymentStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatus", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentStatusPreparer prepares the GetComposeDeploymentStatus request.
func (client BaseClient) GetComposeDeploymentStatusPreparer(ctx context.Context, deploymentName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"deploymentName": deploymentName,
	}

	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ComposeDeployments/{deploymentName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentStatusSender sends the GetComposeDeploymentStatus request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetComposeDeploymentStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentStatusResponder handles the response to the GetComposeDeploymentStatus request. The method always
// closes the http.Response Body.
func (client BaseClient) GetComposeDeploymentStatusResponder(resp *http.Response) (result ComposeDeploymentStatusInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentStatusList gets the status about the compose deployments that were created or in the process of
// being created in the Service Fabric cluster. The response includes the name, status and other details about the
// compose deployments. If the list of deployments do not fit in a page, one page of results is returned as well as a
// continuation token which can be used to get the next page.
// Parameters:
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// maxResults - the maximum number of results to be returned as part of the paged queries. This parameter
// defines the upper bound on the number of results returned. The results returned can be less than the
// specified maximum results if they do not fit in the message as per the max message size restrictions defined
// in the configuration. If this parameter is zero or not specified, the paged queries includes as much results
// as possible that fit in the return message.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetComposeDeploymentStatusList(ctx context.Context, continuationToken string, maxResults *int64, timeout *int64) (result PagedComposeDeploymentStatusInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: maxResults,
			Constraints: []validation.Constraint{{Target: "maxResults", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "maxResults", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetComposeDeploymentStatusList", err.Error())
	}

	req, err := client.GetComposeDeploymentStatusListPreparer(ctx, continuationToken, maxResults, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatusList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetComposeDeploymentStatusListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatusList", resp, "Failure sending request")
		return
	}

	result, err = client.GetComposeDeploymentStatusListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentStatusList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentStatusListPreparer prepares the GetComposeDeploymentStatusList request.
func (client BaseClient) GetComposeDeploymentStatusListPreparer(ctx context.Context, continuationToken string, maxResults *int64, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if maxResults != nil {
		queryParameters["MaxResults"] = autorest.Encode("query", *maxResults)
	} else {
		queryParameters["MaxResults"] = autorest.Encode("query", 0)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ComposeDeployments"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentStatusListSender sends the GetComposeDeploymentStatusList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetComposeDeploymentStatusListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentStatusListResponder handles the response to the GetComposeDeploymentStatusList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetComposeDeploymentStatusListResponder(resp *http.Response) (result PagedComposeDeploymentStatusInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentUpgradeProgress returns the information about the state of the compose deployment upgrade along
// with details to aid debugging application health issues.
// Parameters:
// deploymentName - the identity of the deployment.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetComposeDeploymentUpgradeProgress(ctx context.Context, deploymentName string, timeout *int64) (result ComposeDeploymentUpgradeProgressInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetComposeDeploymentUpgradeProgress", err.Error())
	}

	req, err := client.GetComposeDeploymentUpgradeProgressPreparer(ctx, deploymentName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentUpgradeProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetComposeDeploymentUpgradeProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentUpgradeProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetComposeDeploymentUpgradeProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetComposeDeploymentUpgradeProgress", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentUpgradeProgressPreparer prepares the GetComposeDeploymentUpgradeProgress request.
func (client BaseClient) GetComposeDeploymentUpgradeProgressPreparer(ctx context.Context, deploymentName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"deploymentName": deploymentName,
	}

	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ComposeDeployments/{deploymentName}/$/GetUpgradeProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentUpgradeProgressSender sends the GetComposeDeploymentUpgradeProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetComposeDeploymentUpgradeProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetComposeDeploymentUpgradeProgressResponder handles the response to the GetComposeDeploymentUpgradeProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetComposeDeploymentUpgradeProgressResponder(resp *http.Response) (result ComposeDeploymentUpgradeProgressInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetContainerLogsDeployedOnNode gets the container logs for container deployed on a Service Fabric node for the given
// code package.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// serviceManifestName - the name of a service manifest registered as part of an application type in a Service
// Fabric cluster.
// codePackageName - the name of code package specified in service manifest registered as part of an
// application type in a Service Fabric cluster.
// tail - number of lines to fetch from tail end.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetContainerLogsDeployedOnNode(ctx context.Context, nodeName string, applicationID string, serviceManifestName string, codePackageName string, tail string, timeout *int64) (result ContainerLogs, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetContainerLogsDeployedOnNode", err.Error())
	}

	req, err := client.GetContainerLogsDeployedOnNodePreparer(ctx, nodeName, applicationID, serviceManifestName, codePackageName, tail, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetContainerLogsDeployedOnNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetContainerLogsDeployedOnNodeSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetContainerLogsDeployedOnNode", resp, "Failure sending request")
		return
	}

	result, err = client.GetContainerLogsDeployedOnNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetContainerLogsDeployedOnNode", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetContainerLogsDeployedOnNodePreparer prepares the GetContainerLogsDeployedOnNode request.
func (client BaseClient) GetContainerLogsDeployedOnNodePreparer(ctx context.Context, nodeName string, applicationID string, serviceManifestName string, codePackageName string, tail string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.1"
	queryParameters := map[string]interface{}{
		"api-version":         APIVersion,
		"CodePackageName":     autorest.Encode("query", codePackageName),
		"ServiceManifestName": autorest.Encode("query", serviceManifestName),
	}
	if len(tail) > 0 {
		queryParameters["Tail"] = autorest.Encode("query", tail)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/ContainerLogs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetContainerLogsDeployedOnNodeSender sends the GetContainerLogsDeployedOnNode request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetContainerLogsDeployedOnNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetContainerLogsDeployedOnNodeResponder handles the response to the GetContainerLogsDeployedOnNode request. The method always
// closes the http.Response Body.
func (client BaseClient) GetContainerLogsDeployedOnNodeResponder(resp *http.Response) (result ContainerLogs, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDataLossProgress gets the progress of a data loss operation started with StartDataLoss, using the OperationId.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// partitionID - the identity of the partition.
// operationID - a GUID that identifies a call of this API.  This is passed into the corresponding GetProgress
// API
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDataLossProgress(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (result PartitionDataLossProgress, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDataLossProgress", err.Error())
	}

	req, err := client.GetDataLossProgressPreparer(ctx, serviceID, partitionID, operationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDataLossProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDataLossProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDataLossProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetDataLossProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDataLossProgress", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDataLossProgressPreparer prepares the GetDataLossProgress request.
func (client BaseClient) GetDataLossProgressPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"OperationId": autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetDataLossProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDataLossProgressSender sends the GetDataLossProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDataLossProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDataLossProgressResponder handles the response to the GetDataLossProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDataLossProgressResponder(resp *http.Response) (result PartitionDataLossProgress, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationHealth gets the information about health of an application deployed on a Service Fabric node.
// Use EventsHealthStateFilter to optionally filter for the collection of HealthEvent objects reported on the deployed
// application based on health state. Use DeployedServicePackagesHealthStateFilter to optionally filter for
// DeployedServicePackageHealth children based on health state.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// deployedServicePackagesHealthStateFilter - allows filtering of the deployed service package health state
// objects returned in the result of deployed application health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only deployed service packages that match the filter are returned. All deployed service packages are used to
// evaluate the aggregated health state of the deployed application.
// If not specified, all entries are returned.
// The state values are flag based enumeration, so the value can be a combination of these value obtained using
// bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of service packages with HealthState value of OK
// (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// excludeHealthStatistics - indicates whether the health statistics should be returned as part of the query
// result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedApplicationHealth(ctx context.Context, nodeName string, applicationID string, eventsHealthStateFilter *int32, deployedServicePackagesHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (result DeployedApplicationHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedApplicationHealth", err.Error())
	}

	req, err := client.GetDeployedApplicationHealthPreparer(ctx, nodeName, applicationID, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedApplicationHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedApplicationHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationHealthPreparer prepares the GetDeployedApplicationHealth request.
func (client BaseClient) GetDeployedApplicationHealthPreparer(ctx context.Context, nodeName string, applicationID string, eventsHealthStateFilter *int32, deployedServicePackagesHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if deployedServicePackagesHealthStateFilter != nil {
		queryParameters["DeployedServicePackagesHealthStateFilter"] = autorest.Encode("query", *deployedServicePackagesHealthStateFilter)
	} else {
		queryParameters["DeployedServicePackagesHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	} else {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationHealthSender sends the GetDeployedApplicationHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedApplicationHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationHealthResponder handles the response to the GetDeployedApplicationHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedApplicationHealthResponder(resp *http.Response) (result DeployedApplicationHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationHealthUsingPolicy gets the information about health of an application deployed on a Service
// Fabric node using the specified policy. Use EventsHealthStateFilter to optionally filter for the collection of
// HealthEvent objects reported on the deployed application based on health state. Use
// DeployedServicePackagesHealthStateFilter to optionally filter for DeployedServicePackageHealth children based on
// health state. Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health.
// This API only uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored
// while evaluating the health of the deployed application.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// deployedServicePackagesHealthStateFilter - allows filtering of the deployed service package health state
// objects returned in the result of deployed application health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only deployed service packages that match the filter are returned. All deployed service packages are used to
// evaluate the aggregated health state of the deployed application.
// If not specified, all entries are returned.
// The state values are flag based enumeration, so the value can be a combination of these value obtained using
// bitwise 'OR' operator.
// For example, if the provided value is 6 then health state of service packages with HealthState value of OK
// (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// applicationHealthPolicy - describes the health policies used to evaluate the health of an application or one
// of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health
// policy.
// excludeHealthStatistics - indicates whether the health statistics should be returned as part of the query
// result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedApplicationHealthUsingPolicy(ctx context.Context, nodeName string, applicationID string, eventsHealthStateFilter *int32, deployedServicePackagesHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (result DeployedApplicationHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedApplicationHealthUsingPolicy", err.Error())
	}

	req, err := client.GetDeployedApplicationHealthUsingPolicyPreparer(ctx, nodeName, applicationID, eventsHealthStateFilter, deployedServicePackagesHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedApplicationHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedApplicationHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationHealthUsingPolicyPreparer prepares the GetDeployedApplicationHealthUsingPolicy request.
func (client BaseClient) GetDeployedApplicationHealthUsingPolicyPreparer(ctx context.Context, nodeName string, applicationID string, eventsHealthStateFilter *int32, deployedServicePackagesHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if deployedServicePackagesHealthStateFilter != nil {
		queryParameters["DeployedServicePackagesHealthStateFilter"] = autorest.Encode("query", *deployedServicePackagesHealthStateFilter)
	} else {
		queryParameters["DeployedServicePackagesHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	} else {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationHealthUsingPolicySender sends the GetDeployedApplicationHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedApplicationHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationHealthUsingPolicyResponder handles the response to the GetDeployedApplicationHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedApplicationHealthUsingPolicyResponder(resp *http.Response) (result DeployedApplicationHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationInfo gets the information about an application deployed on a Service Fabric node.  This query
// returns system application information if the application ID provided is for system application. Results encompass
// deployed applications in active, activating, and downloading states. This query requires that the node name
// corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service
// Fabric nodes on the cluster.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
// includeHealthState - include the health state of an entity.
// If this parameter is false or not specified, then the health state returned is "Unknown".
// When set to true, the query goes in parallel to the node and the health system service before the results
// are merged.
// As a result, the query is more expensive and may take a longer time.
func (client BaseClient) GetDeployedApplicationInfo(ctx context.Context, nodeName string, applicationID string, timeout *int64, includeHealthState *bool) (result DeployedApplicationInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedApplicationInfo", err.Error())
	}

	req, err := client.GetDeployedApplicationInfoPreparer(ctx, nodeName, applicationID, timeout, includeHealthState)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedApplicationInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedApplicationInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationInfoPreparer prepares the GetDeployedApplicationInfo request.
func (client BaseClient) GetDeployedApplicationInfoPreparer(ctx context.Context, nodeName string, applicationID string, timeout *int64, includeHealthState *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.1"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}
	if includeHealthState != nil {
		queryParameters["IncludeHealthState"] = autorest.Encode("query", *includeHealthState)
	} else {
		queryParameters["IncludeHealthState"] = autorest.Encode("query", false)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationInfoSender sends the GetDeployedApplicationInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedApplicationInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationInfoResponder handles the response to the GetDeployedApplicationInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedApplicationInfoResponder(resp *http.Response) (result DeployedApplicationInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationInfoList gets the list of applications deployed on a Service Fabric node. The results do not
// include information about deployed system applications unless explicitly queried for by ID. Results encompass
// deployed applications in active, activating, and downloading states. This query requires that the node name
// corresponds to a node on the cluster. The query fails if the provided node name does not point to any active Service
// Fabric nodes on the cluster.
// Parameters:
// nodeName - the name of the node.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
// includeHealthState - include the health state of an entity.
// If this parameter is false or not specified, then the health state returned is "Unknown".
// When set to true, the query goes in parallel to the node and the health system service before the results
// are merged.
// As a result, the query is more expensive and may take a longer time.
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// maxResults - the maximum number of results to be returned as part of the paged queries. This parameter
// defines the upper bound on the number of results returned. The results returned can be less than the
// specified maximum results if they do not fit in the message as per the max message size restrictions defined
// in the configuration. If this parameter is zero or not specified, the paged queries includes as much results
// as possible that fit in the return message.
func (client BaseClient) GetDeployedApplicationInfoList(ctx context.Context, nodeName string, timeout *int64, includeHealthState *bool, continuationToken string, maxResults *int64) (result PagedDeployedApplicationInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}},
		{TargetValue: maxResults,
			Constraints: []validation.Constraint{{Target: "maxResults", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "maxResults", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedApplicationInfoList", err.Error())
	}

	req, err := client.GetDeployedApplicationInfoListPreparer(ctx, nodeName, timeout, includeHealthState, continuationToken, maxResults)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedApplicationInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedApplicationInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedApplicationInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationInfoListPreparer prepares the GetDeployedApplicationInfoList request.
func (client BaseClient) GetDeployedApplicationInfoListPreparer(ctx context.Context, nodeName string, timeout *int64, includeHealthState *bool, continuationToken string, maxResults *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.1"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}
	if includeHealthState != nil {
		queryParameters["IncludeHealthState"] = autorest.Encode("query", *includeHealthState)
	} else {
		queryParameters["IncludeHealthState"] = autorest.Encode("query", false)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if maxResults != nil {
		queryParameters["MaxResults"] = autorest.Encode("query", *maxResults)
	} else {
		queryParameters["MaxResults"] = autorest.Encode("query", 0)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationInfoListSender sends the GetDeployedApplicationInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedApplicationInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedApplicationInfoListResponder handles the response to the GetDeployedApplicationInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedApplicationInfoListResponder(resp *http.Response) (result PagedDeployedApplicationInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedCodePackageInfoList gets the list of code packages deployed on a Service Fabric node for the given
// application.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// serviceManifestName - the name of a service manifest registered as part of an application type in a Service
// Fabric cluster.
// codePackageName - the name of code package specified in service manifest registered as part of an
// application type in a Service Fabric cluster.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedCodePackageInfoList(ctx context.Context, nodeName string, applicationID string, serviceManifestName string, codePackageName string, timeout *int64) (result ListDeployedCodePackageInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedCodePackageInfoList", err.Error())
	}

	req, err := client.GetDeployedCodePackageInfoListPreparer(ctx, nodeName, applicationID, serviceManifestName, codePackageName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedCodePackageInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedCodePackageInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedCodePackageInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedCodePackageInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedCodePackageInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedCodePackageInfoListPreparer prepares the GetDeployedCodePackageInfoList request.
func (client BaseClient) GetDeployedCodePackageInfoListPreparer(ctx context.Context, nodeName string, applicationID string, serviceManifestName string, codePackageName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(serviceManifestName) > 0 {
		queryParameters["ServiceManifestName"] = autorest.Encode("query", serviceManifestName)
	}
	if len(codePackageName) > 0 {
		queryParameters["CodePackageName"] = autorest.Encode("query", codePackageName)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedCodePackageInfoListSender sends the GetDeployedCodePackageInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedCodePackageInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedCodePackageInfoListResponder handles the response to the GetDeployedCodePackageInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedCodePackageInfoListResponder(resp *http.Response) (result ListDeployedCodePackageInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageHealth gets the information about health of service package for a specific application
// deployed on a Service Fabric node. Use EventsHealthStateFilter to optionally filter for the collection of
// HealthEvent objects reported on the deployed service package based on health state.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// servicePackageName - the name of the service package.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedServicePackageHealth(ctx context.Context, nodeName string, applicationID string, servicePackageName string, eventsHealthStateFilter *int32, timeout *int64) (result DeployedServicePackageHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedServicePackageHealth", err.Error())
	}

	req, err := client.GetDeployedServicePackageHealthPreparer(ctx, nodeName, applicationID, servicePackageName, eventsHealthStateFilter, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServicePackageHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServicePackageHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageHealthPreparer prepares the GetDeployedServicePackageHealth request.
func (client BaseClient) GetDeployedServicePackageHealthPreparer(ctx context.Context, nodeName string, applicationID string, servicePackageName string, eventsHealthStateFilter *int32, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId":      applicationID,
		"nodeName":           autorest.Encode("path", nodeName),
		"servicePackageName": servicePackageName,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageHealthSender sends the GetDeployedServicePackageHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServicePackageHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageHealthResponder handles the response to the GetDeployedServicePackageHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServicePackageHealthResponder(resp *http.Response) (result DeployedServicePackageHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageHealthUsingPolicy gets the information about health of an service package for a specific
// application deployed on a Service Fabric node. using the specified policy. Use EventsHealthStateFilter to optionally
// filter for the collection of HealthEvent objects reported on the deployed service package based on health state. Use
// ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only uses
// 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while evaluating
// the health of the deployed service package.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// servicePackageName - the name of the service package.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// applicationHealthPolicy - describes the health policies used to evaluate the health of an application or one
// of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health
// policy.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedServicePackageHealthUsingPolicy(ctx context.Context, nodeName string, applicationID string, servicePackageName string, eventsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (result DeployedServicePackageHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedServicePackageHealthUsingPolicy", err.Error())
	}

	req, err := client.GetDeployedServicePackageHealthUsingPolicyPreparer(ctx, nodeName, applicationID, servicePackageName, eventsHealthStateFilter, applicationHealthPolicy, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServicePackageHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServicePackageHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageHealthUsingPolicyPreparer prepares the GetDeployedServicePackageHealthUsingPolicy request.
func (client BaseClient) GetDeployedServicePackageHealthUsingPolicyPreparer(ctx context.Context, nodeName string, applicationID string, servicePackageName string, eventsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId":      applicationID,
		"nodeName":           autorest.Encode("path", nodeName),
		"servicePackageName": servicePackageName,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageHealthUsingPolicySender sends the GetDeployedServicePackageHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServicePackageHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageHealthUsingPolicyResponder handles the response to the GetDeployedServicePackageHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServicePackageHealthUsingPolicyResponder(resp *http.Response) (result DeployedServicePackageHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageInfoList returns the information about the service packages deployed on a Service Fabric
// node for the given application.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedServicePackageInfoList(ctx context.Context, nodeName string, applicationID string, timeout *int64) (result ListDeployedServicePackageInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedServicePackageInfoList", err.Error())
	}

	req, err := client.GetDeployedServicePackageInfoListPreparer(ctx, nodeName, applicationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServicePackageInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServicePackageInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageInfoListPreparer prepares the GetDeployedServicePackageInfoList request.
func (client BaseClient) GetDeployedServicePackageInfoListPreparer(ctx context.Context, nodeName string, applicationID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageInfoListSender sends the GetDeployedServicePackageInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServicePackageInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageInfoListResponder handles the response to the GetDeployedServicePackageInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServicePackageInfoListResponder(resp *http.Response) (result ListDeployedServicePackageInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageInfoListByName returns the information about the service packages deployed on a Service
// Fabric node for the given application. These results are of service packages whose name match exactly the service
// package name specified as the parameter.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// servicePackageName - the name of the service package.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedServicePackageInfoListByName(ctx context.Context, nodeName string, applicationID string, servicePackageName string, timeout *int64) (result ListDeployedServicePackageInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedServicePackageInfoListByName", err.Error())
	}

	req, err := client.GetDeployedServicePackageInfoListByNamePreparer(ctx, nodeName, applicationID, servicePackageName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoListByName", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServicePackageInfoListByNameSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoListByName", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServicePackageInfoListByNameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServicePackageInfoListByName", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageInfoListByNamePreparer prepares the GetDeployedServicePackageInfoListByName request.
func (client BaseClient) GetDeployedServicePackageInfoListByNamePreparer(ctx context.Context, nodeName string, applicationID string, servicePackageName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId":      applicationID,
		"nodeName":           autorest.Encode("path", nodeName),
		"servicePackageName": servicePackageName,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageInfoListByNameSender sends the GetDeployedServicePackageInfoListByName request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServicePackageInfoListByNameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServicePackageInfoListByNameResponder handles the response to the GetDeployedServicePackageInfoListByName request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServicePackageInfoListByNameResponder(resp *http.Response) (result ListDeployedServicePackageInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaDetailInfo gets the details of the replica deployed on a Service Fabric node. The
// information include service kind, service name, current service operation, current service operation start date
// time, partition id, replica/instance id, reported load and other information.
// Parameters:
// nodeName - the name of the node.
// partitionID - the identity of the partition.
// replicaID - the identifier of the replica.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedServiceReplicaDetailInfo(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, timeout *int64) (result DeployedServiceReplicaDetailInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfo", err.Error())
	}

	req, err := client.GetDeployedServiceReplicaDetailInfoPreparer(ctx, nodeName, partitionID, replicaID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServiceReplicaDetailInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServiceReplicaDetailInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaDetailInfoPreparer prepares the GetDeployedServiceReplicaDetailInfo request.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoPreparer(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName":    autorest.Encode("path", nodeName),
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetDetail", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaDetailInfoSender sends the GetDeployedServiceReplicaDetailInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaDetailInfoResponder handles the response to the GetDeployedServiceReplicaDetailInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoResponder(resp *http.Response) (result DeployedServiceReplicaDetailInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaDetailInfoByPartitionID gets the details of the replica deployed on a Service Fabric node.
// The information include service kind, service name, current service operation, current service operation start date
// time, partition id, replica/instance id, reported load and other information.
// Parameters:
// nodeName - the name of the node.
// partitionID - the identity of the partition.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoByPartitionID(ctx context.Context, nodeName string, partitionID uuid.UUID, timeout *int64) (result DeployedServiceReplicaDetailInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfoByPartitionID", err.Error())
	}

	req, err := client.GetDeployedServiceReplicaDetailInfoByPartitionIDPreparer(ctx, nodeName, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfoByPartitionID", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServiceReplicaDetailInfoByPartitionIDSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfoByPartitionID", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServiceReplicaDetailInfoByPartitionIDResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaDetailInfoByPartitionID", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaDetailInfoByPartitionIDPreparer prepares the GetDeployedServiceReplicaDetailInfoByPartitionID request.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoByPartitionIDPreparer(ctx context.Context, nodeName string, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName":    autorest.Encode("path", nodeName),
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaDetailInfoByPartitionIDSender sends the GetDeployedServiceReplicaDetailInfoByPartitionID request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoByPartitionIDSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaDetailInfoByPartitionIDResponder handles the response to the GetDeployedServiceReplicaDetailInfoByPartitionID request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServiceReplicaDetailInfoByPartitionIDResponder(resp *http.Response) (result DeployedServiceReplicaDetailInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaInfoList gets the list containing the information about replicas deployed on a Service
// Fabric node. The information include partition id, replica id, status of the replica, name of the service, name of
// the service type and other information. Use PartitionId or ServiceManifestName query parameters to return
// information about the deployed replicas matching the specified values for those parameters.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// partitionID - the identity of the partition.
// serviceManifestName - the name of a service manifest registered as part of an application type in a Service
// Fabric cluster.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedServiceReplicaInfoList(ctx context.Context, nodeName string, applicationID string, partitionID *uuid.UUID, serviceManifestName string, timeout *int64) (result ListDeployedServiceReplicaInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedServiceReplicaInfoList", err.Error())
	}

	req, err := client.GetDeployedServiceReplicaInfoListPreparer(ctx, nodeName, applicationID, partitionID, serviceManifestName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServiceReplicaInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServiceReplicaInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceReplicaInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaInfoListPreparer prepares the GetDeployedServiceReplicaInfoList request.
func (client BaseClient) GetDeployedServiceReplicaInfoListPreparer(ctx context.Context, nodeName string, applicationID string, partitionID *uuid.UUID, serviceManifestName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if partitionID != nil {
		queryParameters["PartitionId"] = autorest.Encode("query", *partitionID)
	}
	if len(serviceManifestName) > 0 {
		queryParameters["ServiceManifestName"] = autorest.Encode("query", serviceManifestName)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetReplicas", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaInfoListSender sends the GetDeployedServiceReplicaInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServiceReplicaInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceReplicaInfoListResponder handles the response to the GetDeployedServiceReplicaInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServiceReplicaInfoListResponder(resp *http.Response) (result ListDeployedServiceReplicaInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceTypeInfoByName gets the list containing the information about a specific service type from the
// applications deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its
// registration status, the code package that registered it and activation id of the service package. Each entry
// represents one activation of a service type, differentiated by the activation id.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// serviceTypeName - specifies the name of a Service Fabric service type.
// serviceManifestName - the name of the service manifest to filter the list of deployed service type
// information. If specified, the response will only contain the information about service types that are
// defined in this service manifest.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedServiceTypeInfoByName(ctx context.Context, nodeName string, applicationID string, serviceTypeName string, serviceManifestName string, timeout *int64) (result ListDeployedServiceTypeInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedServiceTypeInfoByName", err.Error())
	}

	req, err := client.GetDeployedServiceTypeInfoByNamePreparer(ctx, nodeName, applicationID, serviceTypeName, serviceManifestName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoByName", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServiceTypeInfoByNameSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoByName", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServiceTypeInfoByNameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoByName", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceTypeInfoByNamePreparer prepares the GetDeployedServiceTypeInfoByName request.
func (client BaseClient) GetDeployedServiceTypeInfoByNamePreparer(ctx context.Context, nodeName string, applicationID string, serviceTypeName string, serviceManifestName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId":   applicationID,
		"nodeName":        autorest.Encode("path", nodeName),
		"serviceTypeName": serviceTypeName,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(serviceManifestName) > 0 {
		queryParameters["ServiceManifestName"] = autorest.Encode("query", serviceManifestName)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes/{serviceTypeName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceTypeInfoByNameSender sends the GetDeployedServiceTypeInfoByName request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServiceTypeInfoByNameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceTypeInfoByNameResponder handles the response to the GetDeployedServiceTypeInfoByName request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServiceTypeInfoByNameResponder(resp *http.Response) (result ListDeployedServiceTypeInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceTypeInfoList gets the list containing the information about service types from the applications
// deployed on a node in a Service Fabric cluster. The response includes the name of the service type, its registration
// status, the code package that registered it and activation id of the service package.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// serviceManifestName - the name of the service manifest to filter the list of deployed service type
// information. If specified, the response will only contain the information about service types that are
// defined in this service manifest.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetDeployedServiceTypeInfoList(ctx context.Context, nodeName string, applicationID string, serviceManifestName string, timeout *int64) (result ListDeployedServiceTypeInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetDeployedServiceTypeInfoList", err.Error())
	}

	req, err := client.GetDeployedServiceTypeInfoListPreparer(ctx, nodeName, applicationID, serviceManifestName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeployedServiceTypeInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeployedServiceTypeInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetDeployedServiceTypeInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceTypeInfoListPreparer prepares the GetDeployedServiceTypeInfoList request.
func (client BaseClient) GetDeployedServiceTypeInfoListPreparer(ctx context.Context, nodeName string, applicationID string, serviceManifestName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(serviceManifestName) > 0 {
		queryParameters["ServiceManifestName"] = autorest.Encode("query", serviceManifestName)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServiceTypes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceTypeInfoListSender sends the GetDeployedServiceTypeInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDeployedServiceTypeInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetDeployedServiceTypeInfoListResponder handles the response to the GetDeployedServiceTypeInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDeployedServiceTypeInfoListResponder(resp *http.Response) (result ListDeployedServiceTypeInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetFaultOperationList gets the a list of user-induced fault operations filtered by provided input.
// Parameters:
// typeFilter - used to filter on OperationType for user-induced operations.
// 65535 - select all
// 1     - select PartitionDataLoss.
// 2     - select PartitionQuorumLoss.
// 4     - select PartitionRestart.
// 8     - select NodeTransition.
// stateFilter - used to filter on OperationState's for user-induced operations.
// 65535 - select All
// 1     - select Running
// 2     - select RollingBack
// 8     - select Completed
// 16    - select Faulted
// 32    - select Cancelled
// 64    - select ForceCancelled
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetFaultOperationList(ctx context.Context, typeFilter int32, stateFilter int32, timeout *int64) (result ListOperationStatus, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetFaultOperationList", err.Error())
	}

	req, err := client.GetFaultOperationListPreparer(ctx, typeFilter, stateFilter, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetFaultOperationList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFaultOperationListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetFaultOperationList", resp, "Failure sending request")
		return
	}

	result, err = client.GetFaultOperationListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetFaultOperationList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetFaultOperationListPreparer prepares the GetFaultOperationList request.
func (client BaseClient) GetFaultOperationListPreparer(ctx context.Context, typeFilter int32, stateFilter int32, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"StateFilter": autorest.Encode("query", stateFilter),
		"TypeFilter":  autorest.Encode("query", typeFilter),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Faults/"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetFaultOperationListSender sends the GetFaultOperationList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetFaultOperationListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetFaultOperationListResponder handles the response to the GetFaultOperationList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetFaultOperationListResponder(resp *http.Response) (result ListOperationStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreContent returns the information about the image store content at the specified contentPath relative to
// the root of the image store.
// Parameters:
// contentPath - relative path to file or folder in the image store from its root.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetImageStoreContent(ctx context.Context, contentPath string, timeout *int64) (result ImageStoreContent, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetImageStoreContent", err.Error())
	}

	req, err := client.GetImageStoreContentPreparer(ctx, contentPath, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreContent", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetImageStoreContentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreContent", resp, "Failure sending request")
		return
	}

	result, err = client.GetImageStoreContentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreContent", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreContentPreparer prepares the GetImageStoreContent request.
func (client BaseClient) GetImageStoreContentPreparer(ctx context.Context, contentPath string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"contentPath": autorest.Encode("path", contentPath),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ImageStore/{contentPath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreContentSender sends the GetImageStoreContent request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetImageStoreContentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreContentResponder handles the response to the GetImageStoreContent request. The method always
// closes the http.Response Body.
func (client BaseClient) GetImageStoreContentResponder(resp *http.Response) (result ImageStoreContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreRootContent returns the information about the image store content at the root of the image store.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetImageStoreRootContent(ctx context.Context, timeout *int64) (result ImageStoreContent, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetImageStoreRootContent", err.Error())
	}

	req, err := client.GetImageStoreRootContentPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreRootContent", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetImageStoreRootContentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreRootContent", resp, "Failure sending request")
		return
	}

	result, err = client.GetImageStoreRootContentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreRootContent", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreRootContentPreparer prepares the GetImageStoreRootContent request.
func (client BaseClient) GetImageStoreRootContentPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ImageStore"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreRootContentSender sends the GetImageStoreRootContent request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetImageStoreRootContentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreRootContentResponder handles the response to the GetImageStoreRootContent request. The method always
// closes the http.Response Body.
func (client BaseClient) GetImageStoreRootContentResponder(resp *http.Response) (result ImageStoreContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreUploadSessionByID gets the image store upload session identified by the given ID. User can query the
// upload session at any time during uploading.
// Parameters:
// sessionID - a GUID generated by the user for a file uploading. It identifies an image store upload session
// which keeps track of all file chunks until it is committed.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetImageStoreUploadSessionByID(ctx context.Context, sessionID uuid.UUID, timeout *int64) (result UploadSession, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetImageStoreUploadSessionByID", err.Error())
	}

	req, err := client.GetImageStoreUploadSessionByIDPreparer(ctx, sessionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreUploadSessionByID", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetImageStoreUploadSessionByIDSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreUploadSessionByID", resp, "Failure sending request")
		return
	}

	result, err = client.GetImageStoreUploadSessionByIDResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreUploadSessionByID", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreUploadSessionByIDPreparer prepares the GetImageStoreUploadSessionByID request.
func (client BaseClient) GetImageStoreUploadSessionByIDPreparer(ctx context.Context, sessionID uuid.UUID, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"session-id":  autorest.Encode("query", sessionID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ImageStore/$/GetUploadSession"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreUploadSessionByIDSender sends the GetImageStoreUploadSessionByID request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetImageStoreUploadSessionByIDSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreUploadSessionByIDResponder handles the response to the GetImageStoreUploadSessionByID request. The method always
// closes the http.Response Body.
func (client BaseClient) GetImageStoreUploadSessionByIDResponder(resp *http.Response) (result UploadSession, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreUploadSessionByPath gets the image store upload session associated with the given image store relative
// path. User can query the upload session at any time during uploading.
// Parameters:
// contentPath - relative path to file or folder in the image store from its root.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetImageStoreUploadSessionByPath(ctx context.Context, contentPath string, timeout *int64) (result UploadSession, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetImageStoreUploadSessionByPath", err.Error())
	}

	req, err := client.GetImageStoreUploadSessionByPathPreparer(ctx, contentPath, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreUploadSessionByPath", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetImageStoreUploadSessionByPathSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreUploadSessionByPath", resp, "Failure sending request")
		return
	}

	result, err = client.GetImageStoreUploadSessionByPathResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetImageStoreUploadSessionByPath", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreUploadSessionByPathPreparer prepares the GetImageStoreUploadSessionByPath request.
func (client BaseClient) GetImageStoreUploadSessionByPathPreparer(ctx context.Context, contentPath string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"contentPath": autorest.Encode("path", contentPath),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ImageStore/{contentPath}/$/GetUploadSession", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreUploadSessionByPathSender sends the GetImageStoreUploadSessionByPath request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetImageStoreUploadSessionByPathSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetImageStoreUploadSessionByPathResponder handles the response to the GetImageStoreUploadSessionByPath request. The method always
// closes the http.Response Body.
func (client BaseClient) GetImageStoreUploadSessionByPathResponder(resp *http.Response) (result UploadSession, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNameExistsInfo returns whether the specified Service Fabric name exists.
// Parameters:
// nameID - the Service Fabric name, without the 'fabric:' URI scheme.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetNameExistsInfo(ctx context.Context, nameID string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetNameExistsInfo", err.Error())
	}

	req, err := client.GetNameExistsInfoPreparer(ctx, nameID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNameExistsInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNameExistsInfoSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNameExistsInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetNameExistsInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNameExistsInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNameExistsInfoPreparer prepares the GetNameExistsInfo request.
func (client BaseClient) GetNameExistsInfoPreparer(ctx context.Context, nameID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNameExistsInfoSender sends the GetNameExistsInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNameExistsInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNameExistsInfoResponder handles the response to the GetNameExistsInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNameExistsInfoResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeHealth gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the collection of
// health events reported on the node based on the health state. If the node that you specify by name does not exist in
// the health store, this returns an error.
// Parameters:
// nodeName - the name of the node.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetNodeHealth(ctx context.Context, nodeName string, eventsHealthStateFilter *int32, timeout *int64) (result NodeHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetNodeHealth", err.Error())
	}

	req, err := client.GetNodeHealthPreparer(ctx, nodeName, eventsHealthStateFilter, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeHealthPreparer prepares the GetNodeHealth request.
func (client BaseClient) GetNodeHealthPreparer(ctx context.Context, nodeName string, eventsHealthStateFilter *int32, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeHealthSender sends the GetNodeHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeHealthResponder handles the response to the GetNodeHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeHealthResponder(resp *http.Response) (result NodeHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeHealthUsingPolicy gets the health of a Service Fabric node. Use EventsHealthStateFilter to filter the
// collection of health events reported on the node based on the health state. Use ClusterHealthPolicy in the POST body
// to override the health policies used to evaluate the health. If the node that you specify by name does not exist in
// the health store, this returns an error.
// Parameters:
// nodeName - the name of the node.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// clusterHealthPolicy - describes the health policies used to evaluate the health of a cluster or node. If not
// present, the health evaluation uses the health policy from cluster manifest or the default health policy.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetNodeHealthUsingPolicy(ctx context.Context, nodeName string, eventsHealthStateFilter *int32, clusterHealthPolicy *ClusterHealthPolicy, timeout *int64) (result NodeHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetNodeHealthUsingPolicy", err.Error())
	}

	req, err := client.GetNodeHealthUsingPolicyPreparer(ctx, nodeName, eventsHealthStateFilter, clusterHealthPolicy, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeHealthUsingPolicyPreparer prepares the GetNodeHealthUsingPolicy request.
func (client BaseClient) GetNodeHealthUsingPolicyPreparer(ctx context.Context, nodeName string, eventsHealthStateFilter *int32, clusterHealthPolicy *ClusterHealthPolicy, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if clusterHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(clusterHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeHealthUsingPolicySender sends the GetNodeHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeHealthUsingPolicyResponder handles the response to the GetNodeHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeHealthUsingPolicyResponder(resp *http.Response) (result NodeHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeInfo gets the information about a specific node in the Service Fabric Cluster.The response include the name,
// status, id, health, uptime and other details about the node.
// Parameters:
// nodeName - the name of the node.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetNodeInfo(ctx context.Context, nodeName string, timeout *int64) (result NodeInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetNodeInfo", err.Error())
	}

	req, err := client.GetNodeInfoPreparer(ctx, nodeName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeInfoPreparer prepares the GetNodeInfo request.
func (client BaseClient) GetNodeInfoPreparer(ctx context.Context, nodeName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeInfoSender sends the GetNodeInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeInfoResponder handles the response to the GetNodeInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeInfoResponder(resp *http.Response) (result NodeInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeInfoList gets the list of nodes in the Service Fabric cluster. The response include the name, status, id,
// health, uptime and other details about the node.
// Parameters:
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// nodeStatusFilter - allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the
// specified filter value will be returned. The filter value can be one of the following.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetNodeInfoList(ctx context.Context, continuationToken string, nodeStatusFilter NodeStatusFilterOptionalQueryParam, timeout *int64) (result PagedNodeInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetNodeInfoList", err.Error())
	}

	req, err := client.GetNodeInfoListPreparer(ctx, continuationToken, nodeStatusFilter, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeInfoListPreparer prepares the GetNodeInfoList request.
func (client BaseClient) GetNodeInfoListPreparer(ctx context.Context, continuationToken string, nodeStatusFilter NodeStatusFilterOptionalQueryParam, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if len(string(nodeStatusFilter)) > 0 {
		queryParameters["NodeStatusFilter"] = autorest.Encode("query", nodeStatusFilter)
	} else {
		queryParameters["NodeStatusFilter"] = autorest.Encode("query", "default")
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Nodes"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeInfoListSender sends the GetNodeInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeInfoListResponder handles the response to the GetNodeInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeInfoListResponder(resp *http.Response) (result PagedNodeInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeLoadInfo retrieves the load information of a Service Fabric node for all the metrics that have load or
// capacity defined.
// Parameters:
// nodeName - the name of the node.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetNodeLoadInfo(ctx context.Context, nodeName string, timeout *int64) (result NodeLoadInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetNodeLoadInfo", err.Error())
	}

	req, err := client.GetNodeLoadInfoPreparer(ctx, nodeName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeLoadInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeLoadInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeLoadInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeLoadInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeLoadInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeLoadInfoPreparer prepares the GetNodeLoadInfo request.
func (client BaseClient) GetNodeLoadInfoPreparer(ctx context.Context, nodeName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetLoadInformation", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeLoadInfoSender sends the GetNodeLoadInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeLoadInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeLoadInfoResponder handles the response to the GetNodeLoadInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeLoadInfoResponder(resp *http.Response) (result NodeLoadInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeTransitionProgress gets the progress of an operation started with StartNodeTransition using the provided
// OperationId.
// Parameters:
// nodeName - the name of the node.
// operationID - a GUID that identifies a call of this API.  This is passed into the corresponding GetProgress
// API
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetNodeTransitionProgress(ctx context.Context, nodeName string, operationID uuid.UUID, timeout *int64) (result NodeTransitionProgress, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetNodeTransitionProgress", err.Error())
	}

	req, err := client.GetNodeTransitionProgressPreparer(ctx, nodeName, operationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeTransitionProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNodeTransitionProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeTransitionProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetNodeTransitionProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetNodeTransitionProgress", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeTransitionProgressPreparer prepares the GetNodeTransitionProgress request.
func (client BaseClient) GetNodeTransitionProgressPreparer(ctx context.Context, nodeName string, operationID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"OperationId": autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Nodes/{nodeName}/$/GetTransitionProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeTransitionProgressSender sends the GetNodeTransitionProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetNodeTransitionProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetNodeTransitionProgressResponder handles the response to the GetNodeTransitionProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetNodeTransitionProgressResponder(resp *http.Response) (result NodeTransitionProgress, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionHealth gets the health information of the specified partition.
// Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health
// state.
// Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition.
// If you specify a partition that does not exist in the health store, this cmdlet returns an error.
// Parameters:
// partitionID - the identity of the partition.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// replicasHealthStateFilter - allows filtering the collection of ReplicaHealthState objects on the partition.
// The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas
// that match the filter will be returned. All replicas will be used to evaluate the aggregated health state.
// If not specified, all entries will be returned.The state values are flag based enumeration, so the value
// could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided
// value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The
// possible values for this parameter include integer value of one of the following health states.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// excludeHealthStatistics - indicates whether the health statistics should be returned as part of the query
// result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetPartitionHealth(ctx context.Context, partitionID uuid.UUID, eventsHealthStateFilter *int32, replicasHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (result PartitionHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetPartitionHealth", err.Error())
	}

	req, err := client.GetPartitionHealthPreparer(ctx, partitionID, eventsHealthStateFilter, replicasHealthStateFilter, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionHealthPreparer prepares the GetPartitionHealth request.
func (client BaseClient) GetPartitionHealthPreparer(ctx context.Context, partitionID uuid.UUID, eventsHealthStateFilter *int32, replicasHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if replicasHealthStateFilter != nil {
		queryParameters["ReplicasHealthStateFilter"] = autorest.Encode("query", *replicasHealthStateFilter)
	} else {
		queryParameters["ReplicasHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	} else {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionHealthSender sends the GetPartitionHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionHealthResponder handles the response to the GetPartitionHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionHealthResponder(resp *http.Response) (result PartitionHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionHealthUsingPolicy gets the health information of the specified partition.
// If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
// If the policy is not specified, the health evaluation uses the application health policy defined in the application
// manifest, or the default health policy, if no policy is defined in the manifest.
// Use EventsHealthStateFilter to filter the collection of health events reported on the partition based on the health
// state.
// Use ReplicasHealthStateFilter to filter the collection of ReplicaHealthState objects on the partition. Use
// ApplicationHealthPolicy in the POST body to override the health policies used to evaluate the health.
// If you specify a partition that does not exist in the health store, this cmdlet returns an error.
// Parameters:
// partitionID - the identity of the partition.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// replicasHealthStateFilter - allows filtering the collection of ReplicaHealthState objects on the partition.
// The value can be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas
// that match the filter will be returned. All replicas will be used to evaluate the aggregated health state.
// If not specified, all entries will be returned.The state values are flag based enumeration, so the value
// could be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided
// value is 6 then all of the events with HealthState value of OK (2) and Warning (4) will be returned. The
// possible values for this parameter include integer value of one of the following health states.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// applicationHealthPolicy - describes the health policies used to evaluate the health of an application or one
// of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health
// policy.
// excludeHealthStatistics - indicates whether the health statistics should be returned as part of the query
// result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetPartitionHealthUsingPolicy(ctx context.Context, partitionID uuid.UUID, eventsHealthStateFilter *int32, replicasHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (result PartitionHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetPartitionHealthUsingPolicy", err.Error())
	}

	req, err := client.GetPartitionHealthUsingPolicyPreparer(ctx, partitionID, eventsHealthStateFilter, replicasHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionHealthUsingPolicyPreparer prepares the GetPartitionHealthUsingPolicy request.
func (client BaseClient) GetPartitionHealthUsingPolicyPreparer(ctx context.Context, partitionID uuid.UUID, eventsHealthStateFilter *int32, replicasHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if replicasHealthStateFilter != nil {
		queryParameters["ReplicasHealthStateFilter"] = autorest.Encode("query", *replicasHealthStateFilter)
	} else {
		queryParameters["ReplicasHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	} else {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionHealthUsingPolicySender sends the GetPartitionHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionHealthUsingPolicyResponder handles the response to the GetPartitionHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionHealthUsingPolicyResponder(resp *http.Response) (result PartitionHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionInfo the Partitions endpoint returns information about the specified partition. The response include the
// partition id, partitioning scheme information, keys supported by the partition, status, health and other details
// about the partition.
// Parameters:
// partitionID - the identity of the partition.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetPartitionInfo(ctx context.Context, partitionID uuid.UUID, timeout *int64) (result ServicePartitionInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetPartitionInfo", err.Error())
	}

	req, err := client.GetPartitionInfoPreparer(ctx, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionInfoPreparer prepares the GetPartitionInfo request.
func (client BaseClient) GetPartitionInfoPreparer(ctx context.Context, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionInfoSender sends the GetPartitionInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionInfoResponder handles the response to the GetPartitionInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionInfoResponder(resp *http.Response) (result ServicePartitionInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionInfoList gets the list of partitions of a Service Fabric service. The response include the partition id,
// partitioning scheme information, keys supported by the partition, status, health and other details about the
// partition.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetPartitionInfoList(ctx context.Context, serviceID string, continuationToken string, timeout *int64) (result PagedServicePartitionInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetPartitionInfoList", err.Error())
	}

	req, err := client.GetPartitionInfoListPreparer(ctx, serviceID, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionInfoListPreparer prepares the GetPartitionInfoList request.
func (client BaseClient) GetPartitionInfoListPreparer(ctx context.Context, serviceID string, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/GetPartitions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionInfoListSender sends the GetPartitionInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionInfoListResponder handles the response to the GetPartitionInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionInfoListResponder(resp *http.Response) (result PagedServicePartitionInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionLoadInformation returns information about the specified partition.
// The response includes a list of load information.
// Each information includes load metric name, value and last reported time in UTC.
// Parameters:
// partitionID - the identity of the partition.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetPartitionLoadInformation(ctx context.Context, partitionID uuid.UUID, timeout *int64) (result PartitionLoadInformation, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetPartitionLoadInformation", err.Error())
	}

	req, err := client.GetPartitionLoadInformationPreparer(ctx, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionLoadInformation", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionLoadInformationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionLoadInformation", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionLoadInformationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionLoadInformation", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionLoadInformationPreparer prepares the GetPartitionLoadInformation request.
func (client BaseClient) GetPartitionLoadInformationPreparer(ctx context.Context, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetLoadInformation", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionLoadInformationSender sends the GetPartitionLoadInformation request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionLoadInformationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionLoadInformationResponder handles the response to the GetPartitionLoadInformation request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionLoadInformationResponder(resp *http.Response) (result PartitionLoadInformation, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionRestartProgress gets the progress of a PartitionRestart started with StartPartitionRestart using the
// provided OperationId.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// partitionID - the identity of the partition.
// operationID - a GUID that identifies a call of this API.  This is passed into the corresponding GetProgress
// API
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetPartitionRestartProgress(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (result PartitionRestartProgress, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetPartitionRestartProgress", err.Error())
	}

	req, err := client.GetPartitionRestartProgressPreparer(ctx, serviceID, partitionID, operationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionRestartProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPartitionRestartProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionRestartProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetPartitionRestartProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPartitionRestartProgress", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionRestartProgressPreparer prepares the GetPartitionRestartProgress request.
func (client BaseClient) GetPartitionRestartProgressPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"OperationId": autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetRestartProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionRestartProgressSender sends the GetPartitionRestartProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPartitionRestartProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPartitionRestartProgressResponder handles the response to the GetPartitionRestartProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPartitionRestartProgressResponder(resp *http.Response) (result PartitionRestartProgress, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPropertyInfo gets the specified Service Fabric property under a given name. This will always return both value
// and metadata.
// Parameters:
// nameID - the Service Fabric name, without the 'fabric:' URI scheme.
// propertyName - specifies the name of the property to get.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetPropertyInfo(ctx context.Context, nameID string, propertyName string, timeout *int64) (result PropertyInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetPropertyInfo", err.Error())
	}

	req, err := client.GetPropertyInfoPreparer(ctx, nameID, propertyName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPropertyInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetPropertyInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPropertyInfoPreparer prepares the GetPropertyInfo request.
func (client BaseClient) GetPropertyInfoPreparer(ctx context.Context, nameID string, propertyName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":  APIVersion,
		"PropertyName": autorest.Encode("query", propertyName),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetProperty", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPropertyInfoSender sends the GetPropertyInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPropertyInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPropertyInfoResponder handles the response to the GetPropertyInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPropertyInfoResponder(resp *http.Response) (result PropertyInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPropertyInfoList a Service Fabric name can have one or more named properties that stores custom information. This
// operation gets the information about these properties in a paged list. The information include name, value and
// metadata about each of the properties.
// Parameters:
// nameID - the Service Fabric name, without the 'fabric:' URI scheme.
// includeValues - allows specifying whether to include the values of the properties returned. True if values
// should be returned with the metadata; False to return only property metadata.
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetPropertyInfoList(ctx context.Context, nameID string, includeValues *bool, continuationToken string, timeout *int64) (result PagedPropertyInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetPropertyInfoList", err.Error())
	}

	req, err := client.GetPropertyInfoListPreparer(ctx, nameID, includeValues, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPropertyInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetPropertyInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetPropertyInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPropertyInfoListPreparer prepares the GetPropertyInfoList request.
func (client BaseClient) GetPropertyInfoListPreparer(ctx context.Context, nameID string, includeValues *bool, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if includeValues != nil {
		queryParameters["IncludeValues"] = autorest.Encode("query", *includeValues)
	} else {
		queryParameters["IncludeValues"] = autorest.Encode("query", false)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetProperties", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPropertyInfoListSender sends the GetPropertyInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetPropertyInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetPropertyInfoListResponder handles the response to the GetPropertyInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetPropertyInfoListResponder(resp *http.Response) (result PagedPropertyInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetProvisionedFabricCodeVersionInfoList gets a list of information about fabric code versions that are provisioned
// in the cluster. The parameter CodeVersion can be used to optionally filter the output to only that particular
// version.
// Parameters:
// codeVersion - the product version of Service Fabric.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetProvisionedFabricCodeVersionInfoList(ctx context.Context, codeVersion string, timeout *int64) (result ListFabricCodeVersionInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetProvisionedFabricCodeVersionInfoList", err.Error())
	}

	req, err := client.GetProvisionedFabricCodeVersionInfoListPreparer(ctx, codeVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricCodeVersionInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProvisionedFabricCodeVersionInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricCodeVersionInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetProvisionedFabricCodeVersionInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricCodeVersionInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetProvisionedFabricCodeVersionInfoListPreparer prepares the GetProvisionedFabricCodeVersionInfoList request.
func (client BaseClient) GetProvisionedFabricCodeVersionInfoListPreparer(ctx context.Context, codeVersion string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(codeVersion) > 0 {
		queryParameters["CodeVersion"] = autorest.Encode("query", codeVersion)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetProvisionedCodeVersions"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetProvisionedFabricCodeVersionInfoListSender sends the GetProvisionedFabricCodeVersionInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetProvisionedFabricCodeVersionInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetProvisionedFabricCodeVersionInfoListResponder handles the response to the GetProvisionedFabricCodeVersionInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetProvisionedFabricCodeVersionInfoListResponder(resp *http.Response) (result ListFabricCodeVersionInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetProvisionedFabricConfigVersionInfoList gets a list of information about fabric config versions that are
// provisioned in the cluster. The parameter ConfigVersion can be used to optionally filter the output to only that
// particular version.
// Parameters:
// configVersion - the config version of Service Fabric.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetProvisionedFabricConfigVersionInfoList(ctx context.Context, configVersion string, timeout *int64) (result ListFabricConfigVersionInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetProvisionedFabricConfigVersionInfoList", err.Error())
	}

	req, err := client.GetProvisionedFabricConfigVersionInfoListPreparer(ctx, configVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricConfigVersionInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProvisionedFabricConfigVersionInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricConfigVersionInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetProvisionedFabricConfigVersionInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetProvisionedFabricConfigVersionInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetProvisionedFabricConfigVersionInfoListPreparer prepares the GetProvisionedFabricConfigVersionInfoList request.
func (client BaseClient) GetProvisionedFabricConfigVersionInfoListPreparer(ctx context.Context, configVersion string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(configVersion) > 0 {
		queryParameters["ConfigVersion"] = autorest.Encode("query", configVersion)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetProvisionedConfigVersions"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetProvisionedFabricConfigVersionInfoListSender sends the GetProvisionedFabricConfigVersionInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetProvisionedFabricConfigVersionInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetProvisionedFabricConfigVersionInfoListResponder handles the response to the GetProvisionedFabricConfigVersionInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetProvisionedFabricConfigVersionInfoListResponder(resp *http.Response) (result ListFabricConfigVersionInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetQuorumLossProgress gets the progress of a quorum loss operation started with StartQuorumLoss, using the provided
// OperationId.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// partitionID - the identity of the partition.
// operationID - a GUID that identifies a call of this API.  This is passed into the corresponding GetProgress
// API
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetQuorumLossProgress(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (result PartitionQuorumLossProgress, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetQuorumLossProgress", err.Error())
	}

	req, err := client.GetQuorumLossProgressPreparer(ctx, serviceID, partitionID, operationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetQuorumLossProgress", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetQuorumLossProgressSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetQuorumLossProgress", resp, "Failure sending request")
		return
	}

	result, err = client.GetQuorumLossProgressResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetQuorumLossProgress", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetQuorumLossProgressPreparer prepares the GetQuorumLossProgress request.
func (client BaseClient) GetQuorumLossProgressPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"OperationId": autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/GetQuorumLossProgress", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetQuorumLossProgressSender sends the GetQuorumLossProgress request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetQuorumLossProgressSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetQuorumLossProgressResponder handles the response to the GetQuorumLossProgress request. The method always
// closes the http.Response Body.
func (client BaseClient) GetQuorumLossProgressResponder(resp *http.Response) (result PartitionQuorumLossProgress, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetRepairTaskList this API supports the Service Fabric platform; it is not meant to be used directly from your code.
// Parameters:
// taskIDFilter - the repair task ID prefix to be matched.
// stateFilter - a bitwise-OR of the following values, specifying which task states should be included in the
// result list.
// - 1 - Created
// - 2 - Claimed
// - 4 - Preparing
// - 8 - Approved
// - 16 - Executing
// - 32 - Restoring
// - 64 - Completed
// executorFilter - the name of the repair executor whose claimed tasks should be included in the list.
func (client BaseClient) GetRepairTaskList(ctx context.Context, taskIDFilter string, stateFilter *int32, executorFilter string) (result ListRepairTask, err error) {
	req, err := client.GetRepairTaskListPreparer(ctx, taskIDFilter, stateFilter, executorFilter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetRepairTaskList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetRepairTaskListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetRepairTaskList", resp, "Failure sending request")
		return
	}

	result, err = client.GetRepairTaskListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetRepairTaskList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetRepairTaskListPreparer prepares the GetRepairTaskList request.
func (client BaseClient) GetRepairTaskListPreparer(ctx context.Context, taskIDFilter string, stateFilter *int32, executorFilter string) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(taskIDFilter) > 0 {
		queryParameters["TaskIdFilter"] = autorest.Encode("query", taskIDFilter)
	}
	if stateFilter != nil {
		queryParameters["StateFilter"] = autorest.Encode("query", *stateFilter)
	}
	if len(executorFilter) > 0 {
		queryParameters["ExecutorFilter"] = autorest.Encode("query", executorFilter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetRepairTaskList"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetRepairTaskListSender sends the GetRepairTaskList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetRepairTaskListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetRepairTaskListResponder handles the response to the GetRepairTaskList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetRepairTaskListResponder(resp *http.Response) (result ListRepairTask, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaHealth gets the health of a Service Fabric replica.
// Use EventsHealthStateFilter to filter the collection of health events reported on the replica based on the health
// state.
// Parameters:
// partitionID - the identity of the partition.
// replicaID - the identifier of the replica.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetReplicaHealth(ctx context.Context, partitionID uuid.UUID, replicaID string, eventsHealthStateFilter *int32, timeout *int64) (result ReplicaHealthModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetReplicaHealth", err.Error())
	}

	req, err := client.GetReplicaHealthPreparer(ctx, partitionID, replicaID, eventsHealthStateFilter, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetReplicaHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetReplicaHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaHealthPreparer prepares the GetReplicaHealth request.
func (client BaseClient) GetReplicaHealthPreparer(ctx context.Context, partitionID uuid.UUID, replicaID string, eventsHealthStateFilter *int32, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaHealthSender sends the GetReplicaHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetReplicaHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaHealthResponder handles the response to the GetReplicaHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetReplicaHealthResponder(resp *http.Response) (result ReplicaHealthModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaHealthUsingPolicy gets the health of a Service Fabric stateful service replica or stateless service
// instance.
// Use EventsHealthStateFilter to filter the collection of health events reported on the cluster based on the health
// state.
// Use ApplicationHealthPolicy to optionally override the health policies used to evaluate the health. This API only
// uses 'ConsiderWarningAsError' field of the ApplicationHealthPolicy. The rest of the fields are ignored while
// evaluating the health of the replica.
// Parameters:
// partitionID - the identity of the partition.
// replicaID - the identifier of the replica.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// applicationHealthPolicy - describes the health policies used to evaluate the health of an application or one
// of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health
// policy.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetReplicaHealthUsingPolicy(ctx context.Context, partitionID uuid.UUID, replicaID string, eventsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (result ReplicaHealthModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetReplicaHealthUsingPolicy", err.Error())
	}

	req, err := client.GetReplicaHealthUsingPolicyPreparer(ctx, partitionID, replicaID, eventsHealthStateFilter, applicationHealthPolicy, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetReplicaHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetReplicaHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaHealthUsingPolicyPreparer prepares the GetReplicaHealthUsingPolicy request.
func (client BaseClient) GetReplicaHealthUsingPolicyPreparer(ctx context.Context, partitionID uuid.UUID, replicaID string, eventsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaHealthUsingPolicySender sends the GetReplicaHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetReplicaHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaHealthUsingPolicyResponder handles the response to the GetReplicaHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetReplicaHealthUsingPolicyResponder(resp *http.Response) (result ReplicaHealthModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaInfo the response include the id, role, status, health, node name, uptime, and other details about the
// replica.
// Parameters:
// partitionID - the identity of the partition.
// replicaID - the identifier of the replica.
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetReplicaInfo(ctx context.Context, partitionID uuid.UUID, replicaID string, continuationToken string, timeout *int64) (result ReplicaInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetReplicaInfo", err.Error())
	}

	req, err := client.GetReplicaInfoPreparer(ctx, partitionID, replicaID, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetReplicaInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetReplicaInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaInfoPreparer prepares the GetReplicaInfo request.
func (client BaseClient) GetReplicaInfoPreparer(ctx context.Context, partitionID uuid.UUID, replicaID string, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetReplicas/{replicaId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaInfoSender sends the GetReplicaInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetReplicaInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaInfoResponder handles the response to the GetReplicaInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetReplicaInfoResponder(resp *http.Response) (result ReplicaInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaInfoList the GetReplicas endpoint returns information about the replicas of the specified partition. The
// respons include the id, role, status, health, node name, uptime, and other details about the replica.
// Parameters:
// partitionID - the identity of the partition.
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetReplicaInfoList(ctx context.Context, partitionID uuid.UUID, continuationToken string, timeout *int64) (result PagedReplicaInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetReplicaInfoList", err.Error())
	}

	req, err := client.GetReplicaInfoListPreparer(ctx, partitionID, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetReplicaInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetReplicaInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetReplicaInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaInfoListPreparer prepares the GetReplicaInfoList request.
func (client BaseClient) GetReplicaInfoListPreparer(ctx context.Context, partitionID uuid.UUID, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetReplicas", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaInfoListSender sends the GetReplicaInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetReplicaInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetReplicaInfoListResponder handles the response to the GetReplicaInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetReplicaInfoListResponder(resp *http.Response) (result PagedReplicaInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceDescription gets the description of an existing Service Fabric service. A service must be created before
// its description can be obtained.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetServiceDescription(ctx context.Context, serviceID string, timeout *int64) (result ServiceDescriptionModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetServiceDescription", err.Error())
	}

	req, err := client.GetServiceDescriptionPreparer(ctx, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceDescription", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceDescriptionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceDescription", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceDescriptionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceDescription", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceDescriptionPreparer prepares the GetServiceDescription request.
func (client BaseClient) GetServiceDescriptionPreparer(ctx context.Context, serviceID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/GetDescription", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceDescriptionSender sends the GetServiceDescription request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceDescriptionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceDescriptionResponder handles the response to the GetServiceDescription request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceDescriptionResponder(resp *http.Response) (result ServiceDescriptionModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceHealth gets the health information of the specified service.
// Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health
// state.
// Use PartitionsHealthStateFilter to filter the collection of partitions returned.
// If you specify a service that does not exist in the health store, this cmdlet returns an error.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// partitionsHealthStateFilter - allows filtering of the partitions health state objects returned in the result
// of service health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated
// health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value
// obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of
// partitions with HealthState value of OK (2) and Warning (4) will be returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// excludeHealthStatistics - indicates whether the health statistics should be returned as part of the query
// result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetServiceHealth(ctx context.Context, serviceID string, eventsHealthStateFilter *int32, partitionsHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (result ServiceHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetServiceHealth", err.Error())
	}

	req, err := client.GetServiceHealthPreparer(ctx, serviceID, eventsHealthStateFilter, partitionsHealthStateFilter, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceHealthSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealth", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceHealthPreparer prepares the GetServiceHealth request.
func (client BaseClient) GetServiceHealthPreparer(ctx context.Context, serviceID string, eventsHealthStateFilter *int32, partitionsHealthStateFilter *int32, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if partitionsHealthStateFilter != nil {
		queryParameters["PartitionsHealthStateFilter"] = autorest.Encode("query", *partitionsHealthStateFilter)
	} else {
		queryParameters["PartitionsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	} else {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceHealthSender sends the GetServiceHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceHealthResponder handles the response to the GetServiceHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceHealthResponder(resp *http.Response) (result ServiceHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceHealthUsingPolicy gets the health information of the specified service.
// If the application health policy is specified, the health evaluation uses it to get the aggregated health state.
// If the policy is not specified, the health evaluation uses the application health policy defined in the application
// manifest, or the default health policy, if no policy is defined in the manifest.
// Use EventsHealthStateFilter to filter the collection of health events reported on the service based on the health
// state.
// Use PartitionsHealthStateFilter to filter the collection of partitions returned.
// If you specify a service that does not exist in the health store, this cmdlet returns an error.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// eventsHealthStateFilter - allows filtering the collection of HealthEvent objects returned based on health
// state.
// The possible values for this parameter include integer value of one of the following health states.
// Only events that match the filter are returned. All events are used to evaluate the aggregated health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value obtained using bitwise 'OR' operator. For example, If the provided value is
// 6 then all of the events with HealthState value of OK (2) and Warning (4) are returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// partitionsHealthStateFilter - allows filtering of the partitions health state objects returned in the result
// of service health query based on their health state.
// The possible values for this parameter include integer value of one of the following health states.
// Only partitions that match the filter are returned. All partitions are used to evaluate the aggregated
// health state.
// If not specified, all entries are returned. The state values are flag based enumeration, so the value could
// be a combination of these value
// obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health state of
// partitions with HealthState value of OK (2) and Warning (4) will be returned.
//
// - Default - Default value. Matches any HealthState. The value is zero.
// - None - Filter that doesn't match any HealthState value. Used in order to return no results on a given
// collection of states. The value is 1.
// - Ok - Filter that matches input with HealthState value Ok. The value is 2.
// - Warning - Filter that matches input with HealthState value Warning. The value is 4.
// - Error - Filter that matches input with HealthState value Error. The value is 8.
// - All - Filter that matches input with any HealthState value. The value is 65535.
// applicationHealthPolicy - describes the health policies used to evaluate the health of an application or one
// of its children.
// If not present, the health evaluation uses the health policy from application manifest or the default health
// policy.
// excludeHealthStatistics - indicates whether the health statistics should be returned as part of the query
// result. False by default.
// The statistics show the number of children entities in health state Ok, Warning, and Error.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetServiceHealthUsingPolicy(ctx context.Context, serviceID string, eventsHealthStateFilter *int32, partitionsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (result ServiceHealth, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetServiceHealthUsingPolicy", err.Error())
	}

	req, err := client.GetServiceHealthUsingPolicyPreparer(ctx, serviceID, eventsHealthStateFilter, partitionsHealthStateFilter, applicationHealthPolicy, excludeHealthStatistics, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealthUsingPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceHealthUsingPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealthUsingPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceHealthUsingPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceHealthUsingPolicy", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceHealthUsingPolicyPreparer prepares the GetServiceHealthUsingPolicy request.
func (client BaseClient) GetServiceHealthUsingPolicyPreparer(ctx context.Context, serviceID string, eventsHealthStateFilter *int32, partitionsHealthStateFilter *int32, applicationHealthPolicy *ApplicationHealthPolicy, excludeHealthStatistics *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if eventsHealthStateFilter != nil {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", *eventsHealthStateFilter)
	} else {
		queryParameters["EventsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if partitionsHealthStateFilter != nil {
		queryParameters["PartitionsHealthStateFilter"] = autorest.Encode("query", *partitionsHealthStateFilter)
	} else {
		queryParameters["PartitionsHealthStateFilter"] = autorest.Encode("query", 0)
	}
	if excludeHealthStatistics != nil {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", *excludeHealthStatistics)
	} else {
		queryParameters["ExcludeHealthStatistics"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/GetHealth", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if applicationHealthPolicy != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(applicationHealthPolicy))
	}
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceHealthUsingPolicySender sends the GetServiceHealthUsingPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceHealthUsingPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceHealthUsingPolicyResponder handles the response to the GetServiceHealthUsingPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceHealthUsingPolicyResponder(resp *http.Response) (result ServiceHealth, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceInfo returns the information about specified service belonging to the specified Service Fabric
// application.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetServiceInfo(ctx context.Context, applicationID string, serviceID string, timeout *int64) (result ServiceInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetServiceInfo", err.Error())
	}

	req, err := client.GetServiceInfoPreparer(ctx, applicationID, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceInfoPreparer prepares the GetServiceInfo request.
func (client BaseClient) GetServiceInfoPreparer(ctx context.Context, applicationID string, serviceID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"serviceId":     serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetServices/{serviceId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceInfoSender sends the GetServiceInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceInfoResponder handles the response to the GetServiceInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceInfoResponder(resp *http.Response) (result ServiceInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceInfoList returns the information about all services belonging to the application specified by the
// application id.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// serviceTypeName - the service type name used to filter the services to query for.
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetServiceInfoList(ctx context.Context, applicationID string, serviceTypeName string, continuationToken string, timeout *int64) (result PagedServiceInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetServiceInfoList", err.Error())
	}

	req, err := client.GetServiceInfoListPreparer(ctx, applicationID, serviceTypeName, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceInfoListPreparer prepares the GetServiceInfoList request.
func (client BaseClient) GetServiceInfoListPreparer(ctx context.Context, applicationID string, serviceTypeName string, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(serviceTypeName) > 0 {
		queryParameters["ServiceTypeName"] = autorest.Encode("query", serviceTypeName)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/GetServices", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceInfoListSender sends the GetServiceInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceInfoListResponder handles the response to the GetServiceInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceInfoListResponder(resp *http.Response) (result PagedServiceInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceManifest gets the manifest describing a service type. The response contains the service manifest XML as a
// string.
// Parameters:
// applicationTypeName - the name of the application type.
// applicationTypeVersion - the version of the application type.
// serviceManifestName - the name of a service manifest registered as part of an application type in a Service
// Fabric cluster.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetServiceManifest(ctx context.Context, applicationTypeName string, applicationTypeVersion string, serviceManifestName string, timeout *int64) (result ServiceTypeManifest, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetServiceManifest", err.Error())
	}

	req, err := client.GetServiceManifestPreparer(ctx, applicationTypeName, applicationTypeVersion, serviceManifestName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceManifest", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceManifestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceManifest", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceManifestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceManifest", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceManifestPreparer prepares the GetServiceManifest request.
func (client BaseClient) GetServiceManifestPreparer(ctx context.Context, applicationTypeName string, applicationTypeVersion string, serviceManifestName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationTypeName": autorest.Encode("path", applicationTypeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":            APIVersion,
		"ApplicationTypeVersion": autorest.Encode("query", applicationTypeVersion),
		"ServiceManifestName":    autorest.Encode("query", serviceManifestName),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ApplicationTypes/{applicationTypeName}/$/GetServiceManifest", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceManifestSender sends the GetServiceManifest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceManifestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceManifestResponder handles the response to the GetServiceManifest request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceManifestResponder(resp *http.Response) (result ServiceTypeManifest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceNameInfo the GetServiceName endpoint returns the name of the service for the specified partition.
// Parameters:
// partitionID - the identity of the partition.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetServiceNameInfo(ctx context.Context, partitionID uuid.UUID, timeout *int64) (result ServiceNameInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetServiceNameInfo", err.Error())
	}

	req, err := client.GetServiceNameInfoPreparer(ctx, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceNameInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceNameInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceNameInfo", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceNameInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceNameInfo", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceNameInfoPreparer prepares the GetServiceNameInfo request.
func (client BaseClient) GetServiceNameInfoPreparer(ctx context.Context, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetServiceName", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceNameInfoSender sends the GetServiceNameInfo request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceNameInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceNameInfoResponder handles the response to the GetServiceNameInfo request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceNameInfoResponder(resp *http.Response) (result ServiceNameInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceTypeInfoList gets the list containing the information about service types that are supported by a
// provisioned application type in a Service Fabric cluster. The response includes the name of the service type, the
// name and version of the service manifest the type is defined in, kind (stateless or stateless) of the service type
// and other information about it.
// Parameters:
// applicationTypeName - the name of the application type.
// applicationTypeVersion - the version of the application type.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetServiceTypeInfoList(ctx context.Context, applicationTypeName string, applicationTypeVersion string, timeout *int64) (result ListServiceTypeInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetServiceTypeInfoList", err.Error())
	}

	req, err := client.GetServiceTypeInfoListPreparer(ctx, applicationTypeName, applicationTypeVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceTypeInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetServiceTypeInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceTypeInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetServiceTypeInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetServiceTypeInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceTypeInfoListPreparer prepares the GetServiceTypeInfoList request.
func (client BaseClient) GetServiceTypeInfoListPreparer(ctx context.Context, applicationTypeName string, applicationTypeVersion string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationTypeName": autorest.Encode("path", applicationTypeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":            APIVersion,
		"ApplicationTypeVersion": autorest.Encode("query", applicationTypeVersion),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ApplicationTypes/{applicationTypeName}/$/GetServiceTypes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceTypeInfoListSender sends the GetServiceTypeInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetServiceTypeInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetServiceTypeInfoListResponder handles the response to the GetServiceTypeInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetServiceTypeInfoListResponder(resp *http.Response) (result ListServiceTypeInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetSubNameInfoList enumerates all the Service Fabric names under a given name. If the subnames do not fit in a page,
// one page of results is returned as well as a continuation token which can be used to get the next page. Querying a
// name that doesn't exist will fail.
// Parameters:
// nameID - the Service Fabric name, without the 'fabric:' URI scheme.
// recursive - allows specifying that the search performed should be recursive.
// continuationToken - the continuation token parameter is used to obtain next set of results. A continuation
// token with a non empty value is included in the response of the API when the results from the system do not
// fit in a single response. When this value is passed to the next API call, the API returns next set of
// results. If there are no further results then the continuation token does not contain a value. The value of
// this parameter should not be URL encoded.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetSubNameInfoList(ctx context.Context, nameID string, recursive *bool, continuationToken string, timeout *int64) (result PagedSubNameInfoList, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetSubNameInfoList", err.Error())
	}

	req, err := client.GetSubNameInfoListPreparer(ctx, nameID, recursive, continuationToken, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetSubNameInfoList", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSubNameInfoListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetSubNameInfoList", resp, "Failure sending request")
		return
	}

	result, err = client.GetSubNameInfoListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetSubNameInfoList", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetSubNameInfoListPreparer prepares the GetSubNameInfoList request.
func (client BaseClient) GetSubNameInfoListPreparer(ctx context.Context, nameID string, recursive *bool, continuationToken string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if recursive != nil {
		queryParameters["Recursive"] = autorest.Encode("query", *recursive)
	} else {
		queryParameters["Recursive"] = autorest.Encode("query", false)
	}
	if len(continuationToken) > 0 {
		queryParameters["ContinuationToken"] = continuationToken
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetSubNames", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetSubNameInfoListSender sends the GetSubNameInfoList request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSubNameInfoListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetSubNameInfoListResponder handles the response to the GetSubNameInfoList request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSubNameInfoListResponder(resp *http.Response) (result PagedSubNameInfoList, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetUpgradeOrchestrationServiceState get the service state of Service Fabric Upgrade Orchestration Service. This API
// is internally used for support purposes.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) GetUpgradeOrchestrationServiceState(ctx context.Context, timeout *int64) (result UpgradeOrchestrationServiceState, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "GetUpgradeOrchestrationServiceState", err.Error())
	}

	req, err := client.GetUpgradeOrchestrationServiceStatePreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetUpgradeOrchestrationServiceState", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetUpgradeOrchestrationServiceStateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetUpgradeOrchestrationServiceState", resp, "Failure sending request")
		return
	}

	result, err = client.GetUpgradeOrchestrationServiceStateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "GetUpgradeOrchestrationServiceState", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetUpgradeOrchestrationServiceStatePreparer prepares the GetUpgradeOrchestrationServiceState request.
func (client BaseClient) GetUpgradeOrchestrationServiceStatePreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/GetUpgradeOrchestrationServiceState"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetUpgradeOrchestrationServiceStateSender sends the GetUpgradeOrchestrationServiceState request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetUpgradeOrchestrationServiceStateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// GetUpgradeOrchestrationServiceStateResponder handles the response to the GetUpgradeOrchestrationServiceState request. The method always
// closes the http.Response Body.
func (client BaseClient) GetUpgradeOrchestrationServiceStateResponder(resp *http.Response) (result UpgradeOrchestrationServiceState, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// InvokeInfrastructureCommand for clusters that have one or more instances of the Infrastructure Service configured,
// this API provides a way to send infrastructure-specific commands to a particular
// instance of the Infrastructure Service.
//
// Available commands and their corresponding response formats vary depending upon
// the infrastructure on which the cluster is running.
//
// This API supports the Service Fabric platform; it is not meant to be used directly from your code.
// Parameters:
// command - the text of the command to be invoked. The content of the command is infrastructure-specific.
// serviceID - the identity of the infrastructure service. This is  the full name of the infrastructure service
// without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one
// instance of infrastructure service running.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) InvokeInfrastructureCommand(ctx context.Context, command string, serviceID string, timeout *int64) (result String, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "InvokeInfrastructureCommand", err.Error())
	}

	req, err := client.InvokeInfrastructureCommandPreparer(ctx, command, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureCommand", nil, "Failure preparing request")
		return
	}

	resp, err := client.InvokeInfrastructureCommandSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureCommand", resp, "Failure sending request")
		return
	}

	result, err = client.InvokeInfrastructureCommandResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureCommand", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// InvokeInfrastructureCommandPreparer prepares the InvokeInfrastructureCommand request.
func (client BaseClient) InvokeInfrastructureCommandPreparer(ctx context.Context, command string, serviceID string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"Command":     autorest.Encode("query", command),
	}
	if len(serviceID) > 0 {
		queryParameters["ServiceId"] = autorest.Encode("query", serviceID)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/InvokeInfrastructureCommand"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// InvokeInfrastructureCommandSender sends the InvokeInfrastructureCommand request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) InvokeInfrastructureCommandSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// InvokeInfrastructureCommandResponder handles the response to the InvokeInfrastructureCommand request. The method always
// closes the http.Response Body.
func (client BaseClient) InvokeInfrastructureCommandResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// InvokeInfrastructureQuery for clusters that have one or more instances of the Infrastructure Service configured,
// this API provides a way to send infrastructure-specific queries to a particular
// instance of the Infrastructure Service.
//
// Available commands and their corresponding response formats vary depending upon
// the infrastructure on which the cluster is running.
//
// This API supports the Service Fabric platform; it is not meant to be used directly from your code.
// Parameters:
// command - the text of the command to be invoked. The content of the command is infrastructure-specific.
// serviceID - the identity of the infrastructure service. This is  the full name of the infrastructure service
// without the 'fabric:' URI scheme. This parameter required only for the cluster that have more than one
// instance of infrastructure service running.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) InvokeInfrastructureQuery(ctx context.Context, command string, serviceID string, timeout *int64) (result String, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "InvokeInfrastructureQuery", err.Error())
	}

	req, err := client.InvokeInfrastructureQueryPreparer(ctx, command, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureQuery", nil, "Failure preparing request")
		return
	}

	resp, err := client.InvokeInfrastructureQuerySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureQuery", resp, "Failure sending request")
		return
	}

	result, err = client.InvokeInfrastructureQueryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "InvokeInfrastructureQuery", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// InvokeInfrastructureQueryPreparer prepares the InvokeInfrastructureQuery request.
func (client BaseClient) InvokeInfrastructureQueryPreparer(ctx context.Context, command string, serviceID string, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"Command":     autorest.Encode("query", command),
	}
	if len(serviceID) > 0 {
		queryParameters["ServiceId"] = autorest.Encode("query", serviceID)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/InvokeInfrastructureQuery"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// InvokeInfrastructureQuerySender sends the InvokeInfrastructureQuery request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) InvokeInfrastructureQuerySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// InvokeInfrastructureQueryResponder handles the response to the InvokeInfrastructureQuery request. The method always
// closes the http.Response Body.
func (client BaseClient) InvokeInfrastructureQueryResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ProvisionApplicationType provisions a Service Fabric application type with the cluster. This is required before any
// new applications can be instantiated.
// The provision operation can be performed either on the application package specified by the
// relativePathInImageStore, or by using the URI of the external .sfpkg.
// Parameters:
// provisionApplicationTypeDescriptionBaseRequiredBodyParam - the base type of provision application type
// description which supports either image store based provision or external store based provision.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ProvisionApplicationType(ctx context.Context, provisionApplicationTypeDescriptionBaseRequiredBodyParam BasicProvisionApplicationTypeDescriptionBase, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: provisionApplicationTypeDescriptionBaseRequiredBodyParam,
			Constraints: []validation.Constraint{{Target: "provisionApplicationTypeDescriptionBaseRequiredBodyParam.Async", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ProvisionApplicationType", err.Error())
	}

	req, err := client.ProvisionApplicationTypePreparer(ctx, provisionApplicationTypeDescriptionBaseRequiredBodyParam, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionApplicationType", nil, "Failure preparing request")
		return
	}

	resp, err := client.ProvisionApplicationTypeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionApplicationType", resp, "Failure sending request")
		return
	}

	result, err = client.ProvisionApplicationTypeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionApplicationType", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ProvisionApplicationTypePreparer prepares the ProvisionApplicationType request.
func (client BaseClient) ProvisionApplicationTypePreparer(ctx context.Context, provisionApplicationTypeDescriptionBaseRequiredBodyParam BasicProvisionApplicationTypeDescriptionBase, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.1"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/ApplicationTypes/$/Provision"),
		autorest.WithJSON(provisionApplicationTypeDescriptionBaseRequiredBodyParam),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ProvisionApplicationTypeSender sends the ProvisionApplicationType request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ProvisionApplicationTypeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ProvisionApplicationTypeResponder handles the response to the ProvisionApplicationType request. The method always
// closes the http.Response Body.
func (client BaseClient) ProvisionApplicationTypeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ProvisionCluster validate and provision the code or configuration packages of a Service Fabric cluster.
// Parameters:
// provisionFabricDescription - describes the parameters for provisioning a cluster.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ProvisionCluster(ctx context.Context, provisionFabricDescription ProvisionFabricDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ProvisionCluster", err.Error())
	}

	req, err := client.ProvisionClusterPreparer(ctx, provisionFabricDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionCluster", nil, "Failure preparing request")
		return
	}

	resp, err := client.ProvisionClusterSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionCluster", resp, "Failure sending request")
		return
	}

	result, err = client.ProvisionClusterResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ProvisionCluster", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ProvisionClusterPreparer prepares the ProvisionCluster request.
func (client BaseClient) ProvisionClusterPreparer(ctx context.Context, provisionFabricDescription ProvisionFabricDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/Provision"),
		autorest.WithJSON(provisionFabricDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ProvisionClusterSender sends the ProvisionCluster request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ProvisionClusterSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ProvisionClusterResponder handles the response to the ProvisionCluster request. The method always
// closes the http.Response Body.
func (client BaseClient) ProvisionClusterResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// PutProperty creates or updates the specified Service Fabric property under a given name.
// Parameters:
// nameID - the Service Fabric name, without the 'fabric:' URI scheme.
// propertyDescription - describes the Service Fabric property to be created.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) PutProperty(ctx context.Context, nameID string, propertyDescription PropertyDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: propertyDescription,
			Constraints: []validation.Constraint{{Target: "propertyDescription.PropertyName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "propertyDescription.Value", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "PutProperty", err.Error())
	}

	req, err := client.PutPropertyPreparer(ctx, nameID, propertyDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "PutProperty", nil, "Failure preparing request")
		return
	}

	resp, err := client.PutPropertySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "PutProperty", resp, "Failure sending request")
		return
	}

	result, err = client.PutPropertyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "PutProperty", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// PutPropertyPreparer prepares the PutProperty request.
func (client BaseClient) PutPropertyPreparer(ctx context.Context, nameID string, propertyDescription PropertyDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetProperty", pathParameters),
		autorest.WithJSON(propertyDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// PutPropertySender sends the PutProperty request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) PutPropertySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// PutPropertyResponder handles the response to the PutProperty request. The method always
// closes the http.Response Body.
func (client BaseClient) PutPropertyResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverAllPartitions indicates to the Service Fabric cluster that it should attempt to recover any services
// (including system services) which are currently stuck in quorum loss. This operation should only be performed if it
// is known that the replicas that are down cannot be recovered. Incorrect use of this API can cause potential data
// loss.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RecoverAllPartitions(ctx context.Context, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RecoverAllPartitions", err.Error())
	}

	req, err := client.RecoverAllPartitionsPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverAllPartitions", nil, "Failure preparing request")
		return
	}

	resp, err := client.RecoverAllPartitionsSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverAllPartitions", resp, "Failure sending request")
		return
	}

	result, err = client.RecoverAllPartitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverAllPartitions", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverAllPartitionsPreparer prepares the RecoverAllPartitions request.
func (client BaseClient) RecoverAllPartitionsPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/RecoverAllPartitions"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverAllPartitionsSender sends the RecoverAllPartitions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RecoverAllPartitionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverAllPartitionsResponder handles the response to the RecoverAllPartitions request. The method always
// closes the http.Response Body.
func (client BaseClient) RecoverAllPartitionsResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverPartition indicates to the Service Fabric cluster that it should attempt to recover a specific partition
// which is currently stuck in quorum loss. This operation should only be performed if it is known that the replicas
// that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
// Parameters:
// partitionID - the identity of the partition.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RecoverPartition(ctx context.Context, partitionID uuid.UUID, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RecoverPartition", err.Error())
	}

	req, err := client.RecoverPartitionPreparer(ctx, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverPartition", nil, "Failure preparing request")
		return
	}

	resp, err := client.RecoverPartitionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverPartition", resp, "Failure sending request")
		return
	}

	result, err = client.RecoverPartitionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverPartition", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverPartitionPreparer prepares the RecoverPartition request.
func (client BaseClient) RecoverPartitionPreparer(ctx context.Context, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/Recover", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverPartitionSender sends the RecoverPartition request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RecoverPartitionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverPartitionResponder handles the response to the RecoverPartition request. The method always
// closes the http.Response Body.
func (client BaseClient) RecoverPartitionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverServicePartitions indicates to the Service Fabric cluster that it should attempt to recover the specified
// service which is currently stuck in quorum loss. This operation should only be performed if it is known that the
// replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RecoverServicePartitions(ctx context.Context, serviceID string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RecoverServicePartitions", err.Error())
	}

	req, err := client.RecoverServicePartitionsPreparer(ctx, serviceID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverServicePartitions", nil, "Failure preparing request")
		return
	}

	resp, err := client.RecoverServicePartitionsSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverServicePartitions", resp, "Failure sending request")
		return
	}

	result, err = client.RecoverServicePartitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverServicePartitions", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverServicePartitionsPreparer prepares the RecoverServicePartitions request.
func (client BaseClient) RecoverServicePartitionsPreparer(ctx context.Context, serviceID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/$/{serviceId}/$/GetPartitions/$/Recover", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverServicePartitionsSender sends the RecoverServicePartitions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RecoverServicePartitionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverServicePartitionsResponder handles the response to the RecoverServicePartitions request. The method always
// closes the http.Response Body.
func (client BaseClient) RecoverServicePartitionsResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverSystemPartitions indicates to the Service Fabric cluster that it should attempt to recover the system
// services which are currently stuck in quorum loss. This operation should only be performed if it is known that the
// replicas that are down cannot be recovered. Incorrect use of this API can cause potential data loss.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RecoverSystemPartitions(ctx context.Context, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RecoverSystemPartitions", err.Error())
	}

	req, err := client.RecoverSystemPartitionsPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverSystemPartitions", nil, "Failure preparing request")
		return
	}

	resp, err := client.RecoverSystemPartitionsSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverSystemPartitions", resp, "Failure sending request")
		return
	}

	result, err = client.RecoverSystemPartitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RecoverSystemPartitions", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverSystemPartitionsPreparer prepares the RecoverSystemPartitions request.
func (client BaseClient) RecoverSystemPartitionsPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/RecoverSystemPartitions"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverSystemPartitionsSender sends the RecoverSystemPartitions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RecoverSystemPartitionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RecoverSystemPartitionsResponder handles the response to the RecoverSystemPartitions request. The method always
// closes the http.Response Body.
func (client BaseClient) RecoverSystemPartitionsResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveComposeDeployment deletes an existing Service Fabric compose deployment.
// Parameters:
// deploymentName - the identity of the deployment.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RemoveComposeDeployment(ctx context.Context, deploymentName string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RemoveComposeDeployment", err.Error())
	}

	req, err := client.RemoveComposeDeploymentPreparer(ctx, deploymentName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveComposeDeployment", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveComposeDeploymentSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveComposeDeployment", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveComposeDeploymentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveComposeDeployment", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveComposeDeploymentPreparer prepares the RemoveComposeDeployment request.
func (client BaseClient) RemoveComposeDeploymentPreparer(ctx context.Context, deploymentName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"deploymentName": deploymentName,
	}

	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ComposeDeployments/{deploymentName}/$/Delete", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveComposeDeploymentSender sends the RemoveComposeDeployment request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RemoveComposeDeploymentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveComposeDeploymentResponder handles the response to the RemoveComposeDeployment request. The method always
// closes the http.Response Body.
func (client BaseClient) RemoveComposeDeploymentResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveNodeState notifies Service Fabric that the persisted state on a node has been permanently removed or lost.
// This implies that it is not possible to recover the persisted state of that node. This generally happens if a hard
// disk has been wiped clean, or if a hard disk crashes. The node has to be down for this operation to be successful.
// This operation lets Service Fabric know that the replicas on that node no longer exist, and that Service Fabric
// should stop waiting for those replicas to come back up. Do not run this cmdlet if the state on the node has not been
// removed and the node can comes back up with its state intact.
// Parameters:
// nodeName - the name of the node.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RemoveNodeState(ctx context.Context, nodeName string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RemoveNodeState", err.Error())
	}

	req, err := client.RemoveNodeStatePreparer(ctx, nodeName, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveNodeState", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveNodeStateSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveNodeState", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveNodeStateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveNodeState", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveNodeStatePreparer prepares the RemoveNodeState request.
func (client BaseClient) RemoveNodeStatePreparer(ctx context.Context, nodeName string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/RemoveNodeState", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveNodeStateSender sends the RemoveNodeState request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RemoveNodeStateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveNodeStateResponder handles the response to the RemoveNodeState request. The method always
// closes the http.Response Body.
func (client BaseClient) RemoveNodeStateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveReplica this API simulates a Service Fabric replica failure by removing a replica from a Service Fabric
// cluster. The removal closes the replica, transitions the replica to the role None, and then removes all of the state
// information of the replica from the cluster. This API tests the replica state removal path, and simulates the report
// fault permanent path through client APIs. Warning - There are no safety checks performed when this API is used.
// Incorrect use of this API can lead to data loss for stateful services.In addition, the forceRemove flag impacts all
// other replicas hosted in the same process.
// Parameters:
// nodeName - the name of the node.
// partitionID - the identity of the partition.
// replicaID - the identifier of the replica.
// forceRemove - remove a Service Fabric application or service forcefully without going through the graceful
// shutdown sequence. This parameter can be used to forcefully delete an application or service for which
// delete is timing out due to issues in the service code that prevents graceful close of replicas.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RemoveReplica(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, forceRemove *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RemoveReplica", err.Error())
	}

	req, err := client.RemoveReplicaPreparer(ctx, nodeName, partitionID, replicaID, forceRemove, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveReplica", nil, "Failure preparing request")
		return
	}

	resp, err := client.RemoveReplicaSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveReplica", resp, "Failure sending request")
		return
	}

	result, err = client.RemoveReplicaResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RemoveReplica", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveReplicaPreparer prepares the RemoveReplica request.
func (client BaseClient) RemoveReplicaPreparer(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, forceRemove *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName":    autorest.Encode("path", nodeName),
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if forceRemove != nil {
		queryParameters["ForceRemove"] = autorest.Encode("query", *forceRemove)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Delete", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveReplicaSender sends the RemoveReplica request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RemoveReplicaSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RemoveReplicaResponder handles the response to the RemoveReplica request. The method always
// closes the http.Response Body.
func (client BaseClient) RemoveReplicaResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportApplicationHealth reports health state of the specified Service Fabric application. The report must contain
// the information about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway Application, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, get application health and check that the report appears
// in the HealthEvents section.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// healthInformation - describes the health information for the health report. This information needs to be
// present in all of the health reports sent to the health manager.
// immediate - a flag which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store,
// regardless of the fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway
// is closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to
// health store as well as health report processing.
// By default, reports are not sent immediately.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ReportApplicationHealth(ctx context.Context, applicationID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ReportApplicationHealth", err.Error())
	}

	req, err := client.ReportApplicationHealthPreparer(ctx, applicationID, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportApplicationHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportApplicationHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportApplicationHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportApplicationHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportApplicationHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportApplicationHealthPreparer prepares the ReportApplicationHealth request.
func (client BaseClient) ReportApplicationHealthPreparer(ctx context.Context, applicationID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	} else {
		queryParameters["Immediate"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportApplicationHealthSender sends the ReportApplicationHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportApplicationHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportApplicationHealthResponder handles the response to the ReportApplicationHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportApplicationHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportClusterHealth sends a health report on a Service Fabric cluster. The report must contain the information about
// the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway node, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, run GetClusterHealth and check that the report appears in
// the HealthEvents section.
// Parameters:
// healthInformation - describes the health information for the health report. This information needs to be
// present in all of the health reports sent to the health manager.
// immediate - a flag which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store,
// regardless of the fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway
// is closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to
// health store as well as health report processing.
// By default, reports are not sent immediately.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ReportClusterHealth(ctx context.Context, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ReportClusterHealth", err.Error())
	}

	req, err := client.ReportClusterHealthPreparer(ctx, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportClusterHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportClusterHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportClusterHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportClusterHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportClusterHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportClusterHealthPreparer prepares the ReportClusterHealth request.
func (client BaseClient) ReportClusterHealthPreparer(ctx context.Context, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	} else {
		queryParameters["Immediate"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/ReportClusterHealth"),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportClusterHealthSender sends the ReportClusterHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportClusterHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportClusterHealthResponder handles the response to the ReportClusterHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportClusterHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportDeployedApplicationHealth reports health state of the application deployed on a Service Fabric node. The
// report must contain the information about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway Service, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, get deployed application health and check that the report
// appears in the HealthEvents section.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// healthInformation - describes the health information for the health report. This information needs to be
// present in all of the health reports sent to the health manager.
// immediate - a flag which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store,
// regardless of the fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway
// is closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to
// health store as well as health report processing.
// By default, reports are not sent immediately.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ReportDeployedApplicationHealth(ctx context.Context, nodeName string, applicationID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ReportDeployedApplicationHealth", err.Error())
	}

	req, err := client.ReportDeployedApplicationHealthPreparer(ctx, nodeName, applicationID, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedApplicationHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportDeployedApplicationHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedApplicationHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportDeployedApplicationHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedApplicationHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportDeployedApplicationHealthPreparer prepares the ReportDeployedApplicationHealth request.
func (client BaseClient) ReportDeployedApplicationHealthPreparer(ctx context.Context, nodeName string, applicationID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	} else {
		queryParameters["Immediate"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportDeployedApplicationHealthSender sends the ReportDeployedApplicationHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportDeployedApplicationHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportDeployedApplicationHealthResponder handles the response to the ReportDeployedApplicationHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportDeployedApplicationHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportDeployedServicePackageHealth reports health state of the service package of the application deployed on a
// Service Fabric node. The report must contain the information about the source of the health report and property on
// which it is reported.
// The report is sent to a Service Fabric gateway Service, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, get deployed service package health and check that the
// report appears in the HealthEvents section.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// servicePackageName - the name of the service package.
// healthInformation - describes the health information for the health report. This information needs to be
// present in all of the health reports sent to the health manager.
// immediate - a flag which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store,
// regardless of the fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway
// is closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to
// health store as well as health report processing.
// By default, reports are not sent immediately.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ReportDeployedServicePackageHealth(ctx context.Context, nodeName string, applicationID string, servicePackageName string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ReportDeployedServicePackageHealth", err.Error())
	}

	req, err := client.ReportDeployedServicePackageHealthPreparer(ctx, nodeName, applicationID, servicePackageName, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedServicePackageHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportDeployedServicePackageHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedServicePackageHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportDeployedServicePackageHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportDeployedServicePackageHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportDeployedServicePackageHealthPreparer prepares the ReportDeployedServicePackageHealth request.
func (client BaseClient) ReportDeployedServicePackageHealthPreparer(ctx context.Context, nodeName string, applicationID string, servicePackageName string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId":      applicationID,
		"nodeName":           autorest.Encode("path", nodeName),
		"servicePackageName": servicePackageName,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	} else {
		queryParameters["Immediate"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetServicePackages/{servicePackageName}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportDeployedServicePackageHealthSender sends the ReportDeployedServicePackageHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportDeployedServicePackageHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportDeployedServicePackageHealthResponder handles the response to the ReportDeployedServicePackageHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportDeployedServicePackageHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportNodeHealth reports health state of the specified Service Fabric node. The report must contain the information
// about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway node, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, run GetNodeHealth and check that the report appears in
// the HealthEvents section.
// Parameters:
// nodeName - the name of the node.
// healthInformation - describes the health information for the health report. This information needs to be
// present in all of the health reports sent to the health manager.
// immediate - a flag which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store,
// regardless of the fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway
// is closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to
// health store as well as health report processing.
// By default, reports are not sent immediately.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ReportNodeHealth(ctx context.Context, nodeName string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ReportNodeHealth", err.Error())
	}

	req, err := client.ReportNodeHealthPreparer(ctx, nodeName, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportNodeHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportNodeHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportNodeHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportNodeHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportNodeHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportNodeHealthPreparer prepares the ReportNodeHealth request.
func (client BaseClient) ReportNodeHealthPreparer(ctx context.Context, nodeName string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	} else {
		queryParameters["Immediate"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportNodeHealthSender sends the ReportNodeHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportNodeHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportNodeHealthResponder handles the response to the ReportNodeHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportNodeHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportPartitionHealth reports health state of the specified Service Fabric partition. The report must contain the
// information about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway Partition, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, run GetPartitionHealth and check that the report appears
// in the HealthEvents section.
// Parameters:
// partitionID - the identity of the partition.
// healthInformation - describes the health information for the health report. This information needs to be
// present in all of the health reports sent to the health manager.
// immediate - a flag which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store,
// regardless of the fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway
// is closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to
// health store as well as health report processing.
// By default, reports are not sent immediately.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ReportPartitionHealth(ctx context.Context, partitionID uuid.UUID, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ReportPartitionHealth", err.Error())
	}

	req, err := client.ReportPartitionHealthPreparer(ctx, partitionID, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportPartitionHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportPartitionHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportPartitionHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportPartitionHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportPartitionHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportPartitionHealthPreparer prepares the ReportPartitionHealth request.
func (client BaseClient) ReportPartitionHealthPreparer(ctx context.Context, partitionID uuid.UUID, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	} else {
		queryParameters["Immediate"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportPartitionHealthSender sends the ReportPartitionHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportPartitionHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportPartitionHealthResponder handles the response to the ReportPartitionHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportPartitionHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportReplicaHealth reports health state of the specified Service Fabric replica. The report must contain the
// information about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway Replica, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, run GetReplicaHealth and check that the report appears in
// the HealthEvents section.
// Parameters:
// partitionID - the identity of the partition.
// replicaID - the identifier of the replica.
// serviceKind - the kind of service replica (Stateless or Stateful) for which the health is being reported.
// Following are the possible values.
// healthInformation - describes the health information for the health report. This information needs to be
// present in all of the health reports sent to the health manager.
// immediate - a flag which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store,
// regardless of the fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway
// is closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to
// health store as well as health report processing.
// By default, reports are not sent immediately.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ReportReplicaHealth(ctx context.Context, partitionID uuid.UUID, replicaID string, serviceKind ReplicaHealthReportServiceKindRequiredQueryParam, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ReportReplicaHealth", err.Error())
	}

	req, err := client.ReportReplicaHealthPreparer(ctx, partitionID, replicaID, serviceKind, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportReplicaHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportReplicaHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportReplicaHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportReplicaHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportReplicaHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportReplicaHealthPreparer prepares the ReportReplicaHealth request.
func (client BaseClient) ReportReplicaHealthPreparer(ctx context.Context, partitionID uuid.UUID, replicaID string, serviceKind ReplicaHealthReportServiceKindRequiredQueryParam, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"ServiceKind": autorest.Encode("query", serviceKind),
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	} else {
		queryParameters["Immediate"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/GetReplicas/{replicaId}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportReplicaHealthSender sends the ReportReplicaHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportReplicaHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportReplicaHealthResponder handles the response to the ReportReplicaHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportReplicaHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportServiceHealth reports health state of the specified Service Fabric service. The report must contain the
// information about the source of the health report and property on which it is reported.
// The report is sent to a Service Fabric gateway Service, which forwards to the health store.
// The report may be accepted by the gateway, but rejected by the health store after extra validation.
// For example, the health store may reject the report because of an invalid parameter, like a stale sequence number.
// To see whether the report was applied in the health store, run GetServiceHealth and check that the report appears in
// the HealthEvents section.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// healthInformation - describes the health information for the health report. This information needs to be
// present in all of the health reports sent to the health manager.
// immediate - a flag which indicates whether the report should be sent immediately.
// A health report is sent to a Service Fabric gateway Application, which forwards to the health store.
// If Immediate is set to true, the report is sent immediately from Http Gateway to the health store,
// regardless of the fabric client settings that the Http Gateway Application is using.
// This is useful for critical reports that should be sent as soon as possible.
// Depending on timing and other conditions, sending the report may still fail, for example if the Http Gateway
// is closed or the message doesn't reach the Gateway.
// If Immediate is set to false, the report is sent based on the health client settings from the Http Gateway.
// Therefore, it will be batched according to the HealthReportSendInterval configuration.
// This is the recommended setting because it allows the health client to optimize health reporting messages to
// health store as well as health report processing.
// By default, reports are not sent immediately.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ReportServiceHealth(ctx context.Context, serviceID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: healthInformation,
			Constraints: []validation.Constraint{{Target: "healthInformation.SourceID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "healthInformation.Property", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ReportServiceHealth", err.Error())
	}

	req, err := client.ReportServiceHealthPreparer(ctx, serviceID, healthInformation, immediate, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportServiceHealth", nil, "Failure preparing request")
		return
	}

	resp, err := client.ReportServiceHealthSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportServiceHealth", resp, "Failure sending request")
		return
	}

	result, err = client.ReportServiceHealthResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ReportServiceHealth", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportServiceHealthPreparer prepares the ReportServiceHealth request.
func (client BaseClient) ReportServiceHealthPreparer(ctx context.Context, serviceID string, healthInformation HealthInformation, immediate *bool, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if immediate != nil {
		queryParameters["Immediate"] = autorest.Encode("query", *immediate)
	} else {
		queryParameters["Immediate"] = autorest.Encode("query", false)
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/ReportHealth", pathParameters),
		autorest.WithJSON(healthInformation),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportServiceHealthSender sends the ReportServiceHealth request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ReportServiceHealthSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ReportServiceHealthResponder handles the response to the ReportServiceHealth request. The method always
// closes the http.Response Body.
func (client BaseClient) ReportServiceHealthResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResetPartitionLoad resets the current load of a Service Fabric partition to the default load for the service.
// Parameters:
// partitionID - the identity of the partition.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ResetPartitionLoad(ctx context.Context, partitionID uuid.UUID, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ResetPartitionLoad", err.Error())
	}

	req, err := client.ResetPartitionLoadPreparer(ctx, partitionID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResetPartitionLoad", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResetPartitionLoadSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResetPartitionLoad", resp, "Failure sending request")
		return
	}

	result, err = client.ResetPartitionLoadResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResetPartitionLoad", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResetPartitionLoadPreparer prepares the ResetPartitionLoad request.
func (client BaseClient) ResetPartitionLoadPreparer(ctx context.Context, partitionID uuid.UUID, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Partitions/{partitionId}/$/ResetLoad", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResetPartitionLoadSender sends the ResetPartitionLoad request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ResetPartitionLoadSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResetPartitionLoadResponder handles the response to the ResetPartitionLoad request. The method always
// closes the http.Response Body.
func (client BaseClient) ResetPartitionLoadResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResolveService resolve a Service Fabric service partition, to get the endpoints of the service replicas.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// partitionKeyType - key type for the partition. This parameter is required if the partition scheme for the
// service is Int64Range or Named. The possible values are following.
// - None (1) - Indicates that the the PartitionKeyValue parameter is not specified. This is valid for the
// partitions with partitioning scheme as Singleton. This is the default value. The value is 1.
// - Int64Range (2) - Indicates that the the PartitionKeyValue parameter is an int64 partition key. This is
// valid for the partitions with partitioning scheme as Int64Range. The value is 2.
// - Named (3) - Indicates that the the PartitionKeyValue parameter is a name of the partition. This is valid
// for the partitions with partitioning scheme as Named. The value is 3.
// partitionKeyValue - partition key. This is required if the partition scheme for the service is Int64Range or
// Named.
// previousRspVersion - the value in the Version field of the response that was received previously. This is
// required if the user knows that the result that was got previously is stale.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ResolveService(ctx context.Context, serviceID string, partitionKeyType *int32, partitionKeyValue string, previousRspVersion string, timeout *int64) (result ResolvedServicePartition, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ResolveService", err.Error())
	}

	req, err := client.ResolveServicePreparer(ctx, serviceID, partitionKeyType, partitionKeyValue, previousRspVersion, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResolveService", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResolveServiceSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResolveService", resp, "Failure sending request")
		return
	}

	result, err = client.ResolveServiceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResolveService", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResolveServicePreparer prepares the ResolveService request.
func (client BaseClient) ResolveServicePreparer(ctx context.Context, serviceID string, partitionKeyType *int32, partitionKeyValue string, previousRspVersion string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if partitionKeyType != nil {
		queryParameters["PartitionKeyType"] = autorest.Encode("query", *partitionKeyType)
	}
	if len(partitionKeyValue) > 0 {
		queryParameters["PartitionKeyValue"] = partitionKeyValue
	}
	if len(previousRspVersion) > 0 {
		queryParameters["PreviousRspVersion"] = previousRspVersion
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/ResolvePartition", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResolveServiceSender sends the ResolveService request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ResolveServiceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResolveServiceResponder handles the response to the ResolveService request. The method always
// closes the http.Response Body.
func (client BaseClient) ResolveServiceResponder(resp *http.Response) (result ResolvedServicePartition, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartDeployedCodePackage restarts a code package deployed on a Service Fabric node in a cluster. This aborts the
// code package process, which will restart all the user service replicas hosted in that process.
// Parameters:
// nodeName - the name of the node.
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// restartDeployedCodePackageDescription - describes the deployed code package on Service Fabric node to
// restart.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RestartDeployedCodePackage(ctx context.Context, nodeName string, applicationID string, restartDeployedCodePackageDescription RestartDeployedCodePackageDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: restartDeployedCodePackageDescription,
			Constraints: []validation.Constraint{{Target: "restartDeployedCodePackageDescription.ServiceManifestName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "restartDeployedCodePackageDescription.CodePackageName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "restartDeployedCodePackageDescription.CodePackageInstanceID", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RestartDeployedCodePackage", err.Error())
	}

	req, err := client.RestartDeployedCodePackagePreparer(ctx, nodeName, applicationID, restartDeployedCodePackageDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartDeployedCodePackage", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestartDeployedCodePackageSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartDeployedCodePackage", resp, "Failure sending request")
		return
	}

	result, err = client.RestartDeployedCodePackageResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartDeployedCodePackage", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartDeployedCodePackagePreparer prepares the RestartDeployedCodePackage request.
func (client BaseClient) RestartDeployedCodePackagePreparer(ctx context.Context, nodeName string, applicationID string, restartDeployedCodePackageDescription RestartDeployedCodePackageDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
		"nodeName":      autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetApplications/{applicationId}/$/GetCodePackages/$/Restart", pathParameters),
		autorest.WithJSON(restartDeployedCodePackageDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartDeployedCodePackageSender sends the RestartDeployedCodePackage request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RestartDeployedCodePackageSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartDeployedCodePackageResponder handles the response to the RestartDeployedCodePackage request. The method always
// closes the http.Response Body.
func (client BaseClient) RestartDeployedCodePackageResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartNode restarts a Service Fabric cluster node that is already started.
// Parameters:
// nodeName - the name of the node.
// restartNodeDescription - the instance of the node to be restarted and a flag indicating the need to take
// dump of the fabric process.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RestartNode(ctx context.Context, nodeName string, restartNodeDescription RestartNodeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: restartNodeDescription,
			Constraints: []validation.Constraint{{Target: "restartNodeDescription.NodeInstanceID", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RestartNode", err.Error())
	}

	req, err := client.RestartNodePreparer(ctx, nodeName, restartNodeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartNode", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestartNodeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartNode", resp, "Failure sending request")
		return
	}

	result, err = client.RestartNodeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartNode", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartNodePreparer prepares the RestartNode request.
func (client BaseClient) RestartNodePreparer(ctx context.Context, nodeName string, restartNodeDescription RestartNodeDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/Restart", pathParameters),
		autorest.WithJSON(restartNodeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartNodeSender sends the RestartNode request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RestartNodeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartNodeResponder handles the response to the RestartNode request. The method always
// closes the http.Response Body.
func (client BaseClient) RestartNodeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartReplica restarts a service replica of a persisted service running on a node. Warning - There are no safety
// checks performed when this API is used. Incorrect use of this API can lead to availability loss for stateful
// services.
// Parameters:
// nodeName - the name of the node.
// partitionID - the identity of the partition.
// replicaID - the identifier of the replica.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RestartReplica(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RestartReplica", err.Error())
	}

	req, err := client.RestartReplicaPreparer(ctx, nodeName, partitionID, replicaID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartReplica", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestartReplicaSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartReplica", resp, "Failure sending request")
		return
	}

	result, err = client.RestartReplicaResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RestartReplica", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartReplicaPreparer prepares the RestartReplica request.
func (client BaseClient) RestartReplicaPreparer(ctx context.Context, nodeName string, partitionID uuid.UUID, replicaID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName":    autorest.Encode("path", nodeName),
		"partitionId": partitionID,
		"replicaId":   replicaID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Nodes/{nodeName}/$/GetPartitions/{partitionId}/$/GetReplicas/{replicaId}/$/Restart", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartReplicaSender sends the RestartReplica request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RestartReplicaSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RestartReplicaResponder handles the response to the RestartReplica request. The method always
// closes the http.Response Body.
func (client BaseClient) RestartReplicaResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResumeApplicationUpgrade resumes an unmonitored manual Service Fabric application upgrade. Service Fabric upgrades
// one upgrade domain at a time. For unmonitored manual upgrades, after Service Fabric finishes an upgrade domain, it
// waits for you to call this API before proceeding to the next upgrade domain.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// resumeApplicationUpgradeDescription - describes the parameters for resuming an application upgrade.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ResumeApplicationUpgrade(ctx context.Context, applicationID string, resumeApplicationUpgradeDescription ResumeApplicationUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resumeApplicationUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "resumeApplicationUpgradeDescription.UpgradeDomainName", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ResumeApplicationUpgrade", err.Error())
	}

	req, err := client.ResumeApplicationUpgradePreparer(ctx, applicationID, resumeApplicationUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeApplicationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResumeApplicationUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeApplicationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.ResumeApplicationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeApplicationUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResumeApplicationUpgradePreparer prepares the ResumeApplicationUpgrade request.
func (client BaseClient) ResumeApplicationUpgradePreparer(ctx context.Context, applicationID string, resumeApplicationUpgradeDescription ResumeApplicationUpgradeDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/MoveToNextUpgradeDomain", pathParameters),
		autorest.WithJSON(resumeApplicationUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResumeApplicationUpgradeSender sends the ResumeApplicationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ResumeApplicationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResumeApplicationUpgradeResponder handles the response to the ResumeApplicationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) ResumeApplicationUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResumeClusterUpgrade make the cluster code or configuration upgrade move on to the next upgrade domain if
// appropriate.
// Parameters:
// resumeClusterUpgradeDescription - describes the parameters for resuming a cluster upgrade.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) ResumeClusterUpgrade(ctx context.Context, resumeClusterUpgradeDescription ResumeClusterUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resumeClusterUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "resumeClusterUpgradeDescription.UpgradeDomain", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "ResumeClusterUpgrade", err.Error())
	}

	req, err := client.ResumeClusterUpgradePreparer(ctx, resumeClusterUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeClusterUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResumeClusterUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeClusterUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.ResumeClusterUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "ResumeClusterUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResumeClusterUpgradePreparer prepares the ResumeClusterUpgrade request.
func (client BaseClient) ResumeClusterUpgradePreparer(ctx context.Context, resumeClusterUpgradeDescription ResumeClusterUpgradeDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/MoveToNextUpgradeDomain"),
		autorest.WithJSON(resumeClusterUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResumeClusterUpgradeSender sends the ResumeClusterUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) ResumeClusterUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// ResumeClusterUpgradeResponder handles the response to the ResumeClusterUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) ResumeClusterUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RollbackApplicationUpgrade starts rolling back the current application upgrade to the previous version. This API can
// only be used to rollback the current in-progress upgrade that is rolling forward to new version. If the application
// is not currently being upgraded use StartApplicationUpgrade API to upgrade it to desired version including rolling
// back to a previous version.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RollbackApplicationUpgrade(ctx context.Context, applicationID string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RollbackApplicationUpgrade", err.Error())
	}

	req, err := client.RollbackApplicationUpgradePreparer(ctx, applicationID, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackApplicationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.RollbackApplicationUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackApplicationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.RollbackApplicationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackApplicationUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RollbackApplicationUpgradePreparer prepares the RollbackApplicationUpgrade request.
func (client BaseClient) RollbackApplicationUpgradePreparer(ctx context.Context, applicationID string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/RollbackUpgrade", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RollbackApplicationUpgradeSender sends the RollbackApplicationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RollbackApplicationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RollbackApplicationUpgradeResponder handles the response to the RollbackApplicationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) RollbackApplicationUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RollbackClusterUpgrade rollback the code or configuration upgrade of a Service Fabric cluster.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) RollbackClusterUpgrade(ctx context.Context, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "RollbackClusterUpgrade", err.Error())
	}

	req, err := client.RollbackClusterUpgradePreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackClusterUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.RollbackClusterUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackClusterUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.RollbackClusterUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "RollbackClusterUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RollbackClusterUpgradePreparer prepares the RollbackClusterUpgrade request.
func (client BaseClient) RollbackClusterUpgradePreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/RollbackUpgrade"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RollbackClusterUpgradeSender sends the RollbackClusterUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) RollbackClusterUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// RollbackClusterUpgradeResponder handles the response to the RollbackClusterUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) RollbackClusterUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// SetUpgradeOrchestrationServiceState update the service state of Service Fabric Upgrade Orchestration Service. This
// API is internally used for support purposes.
// Parameters:
// upgradeOrchestrationServiceState - service state of Service Fabric Upgrade Orchestration Service.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) SetUpgradeOrchestrationServiceState(ctx context.Context, upgradeOrchestrationServiceState UpgradeOrchestrationServiceState, timeout *int64) (result UpgradeOrchestrationServiceStateSummary, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "SetUpgradeOrchestrationServiceState", err.Error())
	}

	req, err := client.SetUpgradeOrchestrationServiceStatePreparer(ctx, upgradeOrchestrationServiceState, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "SetUpgradeOrchestrationServiceState", nil, "Failure preparing request")
		return
	}

	resp, err := client.SetUpgradeOrchestrationServiceStateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "SetUpgradeOrchestrationServiceState", resp, "Failure sending request")
		return
	}

	result, err = client.SetUpgradeOrchestrationServiceStateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "SetUpgradeOrchestrationServiceState", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// SetUpgradeOrchestrationServiceStatePreparer prepares the SetUpgradeOrchestrationServiceState request.
func (client BaseClient) SetUpgradeOrchestrationServiceStatePreparer(ctx context.Context, upgradeOrchestrationServiceState UpgradeOrchestrationServiceState, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/SetUpgradeOrchestrationServiceState"),
		autorest.WithJSON(upgradeOrchestrationServiceState),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// SetUpgradeOrchestrationServiceStateSender sends the SetUpgradeOrchestrationServiceState request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) SetUpgradeOrchestrationServiceStateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// SetUpgradeOrchestrationServiceStateResponder handles the response to the SetUpgradeOrchestrationServiceState request. The method always
// closes the http.Response Body.
func (client BaseClient) SetUpgradeOrchestrationServiceStateResponder(resp *http.Response) (result UpgradeOrchestrationServiceStateSummary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartApplicationUpgrade validates the supplied application upgrade parameters and starts upgrading the application
// if the parameters are valid.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// applicationUpgradeDescription - parameters for an application upgrade.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) StartApplicationUpgrade(ctx context.Context, applicationID string, applicationUpgradeDescription ApplicationUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: applicationUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "applicationUpgradeDescription.Name", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "applicationUpgradeDescription.TargetApplicationTypeVersion", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "applicationUpgradeDescription.Parameters", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "StartApplicationUpgrade", err.Error())
	}

	req, err := client.StartApplicationUpgradePreparer(ctx, applicationID, applicationUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartApplicationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartApplicationUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartApplicationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.StartApplicationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartApplicationUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartApplicationUpgradePreparer prepares the StartApplicationUpgrade request.
func (client BaseClient) StartApplicationUpgradePreparer(ctx context.Context, applicationID string, applicationUpgradeDescription ApplicationUpgradeDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/Upgrade", pathParameters),
		autorest.WithJSON(applicationUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartApplicationUpgradeSender sends the StartApplicationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartApplicationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartApplicationUpgradeResponder handles the response to the StartApplicationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) StartApplicationUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartChaos if Chaos is not already running in the cluster, it starts Chaos with the passed in Chaos parameters.
// If Chaos is already running when this call is made, the call fails with the error code
// FABRIC_E_CHAOS_ALREADY_RUNNING.
// Please refer to the article [Induce controlled Chaos in Service Fabric
// clusters](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-controlled-chaos) for more details.
// Parameters:
// chaosParameters - describes all the parameters to configure a Chaos run.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) StartChaos(ctx context.Context, chaosParameters ChaosParameters, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: chaosParameters,
			Constraints: []validation.Constraint{{Target: "chaosParameters.MaxClusterStabilizationTimeoutInSeconds", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "chaosParameters.MaxClusterStabilizationTimeoutInSeconds", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "chaosParameters.MaxClusterStabilizationTimeoutInSeconds", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
				}},
				{Target: "chaosParameters.MaxConcurrentFaults", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "chaosParameters.MaxConcurrentFaults", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
						{Target: "chaosParameters.MaxConcurrentFaults", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
					}},
				{Target: "chaosParameters.WaitTimeBetweenFaultsInSeconds", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "chaosParameters.WaitTimeBetweenFaultsInSeconds", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
						{Target: "chaosParameters.WaitTimeBetweenFaultsInSeconds", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
					}},
				{Target: "chaosParameters.WaitTimeBetweenIterationsInSeconds", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "chaosParameters.WaitTimeBetweenIterationsInSeconds", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
						{Target: "chaosParameters.WaitTimeBetweenIterationsInSeconds", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
					}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "StartChaos", err.Error())
	}

	req, err := client.StartChaosPreparer(ctx, chaosParameters, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartChaos", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartChaosSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartChaos", resp, "Failure sending request")
		return
	}

	result, err = client.StartChaosResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartChaos", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartChaosPreparer prepares the StartChaos request.
func (client BaseClient) StartChaosPreparer(ctx context.Context, chaosParameters ChaosParameters, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Tools/Chaos/$/Start"),
		autorest.WithJSON(chaosParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartChaosSender sends the StartChaos request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartChaosSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartChaosResponder handles the response to the StartChaos request. The method always
// closes the http.Response Body.
func (client BaseClient) StartChaosResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartClusterConfigurationUpgrade validate the supplied configuration upgrade parameters and start upgrading the
// cluster configuration if the parameters are valid.
// Parameters:
// clusterConfigurationUpgradeDescription - parameters for a standalone cluster configuration upgrade.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) StartClusterConfigurationUpgrade(ctx context.Context, clusterConfigurationUpgradeDescription ClusterConfigurationUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: clusterConfigurationUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "clusterConfigurationUpgradeDescription.ClusterConfig", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "StartClusterConfigurationUpgrade", err.Error())
	}

	req, err := client.StartClusterConfigurationUpgradePreparer(ctx, clusterConfigurationUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterConfigurationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartClusterConfigurationUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterConfigurationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.StartClusterConfigurationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterConfigurationUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartClusterConfigurationUpgradePreparer prepares the StartClusterConfigurationUpgrade request.
func (client BaseClient) StartClusterConfigurationUpgradePreparer(ctx context.Context, clusterConfigurationUpgradeDescription ClusterConfigurationUpgradeDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/StartClusterConfigurationUpgrade"),
		autorest.WithJSON(clusterConfigurationUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartClusterConfigurationUpgradeSender sends the StartClusterConfigurationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartClusterConfigurationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartClusterConfigurationUpgradeResponder handles the response to the StartClusterConfigurationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) StartClusterConfigurationUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartClusterUpgrade validate the supplied upgrade parameters and start upgrading the code or configuration version
// of a Service Fabric cluster if the parameters are valid.
// Parameters:
// startClusterUpgradeDescription - describes the parameters for starting a cluster upgrade.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) StartClusterUpgrade(ctx context.Context, startClusterUpgradeDescription StartClusterUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: startClusterUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
						{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
					}},
					{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
							{Target: "startClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
						}},
				}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "StartClusterUpgrade", err.Error())
	}

	req, err := client.StartClusterUpgradePreparer(ctx, startClusterUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartClusterUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.StartClusterUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartClusterUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartClusterUpgradePreparer prepares the StartClusterUpgrade request.
func (client BaseClient) StartClusterUpgradePreparer(ctx context.Context, startClusterUpgradeDescription StartClusterUpgradeDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/Upgrade"),
		autorest.WithJSON(startClusterUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartClusterUpgradeSender sends the StartClusterUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartClusterUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartClusterUpgradeResponder handles the response to the StartClusterUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) StartClusterUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartComposeDeploymentUpgrade validates the supplied upgrade parameters and starts upgrading the deployment if the
// parameters are valid.
// Parameters:
// deploymentName - the identity of the deployment.
// composeDeploymentUpgradeDescription - parameters for upgrading compose deployment.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) StartComposeDeploymentUpgrade(ctx context.Context, deploymentName string, composeDeploymentUpgradeDescription ComposeDeploymentUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: composeDeploymentUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "composeDeploymentUpgradeDescription.DeploymentName", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "composeDeploymentUpgradeDescription.ComposeFileContent", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "StartComposeDeploymentUpgrade", err.Error())
	}

	req, err := client.StartComposeDeploymentUpgradePreparer(ctx, deploymentName, composeDeploymentUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartComposeDeploymentUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartComposeDeploymentUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartComposeDeploymentUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.StartComposeDeploymentUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartComposeDeploymentUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartComposeDeploymentUpgradePreparer prepares the StartComposeDeploymentUpgrade request.
func (client BaseClient) StartComposeDeploymentUpgradePreparer(ctx context.Context, deploymentName string, composeDeploymentUpgradeDescription ComposeDeploymentUpgradeDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"deploymentName": deploymentName,
	}

	const APIVersion = "6.0-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ComposeDeployments/{deploymentName}/$/Upgrade", pathParameters),
		autorest.WithJSON(composeDeploymentUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartComposeDeploymentUpgradeSender sends the StartComposeDeploymentUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartComposeDeploymentUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartComposeDeploymentUpgradeResponder handles the response to the StartComposeDeploymentUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) StartComposeDeploymentUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartDataLoss this API will induce data loss for the specified partition. It will trigger a call to the OnDataLoss
// API of the partition.
// Actual data loss will depend on the specified DataLossMode
// PartialDataLoss - Only a quorum of replicas are removed and OnDataLoss is triggered for the partition but actual
// data loss depends on the presence of in-flight replication.
// FullDataLoss - All replicas are removed hence all data is lost and OnDataLoss is triggered.
//
// This API should only be called with a stateful service as the target.
//
// Calling this API with a system service as the target is not advised.
//
// Note:  Once this API has been called, it cannot be reversed. Calling CancelOperation will only stop execution and
// clean up internal system state.
// It will not restore data if the command has progressed far enough to cause data loss.
//
// Call the GetDataLossProgress API with the same OperationId to return information on the operation started with this
// API.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// partitionID - the identity of the partition.
// operationID - a GUID that identifies a call of this API.  This is passed into the corresponding GetProgress
// API
// dataLossMode - this enum is passed to the StartDataLoss API to indicate what type of data loss to induce.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) StartDataLoss(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, dataLossMode DataLossModeRequiredQueryParam, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "StartDataLoss", err.Error())
	}

	req, err := client.StartDataLossPreparer(ctx, serviceID, partitionID, operationID, dataLossMode, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartDataLoss", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartDataLossSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartDataLoss", resp, "Failure sending request")
		return
	}

	result, err = client.StartDataLossResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartDataLoss", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartDataLossPreparer prepares the StartDataLoss request.
func (client BaseClient) StartDataLossPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, dataLossMode DataLossModeRequiredQueryParam, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":  APIVersion,
		"DataLossMode": autorest.Encode("query", dataLossMode),
		"OperationId":  autorest.Encode("query", operationID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartDataLoss", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartDataLossSender sends the StartDataLoss request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartDataLossSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartDataLossResponder handles the response to the StartDataLoss request. The method always
// closes the http.Response Body.
func (client BaseClient) StartDataLossResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartNodeTransition starts or stops a cluster node.  A cluster node is a process, not the OS instance itself.  To
// start a node, pass in "Start" for the NodeTransitionType parameter.
// To stop a node, pass in "Stop" for the NodeTransitionType parameter.  This API starts the operation - when the API
// returns the node may not have finished transitioning yet.
// Call GetNodeTransitionProgress with the same OperationId to get the progress of the operation.
// Parameters:
// nodeName - the name of the node.
// operationID - a GUID that identifies a call of this API.  This is passed into the corresponding GetProgress
// API
// nodeTransitionType - indicates the type of transition to perform.  NodeTransitionType.Start will start a
// stopped node.  NodeTransitionType.Stop will stop a node that is up.
// nodeInstanceID - the node instance ID of the target node.  This can be determined through GetNodeInfo API.
// stopDurationInSeconds - the duration, in seconds, to keep the node stopped.  The minimum value is 600, the
// maximum is 14400.  After this time expires, the node will automatically come back up.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) StartNodeTransition(ctx context.Context, nodeName string, operationID uuid.UUID, nodeTransitionType NodeTransitionTypeRequiredQueryParam, nodeInstanceID string, stopDurationInSeconds int32, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: stopDurationInSeconds,
			Constraints: []validation.Constraint{{Target: "stopDurationInSeconds", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "StartNodeTransition", err.Error())
	}

	req, err := client.StartNodeTransitionPreparer(ctx, nodeName, operationID, nodeTransitionType, nodeInstanceID, stopDurationInSeconds, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartNodeTransition", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartNodeTransitionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartNodeTransition", resp, "Failure sending request")
		return
	}

	result, err = client.StartNodeTransitionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartNodeTransition", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartNodeTransitionPreparer prepares the StartNodeTransition request.
func (client BaseClient) StartNodeTransitionPreparer(ctx context.Context, nodeName string, operationID uuid.UUID, nodeTransitionType NodeTransitionTypeRequiredQueryParam, nodeInstanceID string, stopDurationInSeconds int32, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nodeName": autorest.Encode("path", nodeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":           APIVersion,
		"NodeInstanceId":        autorest.Encode("query", nodeInstanceID),
		"NodeTransitionType":    autorest.Encode("query", nodeTransitionType),
		"OperationId":           autorest.Encode("query", operationID),
		"StopDurationInSeconds": autorest.Encode("query", stopDurationInSeconds),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Nodes/{nodeName}/$/StartTransition/", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartNodeTransitionSender sends the StartNodeTransition request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartNodeTransitionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartNodeTransitionResponder handles the response to the StartNodeTransition request. The method always
// closes the http.Response Body.
func (client BaseClient) StartNodeTransitionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartPartitionRestart this API is useful for testing failover.
//
// If used to target a stateless service partition, RestartPartitionMode must be AllReplicasOrInstances.
//
// Call the GetPartitionRestartProgress API using the same OperationId to get the progress.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// partitionID - the identity of the partition.
// operationID - a GUID that identifies a call of this API.  This is passed into the corresponding GetProgress
// API
// restartPartitionMode - describe which partitions to restart.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) StartPartitionRestart(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, restartPartitionMode RestartPartitionModeRequiredQueryParam, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "StartPartitionRestart", err.Error())
	}

	req, err := client.StartPartitionRestartPreparer(ctx, serviceID, partitionID, operationID, restartPartitionMode, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartPartitionRestart", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartPartitionRestartSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartPartitionRestart", resp, "Failure sending request")
		return
	}

	result, err = client.StartPartitionRestartResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartPartitionRestart", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartPartitionRestartPreparer prepares the StartPartitionRestart request.
func (client BaseClient) StartPartitionRestartPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, restartPartitionMode RestartPartitionModeRequiredQueryParam, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":          APIVersion,
		"OperationId":          autorest.Encode("query", operationID),
		"RestartPartitionMode": autorest.Encode("query", restartPartitionMode),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartRestart", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartPartitionRestartSender sends the StartPartitionRestart request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartPartitionRestartSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartPartitionRestartResponder handles the response to the StartPartitionRestart request. The method always
// closes the http.Response Body.
func (client BaseClient) StartPartitionRestartResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartQuorumLoss induces quorum loss for a given stateful service partition.  This API is useful for a temporary
// quorum loss situation on your service.
//
// Call the GetQuorumLossProgress API with the same OperationId to return information on the operation started with
// this API.
//
// This can only be called on stateful persisted (HasPersistedState==true) services.  Do not use this API on stateless
// services or stateful in-memory only services.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// partitionID - the identity of the partition.
// operationID - a GUID that identifies a call of this API.  This is passed into the corresponding GetProgress
// API
// quorumLossMode - this enum is passed to the StartQuorumLoss API to indicate what type of quorum loss to
// induce.
// quorumLossDuration - the amount of time for which the partition will be kept in quorum loss.  This must be
// specified in seconds.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) StartQuorumLoss(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, quorumLossMode QuorumLossModeRequiredQueryParam, quorumLossDuration int32, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "StartQuorumLoss", err.Error())
	}

	req, err := client.StartQuorumLossPreparer(ctx, serviceID, partitionID, operationID, quorumLossMode, quorumLossDuration, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartQuorumLoss", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartQuorumLossSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartQuorumLoss", resp, "Failure sending request")
		return
	}

	result, err = client.StartQuorumLossResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StartQuorumLoss", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartQuorumLossPreparer prepares the StartQuorumLoss request.
func (client BaseClient) StartQuorumLossPreparer(ctx context.Context, serviceID string, partitionID uuid.UUID, operationID uuid.UUID, quorumLossMode QuorumLossModeRequiredQueryParam, quorumLossDuration int32, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"partitionId": partitionID,
		"serviceId":   serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version":        APIVersion,
		"OperationId":        autorest.Encode("query", operationID),
		"QuorumLossDuration": autorest.Encode("query", quorumLossDuration),
		"QuorumLossMode":     autorest.Encode("query", quorumLossMode),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Faults/Services/{serviceId}/$/GetPartitions/{partitionId}/$/StartQuorumLoss", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartQuorumLossSender sends the StartQuorumLoss request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StartQuorumLossSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StartQuorumLossResponder handles the response to the StartQuorumLoss request. The method always
// closes the http.Response Body.
func (client BaseClient) StartQuorumLossResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StopChaos stops Chaos from scheduling further faults; but, the in-flight faults are not affected.
// Parameters:
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) StopChaos(ctx context.Context, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "StopChaos", err.Error())
	}

	req, err := client.StopChaosPreparer(ctx, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StopChaos", nil, "Failure preparing request")
		return
	}

	resp, err := client.StopChaosSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StopChaos", resp, "Failure sending request")
		return
	}

	result, err = client.StopChaosResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "StopChaos", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StopChaosPreparer prepares the StopChaos request.
func (client BaseClient) StopChaosPreparer(ctx context.Context, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/Tools/Chaos/$/Stop"),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StopChaosSender sends the StopChaos request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) StopChaosSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// StopChaosResponder handles the response to the StopChaos request. The method always
// closes the http.Response Body.
func (client BaseClient) StopChaosResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// SubmitPropertyBatch submits a batch of property operations. Either all or none of the operations will be committed.
// Parameters:
// nameID - the Service Fabric name, without the 'fabric:' URI scheme.
// propertyBatchDescriptionList - describes the property batch operations to be submitted.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) SubmitPropertyBatch(ctx context.Context, nameID string, propertyBatchDescriptionList PropertyBatchDescriptionList, timeout *int64) (result PropertyBatchInfoModel, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "SubmitPropertyBatch", err.Error())
	}

	req, err := client.SubmitPropertyBatchPreparer(ctx, nameID, propertyBatchDescriptionList, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "SubmitPropertyBatch", nil, "Failure preparing request")
		return
	}

	resp, err := client.SubmitPropertyBatchSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "SubmitPropertyBatch", resp, "Failure sending request")
		return
	}

	result, err = client.SubmitPropertyBatchResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "SubmitPropertyBatch", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// SubmitPropertyBatchPreparer prepares the SubmitPropertyBatch request.
func (client BaseClient) SubmitPropertyBatchPreparer(ctx context.Context, nameID string, propertyBatchDescriptionList PropertyBatchDescriptionList, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"nameId": nameID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Names/{nameId}/$/GetProperties/$/SubmitBatch", pathParameters),
		autorest.WithJSON(propertyBatchDescriptionList),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// SubmitPropertyBatchSender sends the SubmitPropertyBatch request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) SubmitPropertyBatchSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// SubmitPropertyBatchResponder handles the response to the SubmitPropertyBatch request. The method always
// closes the http.Response Body.
func (client BaseClient) SubmitPropertyBatchResponder(resp *http.Response) (result PropertyBatchInfoModel, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusConflict),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UnprovisionApplicationType removes or unregisters a Service Fabric application type from the cluster. This operation
// can only be performed if all application instances of the application type has been deleted. Once the application
// type is unregistered, no new application instances can be created for this particular application type.
// Parameters:
// applicationTypeName - the name of the application type.
// unprovisionApplicationTypeDescriptionInfo - the relative path for the application package in the image store
// specified during the prior copy operation.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) UnprovisionApplicationType(ctx context.Context, applicationTypeName string, unprovisionApplicationTypeDescriptionInfo UnprovisionApplicationTypeDescriptionInfo, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: unprovisionApplicationTypeDescriptionInfo,
			Constraints: []validation.Constraint{{Target: "unprovisionApplicationTypeDescriptionInfo.ApplicationTypeVersion", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "UnprovisionApplicationType", err.Error())
	}

	req, err := client.UnprovisionApplicationTypePreparer(ctx, applicationTypeName, unprovisionApplicationTypeDescriptionInfo, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionApplicationType", nil, "Failure preparing request")
		return
	}

	resp, err := client.UnprovisionApplicationTypeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionApplicationType", resp, "Failure sending request")
		return
	}

	result, err = client.UnprovisionApplicationTypeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionApplicationType", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UnprovisionApplicationTypePreparer prepares the UnprovisionApplicationType request.
func (client BaseClient) UnprovisionApplicationTypePreparer(ctx context.Context, applicationTypeName string, unprovisionApplicationTypeDescriptionInfo UnprovisionApplicationTypeDescriptionInfo, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationTypeName": autorest.Encode("path", applicationTypeName),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ApplicationTypes/{applicationTypeName}/$/Unprovision", pathParameters),
		autorest.WithJSON(unprovisionApplicationTypeDescriptionInfo),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UnprovisionApplicationTypeSender sends the UnprovisionApplicationType request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UnprovisionApplicationTypeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UnprovisionApplicationTypeResponder handles the response to the UnprovisionApplicationType request. The method always
// closes the http.Response Body.
func (client BaseClient) UnprovisionApplicationTypeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UnprovisionCluster unprovision the code or configuration packages of a Service Fabric cluster. It is supported to
// unprovision code and configuration separately.
// Parameters:
// unprovisionFabricDescription - describes the parameters for unprovisioning a cluster.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) UnprovisionCluster(ctx context.Context, unprovisionFabricDescription UnprovisionFabricDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "UnprovisionCluster", err.Error())
	}

	req, err := client.UnprovisionClusterPreparer(ctx, unprovisionFabricDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionCluster", nil, "Failure preparing request")
		return
	}

	resp, err := client.UnprovisionClusterSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionCluster", resp, "Failure sending request")
		return
	}

	result, err = client.UnprovisionClusterResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UnprovisionCluster", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UnprovisionClusterPreparer prepares the UnprovisionCluster request.
func (client BaseClient) UnprovisionClusterPreparer(ctx context.Context, unprovisionFabricDescription UnprovisionFabricDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/Unprovision"),
		autorest.WithJSON(unprovisionFabricDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UnprovisionClusterSender sends the UnprovisionCluster request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UnprovisionClusterSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UnprovisionClusterResponder handles the response to the UnprovisionCluster request. The method always
// closes the http.Response Body.
func (client BaseClient) UnprovisionClusterResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateApplicationUpgrade updates the parameters of an ongoing application upgrade from the ones specified at the
// time of starting the application upgrade. This may be required to mitigate stuck application upgrades due to
// incorrect parameters or issues in the application to make progress.
// Parameters:
// applicationID - the identity of the application. This is typically the full name of the application without
// the 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the application name is "fabric:/myapp/app1", the application identity would be "myapp~app1"
// in 6.0+ and "myapp/app1" in previous versions.
// applicationUpgradeUpdateDescription - parameters for updating an existing application upgrade.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) UpdateApplicationUpgrade(ctx context.Context, applicationID string, applicationUpgradeUpdateDescription ApplicationUpgradeUpdateDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: applicationUpgradeUpdateDescription,
			Constraints: []validation.Constraint{{Target: "applicationUpgradeUpdateDescription.Name", Name: validation.Null, Rule: true, Chain: nil}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "UpdateApplicationUpgrade", err.Error())
	}

	req, err := client.UpdateApplicationUpgradePreparer(ctx, applicationID, applicationUpgradeUpdateDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateApplicationUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateApplicationUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateApplicationUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateApplicationUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateApplicationUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateApplicationUpgradePreparer prepares the UpdateApplicationUpgrade request.
func (client BaseClient) UpdateApplicationUpgradePreparer(ctx context.Context, applicationID string, applicationUpgradeUpdateDescription ApplicationUpgradeUpdateDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"applicationId": applicationID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Applications/{applicationId}/$/UpdateUpgrade", pathParameters),
		autorest.WithJSON(applicationUpgradeUpdateDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateApplicationUpgradeSender sends the UpdateApplicationUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateApplicationUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateApplicationUpgradeResponder handles the response to the UpdateApplicationUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateApplicationUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateClusterUpgrade update the upgrade parameters used during a Service Fabric cluster upgrade.
// Parameters:
// updateClusterUpgradeDescription - parameters for updating a cluster upgrade.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) UpdateClusterUpgrade(ctx context.Context, updateClusterUpgradeDescription UpdateClusterUpgradeDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: updateClusterUpgradeDescription,
			Constraints: []validation.Constraint{{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
						{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentDeltaUnhealthyNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
					}},
					{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
							{Target: "updateClusterUpgradeDescription.ClusterUpgradeHealthPolicy.MaxPercentUpgradeDomainDeltaUnhealthyNodes", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
						}},
				}}}},
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "UpdateClusterUpgrade", err.Error())
	}

	req, err := client.UpdateClusterUpgradePreparer(ctx, updateClusterUpgradeDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateClusterUpgrade", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateClusterUpgradeSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateClusterUpgrade", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateClusterUpgradeResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateClusterUpgrade", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateClusterUpgradePreparer prepares the UpdateClusterUpgrade request.
func (client BaseClient) UpdateClusterUpgradePreparer(ctx context.Context, updateClusterUpgradeDescription UpdateClusterUpgradeDescription, timeout *int64) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/UpdateUpgrade"),
		autorest.WithJSON(updateClusterUpgradeDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateClusterUpgradeSender sends the UpdateClusterUpgrade request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateClusterUpgradeSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateClusterUpgradeResponder handles the response to the UpdateClusterUpgrade request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateClusterUpgradeResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateRepairExecutionState this API supports the Service Fabric platform; it is not meant to be used directly from
// your code.
// Parameters:
// repairTask - describes the repair task to be created or updated.
func (client BaseClient) UpdateRepairExecutionState(ctx context.Context, repairTask RepairTask) (result RepairTaskUpdateInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTask,
			Constraints: []validation.Constraint{{Target: "repairTask.TaskID", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "repairTask.Action", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "UpdateRepairExecutionState", err.Error())
	}

	req, err := client.UpdateRepairExecutionStatePreparer(ctx, repairTask)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairExecutionState", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateRepairExecutionStateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairExecutionState", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateRepairExecutionStateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairExecutionState", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateRepairExecutionStatePreparer prepares the UpdateRepairExecutionState request.
func (client BaseClient) UpdateRepairExecutionStatePreparer(ctx context.Context, repairTask RepairTask) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/UpdateRepairExecutionState"),
		autorest.WithJSON(repairTask),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateRepairExecutionStateSender sends the UpdateRepairExecutionState request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateRepairExecutionStateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateRepairExecutionStateResponder handles the response to the UpdateRepairExecutionState request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateRepairExecutionStateResponder(resp *http.Response) (result RepairTaskUpdateInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateRepairTaskHealthPolicy this API supports the Service Fabric platform; it is not meant to be used directly from
// your code.
// Parameters:
// repairTaskUpdateHealthPolicyDescription - describes the repair task healthy policy to be updated.
func (client BaseClient) UpdateRepairTaskHealthPolicy(ctx context.Context, repairTaskUpdateHealthPolicyDescription RepairTaskUpdateHealthPolicyDescription) (result RepairTaskUpdateInfo, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: repairTaskUpdateHealthPolicyDescription,
			Constraints: []validation.Constraint{{Target: "repairTaskUpdateHealthPolicyDescription.TaskID", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "UpdateRepairTaskHealthPolicy", err.Error())
	}

	req, err := client.UpdateRepairTaskHealthPolicyPreparer(ctx, repairTaskUpdateHealthPolicyDescription)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairTaskHealthPolicy", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateRepairTaskHealthPolicySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairTaskHealthPolicy", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateRepairTaskHealthPolicyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateRepairTaskHealthPolicy", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateRepairTaskHealthPolicyPreparer prepares the UpdateRepairTaskHealthPolicy request.
func (client BaseClient) UpdateRepairTaskHealthPolicyPreparer(ctx context.Context, repairTaskUpdateHealthPolicyDescription RepairTaskUpdateHealthPolicyDescription) (*http.Request, error) {
	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/$/UpdateRepairTaskHealthPolicy"),
		autorest.WithJSON(repairTaskUpdateHealthPolicyDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateRepairTaskHealthPolicySender sends the UpdateRepairTaskHealthPolicy request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateRepairTaskHealthPolicySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateRepairTaskHealthPolicyResponder handles the response to the UpdateRepairTaskHealthPolicy request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateRepairTaskHealthPolicyResponder(resp *http.Response) (result RepairTaskUpdateInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateService this API allows updating properties of a running Service Fabric service. The set of properties that
// can be updated are a subset of the properties that were specified at the time of creating the service. The current
// set of properties can be obtained using `GetServiceDescription` API. Please note that updating the properties of a
// running service is different than upgrading your application using `StartApplicationUpgrade` API. The upgrade is a
// long running background operation that involves moving the application from one version to another, one upgrade
// domain at a time, whereas update applies the new properties immediately to the service.
// Parameters:
// serviceID - the identity of the service. This is typically the full name of the service without the
// 'fabric:' URI scheme.
// Starting from version 6.0, hierarchical names are delimited with the "~" character.
// For example, if the service name is "fabric:/myapp/app1/svc1", the service identity would be
// "myapp~app1~svc1" in 6.0+ and "myapp/app1/svc1" in previous versions.
// serviceUpdateDescription - the information necessary to update a service.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) UpdateService(ctx context.Context, serviceID string, serviceUpdateDescription BasicServiceUpdateDescription, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "UpdateService", err.Error())
	}

	req, err := client.UpdateServicePreparer(ctx, serviceID, serviceUpdateDescription, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateService", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateServiceSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateService", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateServiceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UpdateService", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateServicePreparer prepares the UpdateService request.
func (client BaseClient) UpdateServicePreparer(ctx context.Context, serviceID string, serviceUpdateDescription BasicServiceUpdateDescription, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"serviceId": serviceID,
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/Services/{serviceId}/$/Update", pathParameters),
		autorest.WithJSON(serviceUpdateDescription),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateServiceSender sends the UpdateService request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateServiceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UpdateServiceResponder handles the response to the UpdateService request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateServiceResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UploadFile uploads contents of the file to the image store. Use this API if the file is small enough to upload again
// if the connection fails. The file's data needs to be added to the request body. The contents will be uploaded to the
// specified path. Image store service uses a mark file to indicate the availability of the folder. The mark file is an
// empty file named "_.dir". The mark file is generated by the image store service when all files in a folder are
// uploaded. When using File-by-File approach to upload application package in REST, the image store service isn't
// aware of the file hierarchy of the application package; you need to create a mark file per folder and upload it
// last, to let the image store service know that the folder is complete.
// Parameters:
// contentPath - relative path to file or folder in the image store from its root.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) UploadFile(ctx context.Context, contentPath string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "UploadFile", err.Error())
	}

	req, err := client.UploadFilePreparer(ctx, contentPath, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UploadFile", nil, "Failure preparing request")
		return
	}

	resp, err := client.UploadFileSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UploadFile", resp, "Failure sending request")
		return
	}

	result, err = client.UploadFileResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UploadFile", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UploadFilePreparer prepares the UploadFile request.
func (client BaseClient) UploadFilePreparer(ctx context.Context, contentPath string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"contentPath": autorest.Encode("path", contentPath),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ImageStore/{contentPath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UploadFileSender sends the UploadFile request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UploadFileSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UploadFileResponder handles the response to the UploadFile request. The method always
// closes the http.Response Body.
func (client BaseClient) UploadFileResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UploadFileChunk uploads a file chunk to the image store with the specified upload session ID and image store
// relative path. This API allows user to resume the file upload operation. user doesn't have to restart the file
// upload from scratch whenever there is a network interruption. Use this option if the file size is large.
//
// To perform a resumable file upload, user need to break the file into multiple chunks and upload these chunks to the
// image store one-by-one. Chunks don't have to be uploaded in order. If the file represented by the image store
// relative path already exists, it will be overwritten when the upload session commits.
// Parameters:
// contentPath - relative path to file or folder in the image store from its root.
// sessionID - a GUID generated by the user for a file uploading. It identifies an image store upload session
// which keeps track of all file chunks until it is committed.
// contentRange - when uploading file chunks to the image store, the Content-Range header field need to be
// configured and sent with a request. The format should looks like "bytes
// {First-Byte-Position}-{Last-Byte-Position}/{File-Length}". For example, Content-Range:bytes 300-5000/20000
// indicates that user is sending bytes 300 through 5,000 and the total file length is 20,000 bytes.
// timeout - the server timeout for performing the operation in seconds. This specifies the time duration that
// the client is willing to wait for the requested operation to complete. The default value for this parameter
// is 60 seconds.
func (client BaseClient) UploadFileChunk(ctx context.Context, contentPath string, sessionID uuid.UUID, contentRange string, timeout *int64) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: timeout,
			Constraints: []validation.Constraint{{Target: "timeout", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "timeout", Name: validation.InclusiveMaximum, Rule: int64(4294967295), Chain: nil},
					{Target: "timeout", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("servicefabric.BaseClient", "UploadFileChunk", err.Error())
	}

	req, err := client.UploadFileChunkPreparer(ctx, contentPath, sessionID, contentRange, timeout)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UploadFileChunk", nil, "Failure preparing request")
		return
	}

	resp, err := client.UploadFileChunkSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UploadFileChunk", resp, "Failure sending request")
		return
	}

	result, err = client.UploadFileChunkResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "servicefabric.BaseClient", "UploadFileChunk", resp, "Failure responding to request")
	}

	return
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UploadFileChunkPreparer prepares the UploadFileChunk request.
func (client BaseClient) UploadFileChunkPreparer(ctx context.Context, contentPath string, sessionID uuid.UUID, contentRange string, timeout *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"contentPath": autorest.Encode("path", contentPath),
	}

	const APIVersion = "6.0"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
		"session-id":  autorest.Encode("query", sessionID),
	}
	if timeout != nil {
		queryParameters["timeout"] = autorest.Encode("query", *timeout)
	} else {
		queryParameters["timeout"] = autorest.Encode("query", 60)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/ImageStore/{contentPath}/$/UploadChunk", pathParameters),
		autorest.WithQueryParameters(queryParameters),
		autorest.WithHeader("Content-Range", autorest.String(contentRange)))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UploadFileChunkSender sends the UploadFileChunk request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UploadFileChunkSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// Deprecated: Please use package github.com/Azure/azure-sdk-for-go/services/servicefabric/6.2/servicefabric instead
// UploadFileChunkResponder handles the response to the UploadFileChunk request. The method always
// closes the http.Response Body.
func (client BaseClient) UploadFileChunkResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}
