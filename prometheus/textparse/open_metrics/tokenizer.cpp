/* Generated by re2c */
#include "tokenizer.h"

#include <cstring>

// NOLINTBEGIN
enum YYCONDTYPE {
  yycinit,
  yyccomment,
  yycmeta_name,
  yycmeta_text_with_leading_spaces,
  yycexemplar_labels,
  yyclabels,
  yyclabel_value,
  yycexemplar_label_value,
  yycvalue,
  yyctimestamp,
  yycexemplar_value,
  yycexemplar_timestamp,
};

// NOLINTEND

namespace PromPP::Prometheus::textparse::OpenMetrics {

Tokenizer::Tokenizer() : condition_{yycinit} {}

Tokenizer::Tokenizer(std::string_view str)
    : start_ptr_(str.data()),
      cursor_ptr_(start_ptr_),
      limit_ptr_(start_ptr_ + str.size()),
      marker_ptr_(start_ptr_),
      token_ptr_(start_ptr_),
      condition_{yycinit} {}

void Tokenizer::tokenize(std::string_view str) noexcept {
  start_ptr_ = str.data();
  cursor_ptr_ = start_ptr_;
  limit_ptr_ = start_ptr_ + str.size();
  marker_ptr_ = start_ptr_;
  token_ptr_ = start_ptr_;

  condition_ = yycinit;
}

Token Tokenizer::consume_comment(Token token) noexcept {
  if (cursor_ptr_ = static_cast<const char*>(std::memchr(cursor_ptr_, '\n', limit_ptr_ - cursor_ptr_)); cursor_ptr_ != nullptr) [[likely]] {
    condition_ = yycinit;
    return token;
  }

  cursor_ptr_ = limit_ptr_;
  return Token::kInvalid;
}

Token Tokenizer::consume_escaped_string(Token token) noexcept {
  while (true) {
    if (cursor_ptr_ = static_cast<const char*>(std::memchr(cursor_ptr_, '"', limit_ptr_ - cursor_ptr_)); cursor_ptr_ == nullptr) [[unlikely]] {
      cursor_ptr_ = limit_ptr_;
      return Token::kInvalid;
    }

    if (cursor_ptr_[-1] == '\\') [[unlikely]] {
      ++cursor_ptr_;
      continue;
    }

    break;
  }

  ++cursor_ptr_;
  return token;
}

// NOLINTBEGIN
Token Tokenizer::next_impl() noexcept {
  token_ptr_ = cursor_ptr_;

  {
    unsigned char yych;
    unsigned int yyaccept = 0;
    if (condition_ < 6) {
      if (condition_ < 3) {
        if (condition_ < 1) {
          goto yyc_init;
        } else {
          if (condition_ < 2) {
            goto yyc_comment;
          } else {
            goto yyc_meta_name;
          }
        }
      } else {
        if (condition_ < 4) {
          goto yyc_meta_text_with_leading_spaces;
        } else {
          if (condition_ < 5) {
            goto yyc_exemplar_labels;
          } else {
            goto yyc_labels;
          }
        }
      }
    } else {
      if (condition_ < 9) {
        if (condition_ < 7) {
          goto yyc_label_value;
        } else {
          if (condition_ < 8) {
            goto yyc_exemplar_label_value;
          } else {
            goto yyc_value;
          }
        }
      } else {
        if (condition_ < 10) {
          goto yyc_timestamp;
        } else {
          if (condition_ < 11) {
            goto yyc_exemplar_value;
          } else {
            goto yyc_exemplar_timestamp;
          }
        }
      }
    }
  /* *********************************** */
  yyc_init: {
    static const unsigned char yybm[] = {
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  128, 0,  0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 0, 0,  0,  0,  0,  0,  64, 64, 64, 64, 64,  64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 0,  0,  0,  0,  64, 0, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,  0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,
    };
    if ((limit_ptr_ - cursor_ptr_) < 2) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *(marker_ptr_ = cursor_ptr_);
    if (yych <= ':') {
      if (yych <= '\n') {
        if (yych <= 0x00)
          goto yy2;
        if (yych >= '\n')
          goto yy3;
      } else {
        if (yych == '#')
          goto yy4;
        if (yych >= ':')
          goto yy5;
      }
    } else {
      if (yych <= '_') {
        if (yych <= '@')
          goto yy1;
        if (yych <= 'Z')
          goto yy5;
        if (yych >= '_')
          goto yy5;
      } else {
        if (yych <= '`')
          goto yy1;
        if (yych <= 'z')
          goto yy5;
        if (yych <= '{')
          goto yy6;
      }
    }
  yy1: { return Token::kInvalid; }
  yy2:
    ++cursor_ptr_;
    {
      return Token::kEOF;
    }
  yy3:
    ++cursor_ptr_;
    {
      return Token::kLinebreak;
    }
  yy4:
    yych = *++cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy7;
    }
    cursor_ptr_ = marker_ptr_;
    goto yy1;
  yy5:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy5;
    }
    condition_ = yycvalue;
    {
      return Token::kMetricName;
    }
  yy6:
    ++cursor_ptr_;
    condition_ = yyclabels;
    {
      return Token::kBraceOpen;
    }
  yy7:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy7;
    }
    condition_ = yyccomment;
    {
      token_ptr_ = cursor_ptr_;
    }
  }
  /* *********************************** */
  yyc_comment: {
    static const unsigned char yybm[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
    };
    if ((limit_ptr_ - cursor_ptr_) < 5) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *(marker_ptr_ = cursor_ptr_);
    if (yych <= 'H') {
      if (yych == 'E')
        goto yy10;
      if (yych >= 'H')
        goto yy12;
    } else {
      if (yych <= 'S')
        goto yy9;
      if (yych <= 'T')
        goto yy13;
      if (yych <= 'U')
        goto yy14;
    }
  yy9:
    condition_ = yycinit;
    {
      return Token::kInvalid;
    }
  yy10:
    yych = *++cursor_ptr_;
    if (yych == 'O')
      goto yy15;
  yy11:
    cursor_ptr_ = marker_ptr_;
    goto yy9;
  yy12:
    yych = *++cursor_ptr_;
    if (yych == 'E')
      goto yy16;
    goto yy11;
  yy13:
    yych = *++cursor_ptr_;
    if (yych == 'Y')
      goto yy17;
    goto yy11;
  yy14:
    yych = *++cursor_ptr_;
    if (yych == 'N')
      goto yy18;
    goto yy11;
  yy15:
    yych = *++cursor_ptr_;
    if (yych == 'F')
      goto yy19;
    goto yy11;
  yy16:
    yych = *++cursor_ptr_;
    if (yych == 'L')
      goto yy21;
    goto yy11;
  yy17:
    yych = *++cursor_ptr_;
    if (yych == 'P')
      goto yy22;
    goto yy11;
  yy18:
    yych = *++cursor_ptr_;
    if (yych == 'I')
      goto yy23;
    goto yy11;
  yy19:
    yych = *++cursor_ptr_;
    if (yych == '\n')
      goto yy24;
  yy20:
    condition_ = yycinit;
    {
      return Token::kEOFWord;
    }
  yy21:
    yych = *++cursor_ptr_;
    if (yych == 'P')
      goto yy25;
    goto yy11;
  yy22:
    yych = *++cursor_ptr_;
    if (yych == 'E')
      goto yy26;
    goto yy11;
  yy23:
    yych = *++cursor_ptr_;
    if (yych == 'T')
      goto yy27;
    goto yy11;
  yy24:
    ++cursor_ptr_;
    goto yy20;
  yy25:
    yych = *++cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy28;
    }
    goto yy11;
  yy26:
    yych = *++cursor_ptr_;
    if (yych == ' ')
      goto yy29;
    goto yy11;
  yy27:
    yych = *++cursor_ptr_;
    if (yych == ' ')
      goto yy30;
    goto yy11;
  yy28:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy28;
    }
    condition_ = yycmeta_name;
    {
      return Token::kHelp;
    }
  yy29:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yych == ' ')
      goto yy29;
    condition_ = yycmeta_name;
    {
      return Token::kType;
    }
  yy30:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yych == ' ')
      goto yy30;
    condition_ = yycmeta_name;
    {
      return Token::kUnit;
    }
  }
  /* *********************************** */
  yyc_meta_name: {
    static const unsigned char yybm[] = {
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0,
        0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 128,
        0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
    };
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *(marker_ptr_ = cursor_ptr_);
    if (yych <= '@') {
      if (yych <= '"') {
        if (yych >= '"')
          goto yy33;
      } else {
        if (yych == ':')
          goto yy34;
      }
    } else {
      if (yych <= '_') {
        if (yych <= 'Z')
          goto yy34;
        if (yych >= '_')
          goto yy34;
      } else {
        if (yych <= '`')
          goto yy32;
        if (yych <= 'z')
          goto yy34;
      }
    }
  yy32: { return Token::kInvalid; }
  yy33:
    ++cursor_ptr_;
    condition_ = yycmeta_text_with_leading_spaces;
    {
      return consume_escaped_string(Token::kMetricName);
    }
  yy34:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy34;
    }
    if (yych == ' ')
      goto yy35;
    cursor_ptr_ = marker_ptr_;
    goto yy32;
  yy35:
    ++cursor_ptr_;
    condition_ = yycmeta_text_with_leading_spaces;
    {
      --cursor_ptr_;
      return Token::kMetricName;
    }
  }
  /* *********************************** */
  yyc_meta_text_with_leading_spaces: {
    static const unsigned char yybm[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
    };
    goto yy36;
  yy37:
    ++cursor_ptr_;
  yy36:
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy37;
    }
    condition_ = yycinit;
    {
      token_ptr_ = cursor_ptr_;
      return consume_comment(Token::kText);
    }
  }
  /* *********************************** */
  yyc_exemplar_labels: {
    static const unsigned char yybm[] = {
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0,   0, 0, 0, 0, 0,
        0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 128,
        0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
    };
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yych <= '@') {
      if (yych <= '+') {
        if (yych == '"')
          goto yy39;
      } else {
        if (yych <= ',')
          goto yy40;
        if (yych == '=')
          goto yy41;
      }
    } else {
      if (yych <= '`') {
        if (yych <= 'Z')
          goto yy42;
        if (yych == '_')
          goto yy42;
      } else {
        if (yych <= 'z')
          goto yy42;
        if (yych == '}')
          goto yy43;
      }
    }
    {
      return Token::kInvalid;
    }
  yy39:
    ++cursor_ptr_;
    {
      return consume_escaped_string(Token::kQuotedString);
    }
  yy40:
    ++cursor_ptr_;
    {
      return Token::kComma;
    }
  yy41:
    ++cursor_ptr_;
    condition_ = yycexemplar_label_value;
    {
      return Token::kEqual;
    }
  yy42:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy42;
    }
    {
      return Token::kLabelName;
    }
  yy43:
    ++cursor_ptr_;
    condition_ = yycexemplar_value;
    {
      return Token::kBraceClose;
    }
  }
  /* *********************************** */
  yyc_labels: {
    static const unsigned char yybm[] = {
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0,   0, 0, 0, 0, 0,
        0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 128,
        0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
    };
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yych <= '@') {
      if (yych <= '+') {
        if (yych == '"')
          goto yy45;
      } else {
        if (yych <= ',')
          goto yy46;
        if (yych == '=')
          goto yy47;
      }
    } else {
      if (yych <= '`') {
        if (yych <= 'Z')
          goto yy48;
        if (yych == '_')
          goto yy48;
      } else {
        if (yych <= 'z')
          goto yy48;
        if (yych == '}')
          goto yy49;
      }
    }
    {
      return Token::kInvalid;
    }
  yy45:
    ++cursor_ptr_;
    {
      return consume_escaped_string(Token::kQuotedString);
    }
  yy46:
    ++cursor_ptr_;
    {
      return Token::kComma;
    }
  yy47:
    ++cursor_ptr_;
    condition_ = yyclabel_value;
    {
      return Token::kEqual;
    }
  yy48:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy48;
    }
    {
      return Token::kLabelName;
    }
  yy49:
    ++cursor_ptr_;
    condition_ = yycvalue;
    {
      return Token::kBraceClose;
    }
  }
  /* *********************************** */
  yyc_label_value:
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yych == '"')
      goto yy51;
    {
      return Token::kInvalid;
    }
  yy51:
    ++cursor_ptr_;
    condition_ = yyclabels;
    {
      return consume_escaped_string(Token::kLabelValue);
    }
  /* *********************************** */
  yyc_exemplar_label_value:
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yych == '"')
      goto yy53;
    {
      return Token::kInvalid;
    }
  yy53:
    ++cursor_ptr_;
    condition_ = yycexemplar_labels;
    {
      return consume_escaped_string(Token::kLabelValue);
    }
  /* *********************************** */
  yyc_value: {
    static const unsigned char yybm[] = {
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
    };
    if ((limit_ptr_ - cursor_ptr_) < 2) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *(marker_ptr_ = cursor_ptr_);
    if (yych == ' ')
      goto yy56;
    if (yych == '{')
      goto yy57;
  yy55: { return Token::kInvalid; }
  yy56:
    yych = *++cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy58;
    }
    cursor_ptr_ = marker_ptr_;
    goto yy55;
  yy57:
    ++cursor_ptr_;
    condition_ = yyclabels;
    {
      return Token::kBraceOpen;
    }
  yy58:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy58;
    }
    condition_ = yyctimestamp;
    {
      ++token_ptr_;
      return Token::kValue;
    }
  }
  /* *********************************** */
  yyc_timestamp: {
    static const unsigned char yybm[] = {
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
    };
    if ((limit_ptr_ - cursor_ptr_) < 4) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *(marker_ptr_ = cursor_ptr_);
    if (yych == '\n')
      goto yy61;
    if (yych == ' ')
      goto yy62;
  yy60: { return Token::kInvalid; }
  yy61:
    ++cursor_ptr_;
    condition_ = yycinit;
    {
      return Token::kLinebreak;
    }
  yy62:
    yych = *++cursor_ptr_;
    if (yych <= ' ') {
      if (yych == '\n')
        goto yy63;
      if (yych <= 0x1F)
        goto yy64;
    } else {
      if (yych <= '#') {
        if (yych <= '"')
          goto yy64;
        goto yy67;
      } else {
        if (yych != '{')
          goto yy64;
      }
    }
  yy63:
    cursor_ptr_ = marker_ptr_;
    if (yyaccept == 0) {
      goto yy60;
    } else {
      goto yy66;
    }
  yy64:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
  yy65:
    if (yybm[0 + yych] & 128) {
      goto yy64;
    }
  yy66: {
    ++token_ptr_;
    return Token::kTimestamp;
  }
  yy67:
    yyaccept = 1;
    yych = *(marker_ptr_ = ++cursor_ptr_);
    if (yych != ' ')
      goto yy65;
    yych = *++cursor_ptr_;
    if (yych != '{')
      goto yy63;
    ++cursor_ptr_;
    condition_ = yycexemplar_labels;
    {
      return Token::kExemplar;
    }
  }
  /* *********************************** */
  yyc_exemplar_value: {
    static const unsigned char yybm[] = {
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
    };
    if ((limit_ptr_ - cursor_ptr_) < 2) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *(marker_ptr_ = cursor_ptr_);
    if (yych == ' ')
      goto yy70;
  yy69: { return Token::kInvalid; }
  yy70:
    yych = *++cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy71;
    }
    cursor_ptr_ = marker_ptr_;
    goto yy69;
  yy71:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy71;
    }
    condition_ = yycexemplar_timestamp;
    {
      ++token_ptr_;
      return Token::kValue;
    }
  }
  /* *********************************** */
  yyc_exemplar_timestamp: {
    static const unsigned char yybm[] = {
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
        128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
    };
    if ((limit_ptr_ - cursor_ptr_) < 2) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *(marker_ptr_ = cursor_ptr_);
    if (yych == '\n')
      goto yy74;
    if (yych == ' ')
      goto yy75;
  yy73: { return Token::kInvalid; }
  yy74:
    ++cursor_ptr_;
    condition_ = yycinit;
    {
      return Token::kLinebreak;
    }
  yy75:
    yych = *++cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy76;
    }
    cursor_ptr_ = marker_ptr_;
    goto yy73;
  yy76:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy76;
    }
    {
      ++token_ptr_;
      return Token::kTimestamp;
    }
  }
  }
}
// NOLINTEND

}  // namespace PromPP::Prometheus::textparse::OpenMetrics
