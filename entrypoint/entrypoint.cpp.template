#if defined(__x86_64__) || defined(_M_AMD64)
#define PROMPP_PLATFORM_AMD64 1
#endif
#if defined(__aarch64__) || defined(_M_ARM64)
#define PROMPP_PLATFORM_ARM64 1
#endif

#include <cstring>
#if PROMPP_PLATFORM_AMD64
//#entrypoint.amd64_includes
#elif PROMPP_PLATFORM_ARM64
#include <asm/hwcap.h>
#include <sys/auxv.h>

//#entrypoint.arm64_includes
#endif

//#entrypoint.function_pointers

#if PROMPP_PLATFORM_AMD64
enum arch_flavor { generic, nehalem, haswell };

arch_flavor determine_arch_flavor() {
  if (!__builtin_cpu_supports("sse4.2"))
    return generic;

  if (!__builtin_cpu_supports("bmi") || !__builtin_cpu_supports("avx2"))
    return nehalem;

  return haswell;
}
#elif PROMPP_PLATFORM_ARM64
enum arch_flavor { generic, crc32 };

arch_flavor determine_arch_flavor() {
  if (getauxval(AT_HWCAP) & HWCAP_CRC32) {
    return crc32;
  }
  return generic;
}
#endif

const char* prompp_flavor = nullptr;
extern "C" void prompp_get_flavor(void* res) {
  using res_t = struct {
    const char* data;
    size_t len;
  };
  res_t* out = reinterpret_cast<res_t*>(res);
  out->data = prompp_flavor;
  out->len = 0;
  if (prompp_flavor != nullptr) {
    out->len = std::strlen(prompp_flavor);
  }
}

#define EXTERN_FUNCTION(return_type, name, args) \
  return_type amd64_haswell_##name args;         \
  return_type amd64_nehalem_##name args;         \
  return_type amd64_k8_##name args;              \
  return_type arm64_armv8_a_crc_##name args;     \
  return_type arm64_armv8_a_##name args;

extern "C" {
EXTERN_FUNCTION(void, prompp_jemalloc_init, ());
EXTERN_FUNCTION(void*, malloc, (size_t));
EXTERN_FUNCTION(void*, realloc, (void*, size_t));
EXTERN_FUNCTION(void*, calloc, (size_t n, size_t size));
EXTERN_FUNCTION(int, posix_memalign, (void **__memptr, size_t __alignment, size_t __size));
EXTERN_FUNCTION(void*, aligned_alloc, (size_t alignment, size_t size));
EXTERN_FUNCTION(void*, valloc, (size_t size));
EXTERN_FUNCTION(void*, memalign, (size_t alignment, size_t size));
EXTERN_FUNCTION(void, free, (void*));
}

#undef EXTERN_FUNCTION

static void initialize();

#if !defined(__SANITIZE_ADDRESS__)
#define DEFINE_ALLOCATOR_SYMBOL(return_type, name, args, parameters) \
  extern "C" return_type name args { return name ## _func parameters; }
#else
#define DEFINE_ALLOCATOR_SYMBOL(return_type, name, args, parameters)
#endif

#define OVERRIDE_ALLOCATOR_SYMBOL(return_type, name, args, parameters) \
  return_type initialize_and_ ## name args; \
  static return_type (*name ## _func) args = initialize_and_ ## name; \
  return_type initialize_and_ ## name args { \
    initialize(); \
    return name ## _func parameters; \
  } \
  DEFINE_ALLOCATOR_SYMBOL(return_type, name, args, parameters)

OVERRIDE_ALLOCATOR_SYMBOL(void*, malloc, (size_t size), (size));
OVERRIDE_ALLOCATOR_SYMBOL(void*, realloc, (void* ptr, size_t size), (ptr, size));
OVERRIDE_ALLOCATOR_SYMBOL(void*, calloc, (size_t n, size_t size), (n, size));
OVERRIDE_ALLOCATOR_SYMBOL(int, posix_memalign, (void **__memptr, size_t __alignment, size_t __size), (__memptr, __alignment, __size));
OVERRIDE_ALLOCATOR_SYMBOL(void*, aligned_alloc, (size_t alignment, size_t size), (alignment, size));
OVERRIDE_ALLOCATOR_SYMBOL(void*, valloc, (size_t size), (size));
OVERRIDE_ALLOCATOR_SYMBOL(void*, memalign, (size_t alignment, size_t size), (alignment, size));
OVERRIDE_ALLOCATOR_SYMBOL(void, free, (void *ptr), (ptr));

#undef OVERRIDE_ALLOCATOR_SYMBOL
#undef DEFINE_ALLOCATOR_SYMBOL

#define SELECT_ARCH(arch, flavor)  \
  arch##_prompp_jemalloc_init();   \
  malloc_func = arch##_malloc;   \
  realloc_func = arch##_realloc; \
  calloc_func = arch##_calloc;   \
  posix_memalign_func = arch##_posix_memalign;   \
  aligned_alloc_func = arch##_aligned_alloc;   \
  valloc_func = arch##_valloc;   \
  memalign_func = arch##_memalign;   \
  free_func = arch##_free;       \
  prompp_flavor = flavor;

static __attribute__((constructor)) void initialize() {
  switch (determine_arch_flavor()) {
#if PROMPP_PLATFORM_AMD64
    case haswell: {
//#entrypoint.amd64_haswell_bindings
      SELECT_ARCH(amd64_haswell, "haswell");
      break;
    }
    case nehalem: {
//#entrypoint.amd64_nehalem_bindings
      SELECT_ARCH(amd64_nehalem, "nehalem");
      break;
    }
    default: {
//#entrypoint.amd64_k8_bindings
      SELECT_ARCH(amd64_k8, "k8");
      break;
    }
#elif PROMPP_PLATFORM_ARM64
    case crc32: {
//#entrypoint.arm64_armv8_a_crc_bindings
      SELECT_ARCH(arm64_armv8_a_crc, "armv8-a+crc");
      break;
    }
    default: {
//#entrypoint.arm64_armv8_a_bindings
      SELECT_ARCH(arm64_armv8_a, "armv8-a");
      break;
    }
#endif
  }
}

#undef SELECT_ARCH
