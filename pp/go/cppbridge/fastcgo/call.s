// +build amd64 amd64p32 arm64

// This file is an Go Assembly implementation of fast calls on main (g0) goroutine.
// For proper work, there must be an runtime_XXXX.go file with
// runtime types/variables declarations.
#include "go_asm.h" // autogenerated by go build/ go asm, use -x for details or -work for printing info about tmp files and this file
#include "textflag.h" // located at golang sources at golang/go/src/runtime

// Brief info about registers' aliases
//
// - RARGn is a Register alias for ARGn.
// - R_SP  is a Register alias for Stack Pointer (SP for x86, RSP for ARM).
// - RTMP0, RTMP1 are Register aliases for temporary Generic Registers
//                (to avoid using the reserved registries' names).
// - RTMPSP is the temporary register for storing SP across the calls.
//   It must be one of so-called "Callee-saved Registers". (See [SO-Callee-saved])
// - CALL_REG is a Register reserved by us for indirect (through function pointer) call.
// - RRET is an alias for Register reserved for returning values from calls.

// The used references:
// https://github.com/choleraehyq/fastercgo/blob/master/call_amd64.s
// https://github.com/leha-bot/test-fastcgo-multiarch
// https://github.com/petermattis/fastcgo/blob/master/call_amd64.s
//
// https://github.com/golang/go/blob/master/src/runtime/cgo/asm_arm64.s
//
// Plan 9 Assembly Reference: https://9p.io/sys/doc/asm.html
//
// Info about registers:
//
// ARM ABI: https://developer.arm.com/documentation/den0024/a/The-ABI-for-ARM-64-bit-Architecture/Register-use-in-the-AArch64-Procedure-Call-Standard/Parameters-in-general-purpose-registers
// [SO-Callee-saved]: https://stackoverflow.com/questions/9268586/what-are-callee-and-caller-saved-registers
// x86-64 callee-saved regs: https://stackoverflow.com/questions/18024672/what-registers-are-preserved-through-a-linux-x86-64-function-call
// Work with ARM stack (push/pop analogue for ARM): https://stackoverflow.com/questions/27941220/push-lr-and-pop-lr-in-arm-arch64
//
// More interesting links to dive into:
// https://github.com/akutz/go-interface-values/blob/main/docs/02-interface-values/09-on-the-stack.md
// https://github.com/teh-cmc/go-internals/blob/master/chapter1_assembly_primer/README.md

#ifdef GOARCH_arm64
// see https://developer.arm.com/documentation/den0024/a/The-ABI-for-ARM-64-bit-Architecture/Register-use-in-the-AArch64-Procedure-Call-Standard/Parameters-in-general-purpose-registers
// for details of all ARM regs,
// For asm details see https://9p.io/sys/doc/asm.html
// For more ABI details see https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst
#define RARG0 R0
#define RARG1 R1
#define RARG2 R2
#define RARG3 R3
#define R_SP   RSP
#define RTMP0  R9
#define RTMP1  R10
#define RTMP2  R11
#define RTMPSP R19
#define RRET   R0 // same as arg0

/* CALL_REG is a temporary register for storing an actual pointer to called function. */
#define CALL_REG R13

// G_VAR is a main goroutine variable.
#define G_VAR g

/* macro synonyms for operations */
#define MOV_64bit MOVD
#define MOV_adr64bit MOVD.P
#define AND_64bit AND

// Makes an initial preparations for calling, e.g., storing function pointer into avail register.
#define PREPARE_CALL                                                            \
	MOVD fn+0(FP), CALL_REG
#else /* amd64 */
/*Intel x86(-64)*/

#define RARG0 DI
#define RARG1 SI
#define RARG2 DX
#define RARG3 CX
#define R_SP  SP
#define RTMP0 R13
#define RTMP1 R14
#define RTMP2 R11
#define RTMPSP R12
#define RRET  AX

#define CALL_REG AX
#define G_VAR (TLS)

#define MOV_64bit MOVQ
#define MOV_adr64bit MOVQ
#define AND_64bit ANDQ

#define PREPARE_CALL                                                            \
        MOVQ fn+0(FP), CALL_REG
#endif

#define UNSAFE_CALL                                                                       \
	/* Switch stack to g0 */                                                              \
	MOV_64bit G_VAR, RTMP1;                     /* Load g */                              \
	MOV_64bit g_m(RTMP1), RTMP0;                /* Load g.m */                            \
	MOV_64bit R_SP, RTMPSP;                     /* Save SP in a callee-saved register */  \
	MOV_64bit m_g0(RTMP0), RTMP1;                /* Load m.go */                          \
	MOV_64bit (g_sched+gobuf_sp)(RTMP1), RTMP2;  /* Load g0.sched.sp */                   \
	AND_64bit $~15, RTMP2;                       /* Align the stack to 16-bytes */        \
	MOV_64bit RTMP2, R_SP                                                                 \
	CALL CALL_REG;                                                                        \
	MOV_64bit RTMPSP, R_SP;                      /* Restore SP */                         \

// func UnsafeCall0(fn unsafe.Pointer)
// Switches SP to g0 stack and calls fn.
TEXT ·UnsafeCall0(SB), NOSPLIT, $0-0
	PREPARE_CALL
	UNSAFE_CALL
	RET

// func UnsafeCall1(fn unsafe.Pointer, arg0 uintptr)
// Switches SP to g0 stack and calls fn with one arg.
TEXT ·UnsafeCall1(SB), NOSPLIT, $0-0
	PREPARE_CALL
	MOV_64bit arg0+8(FP), RARG0
	UNSAFE_CALL
	RET

// func UnsafeCall2(fn unsafe.Pointer, arg0, arg1 uintptr)
// Switches SP to g0 stack and calls fn with two args.
TEXT ·UnsafeCall2(SB), NOSPLIT, $0-0
	PREPARE_CALL
	MOV_64bit arg0+8(FP),  RARG0
	MOV_64bit arg1+16(FP), RARG1
	UNSAFE_CALL
	RET

// func UnsafeCall3(fn unsafe.Pointer, arg0, arg1, arg2 uintptr)
// Switches SP to g0 stack and calls fn with two args.
TEXT ·UnsafeCall3(SB), NOSPLIT, $0-0
	PREPARE_CALL
	MOV_64bit arg0+8(FP),  RARG0
	MOV_64bit arg1+16(FP), RARG1
	MOV_64bit arg2+24(FP), RARG2
	UNSAFE_CALL
	RET

// func UnsafeCall4(fn unsafe.Pointer, arg0, arg1, arg2, arg3 uintptr)
// Switches SP to g0 stack and calls fn.
TEXT ·UnsafeCall4(SB), NOSPLIT, $0-0
	PREPARE_CALL
	MOV_64bit arg0+8(FP), RARG0
	MOV_64bit arg1+16(FP), RARG1
	MOV_64bit arg2+24(FP), RARG2
	MOV_64bit arg3+32(FP), RARG3
	UNSAFE_CALL
	RET
