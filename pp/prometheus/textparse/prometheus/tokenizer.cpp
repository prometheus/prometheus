/* Generated by re2c */
#include "tokenizer.h"

#include <cstring>

// NOLINTBEGIN
enum YYCONDTYPE {
  yycinit,
  yyccomment,
  yycmeta_name,
  yycmeta_text_with_leading_spaces,
  yyclabels,
  yyclabel_value,
  yycvalue,
  yyctimestamp,
};

// NOLINTEND

namespace PromPP::Prometheus::textparse::Prometheus {

Tokenizer::Tokenizer() : condition_{yycinit} {}

Tokenizer::Tokenizer(std::string_view str)
    : start_ptr_(str.data()),
      cursor_ptr_(start_ptr_),
      limit_ptr_(start_ptr_ + str.size()),
      marker_ptr_(start_ptr_),
      token_ptr_(start_ptr_),
      condition_{yycinit} {}

void Tokenizer::tokenize(std::string_view str) noexcept {
  start_ptr_ = str.data();
  cursor_ptr_ = start_ptr_;
  limit_ptr_ = start_ptr_ + str.size();
  marker_ptr_ = start_ptr_;
  token_ptr_ = start_ptr_;

  condition_ = yycinit;
}

Token Tokenizer::consume_comment(Token token) noexcept {
  if (cursor_ptr_ = static_cast<const char*>(std::memchr(cursor_ptr_, '\n', limit_ptr_ - cursor_ptr_)); cursor_ptr_ != nullptr) [[likely]] {
    condition_ = yycinit;
    return token;
  }

  cursor_ptr_ = limit_ptr_;
  return Token::kEOF;
}

Token Tokenizer::consume_escaped_string(Token token) noexcept {
  while (true) {
    if (cursor_ptr_ = static_cast<const char*>(std::memchr(cursor_ptr_, '"', limit_ptr_ - cursor_ptr_)); cursor_ptr_ == nullptr) [[unlikely]] {
      cursor_ptr_ = limit_ptr_;
      return Token::kInvalid;
    }

    if (cursor_ptr_[-1] == '\\') [[unlikely]] {
      ++cursor_ptr_;
      continue;
    }

    break;
  }

  ++cursor_ptr_;
  return token;
}

// NOLINTBEGIN
Token Tokenizer::next_impl() noexcept {
  token_ptr_ = cursor_ptr_;

  {
    unsigned char yych;
    if (condition_ < 4) {
      if (condition_ < 2) {
        if (condition_ < 1) {
          goto yyc_init;
        } else {
          goto yyc_comment;
        }
      } else {
        if (condition_ < 3) {
          goto yyc_meta_name;
        } else {
          goto yyc_meta_text_with_leading_spaces;
        }
      }
    } else {
      if (condition_ < 6) {
        if (condition_ < 5) {
          goto yyc_labels;
        } else {
          goto yyc_label_value;
        }
      } else {
        if (condition_ < 7) {
          goto yyc_value;
        } else {
          goto yyc_timestamp;
        }
      }
    }
  /* *********************************** */
  yyc_init: {
    static const unsigned char yybm[] = {
        0,  0,   0,   0,   0,   0,   0,   0,   0,   64,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        64, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0,
        0,  128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 128,
        0,  128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
    };
    if ((limit_ptr_ - cursor_ptr_) < 2) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy3;
    }
    if (yych <= ':') {
      if (yych <= '\n') {
        if (yych <= 0x00)
          goto yy2;
        if (yych >= '\t')
          goto yy4;
      } else {
        if (yych == '#')
          goto yy5;
        if (yych >= ':')
          goto yy6;
      }
    } else {
      if (yych <= '_') {
        if (yych <= '@')
          goto yy1;
        if (yych <= 'Z')
          goto yy6;
        if (yych >= '_')
          goto yy6;
      } else {
        if (yych <= '`')
          goto yy1;
        if (yych <= 'z')
          goto yy6;
        if (yych <= '{')
          goto yy7;
      }
    }
  yy1: { return Token::kInvalid; }
  yy2:
    ++cursor_ptr_;
    {
      return Token::kEOF;
    }
  yy3:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy3;
    }
    {
      return Token::kWhitespace;
    }
  yy4:
    ++cursor_ptr_;
    {
      return Token::kLinebreak;
    }
  yy5:
    yych = *++cursor_ptr_;
    if (yych == '\t')
      goto yy8;
    if (yych == ' ')
      goto yy8;
    {
      token_ptr_ = cursor_ptr_;
      return consume_comment();
    }
  yy6:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy6;
    }
    condition_ = yycvalue;
    {
      return Token::kMetricName;
    }
  yy7:
    ++cursor_ptr_;
    condition_ = yyclabels;
    {
      return Token::kBraceOpen;
    }
  yy8:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yych == '\t')
      goto yy8;
    if (yych == ' ')
      goto yy8;
    condition_ = yyccomment;
    {
      token_ptr_ = cursor_ptr_;
    }
  }
  /* *********************************** */
  yyc_comment: {
    static const unsigned char yybm[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
    };
    if ((limit_ptr_ - cursor_ptr_) < 5) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *(marker_ptr_ = cursor_ptr_);
    if (yybm[0 + yych] & 128) {
      goto yy11;
    }
    if (yych == 'H')
      goto yy12;
    if (yych == 'T')
      goto yy14;
  yy10:
    condition_ = yycinit;
    {
      return consume_comment();
    }
  yy11:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy11;
    }
    {
      return Token::kWhitespace;
    }
  yy12:
    yych = *++cursor_ptr_;
    if (yych == 'E')
      goto yy15;
  yy13:
    cursor_ptr_ = marker_ptr_;
    goto yy10;
  yy14:
    yych = *++cursor_ptr_;
    if (yych == 'Y')
      goto yy16;
    goto yy13;
  yy15:
    yych = *++cursor_ptr_;
    if (yych == 'L')
      goto yy17;
    goto yy13;
  yy16:
    yych = *++cursor_ptr_;
    if (yych == 'P')
      goto yy18;
    goto yy13;
  yy17:
    yych = *++cursor_ptr_;
    if (yych == 'P')
      goto yy19;
    goto yy13;
  yy18:
    yych = *++cursor_ptr_;
    if (yych == 'E')
      goto yy20;
    goto yy13;
  yy19:
    yych = *++cursor_ptr_;
    if (yych == '\t')
      goto yy21;
    if (yych == ' ')
      goto yy21;
    goto yy13;
  yy20:
    yych = *++cursor_ptr_;
    if (yych == '\t')
      goto yy22;
    if (yych == ' ')
      goto yy22;
    goto yy13;
  yy21:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yych == '\t')
      goto yy21;
    if (yych == ' ')
      goto yy21;
    condition_ = yycmeta_name;
    {
      return Token::kHelp;
    }
  yy22:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yych == '\t')
      goto yy22;
    if (yych == ' ')
      goto yy22;
    condition_ = yycmeta_name;
    {
      return Token::kType;
    }
  }
  /* *********************************** */
  yyc_meta_name: {
    static const unsigned char yybm[] = {
        0,  0,   0,   0,   0,   0,   0,   0,   0,   64,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        64, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0,
        0,  128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 128,
        0,  128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
    };
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy25;
    }
    if (yych <= '@') {
      if (yych <= '"') {
        if (yych >= '"')
          goto yy26;
      } else {
        if (yych == ':')
          goto yy27;
      }
    } else {
      if (yych <= '_') {
        if (yych <= 'Z')
          goto yy27;
        if (yych >= '_')
          goto yy27;
      } else {
        if (yych <= '`')
          goto yy24;
        if (yych <= 'z')
          goto yy27;
      }
    }
  yy24: { return Token::kInvalid; }
  yy25:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy25;
    }
    {
      return Token::kWhitespace;
    }
  yy26:
    ++cursor_ptr_;
    condition_ = yycmeta_text_with_leading_spaces;
    {
      return consume_escaped_string(Token::kMetricName);
    }
  yy27:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy27;
    }
    condition_ = yycmeta_text_with_leading_spaces;
    {
      return Token::kMetricName;
    }
  }
  /* *********************************** */
  yyc_meta_text_with_leading_spaces: {
    static const unsigned char yybm[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
    };
    goto yy28;
  yy29:
    ++cursor_ptr_;
  yy28:
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy29;
    }
    condition_ = yycinit;
    {
      token_ptr_ = cursor_ptr_;
      return consume_comment(Token::kText);
    }
  }
  /* *********************************** */
  yyc_labels: {
    static const unsigned char yybm[] = {
        0,  0,   0,   0,   0,   0,   0,   0,   0,   64,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        64, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0,   0, 0, 0, 0, 0,
        0,  128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 128,
        0,  128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
        0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0,
    };
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy31;
    }
    if (yych <= '@') {
      if (yych <= '+') {
        if (yych == '"')
          goto yy32;
      } else {
        if (yych <= ',')
          goto yy33;
        if (yych == '=')
          goto yy34;
      }
    } else {
      if (yych <= '`') {
        if (yych <= 'Z')
          goto yy35;
        if (yych == '_')
          goto yy35;
      } else {
        if (yych <= 'z')
          goto yy35;
        if (yych == '}')
          goto yy36;
      }
    }
    {
      return Token::kInvalid;
    }
  yy31:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy31;
    }
    {
      return Token::kWhitespace;
    }
  yy32:
    ++cursor_ptr_;
    {
      return consume_escaped_string(Token::kQuotedString);
    }
  yy33:
    ++cursor_ptr_;
    {
      return Token::kComma;
    }
  yy34:
    ++cursor_ptr_;
    condition_ = yyclabel_value;
    {
      return Token::kEqual;
    }
  yy35:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy35;
    }
    {
      return Token::kLabelName;
    }
  yy36:
    ++cursor_ptr_;
    condition_ = yycvalue;
    {
      return Token::kBraceClose;
    }
  }
  /* *********************************** */
  yyc_label_value: {
    static const unsigned char yybm[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,
    };
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy38;
    }
    if (yych == '"')
      goto yy39;
    {
      return Token::kInvalid;
    }
  yy38:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy38;
    }
    {
      return Token::kWhitespace;
    }
  yy39:
    ++cursor_ptr_;
    condition_ = yyclabels;
    {
      return consume_escaped_string(Token::kLabelValue);
    }
  }
  /* *********************************** */
  yyc_value: {
    static const unsigned char yybm[] = {
        64, 64, 64, 64, 64, 64, 64, 64, 64, 128, 0,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 128, 64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 0,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64,
        64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  64,
    };
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy42;
    }
    if (yych == '\n')
      goto yy41;
    if (yych <= ' ')
      goto yy43;
    goto yy44;
  yy41: { return Token::kInvalid; }
  yy42:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy42;
    }
    condition_ = yyctimestamp;
    {
      return Token::kValue;
    }
  yy43:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy43;
    }
    {
      return Token::kWhitespace;
    }
  yy44:
    ++cursor_ptr_;
    condition_ = yyclabels;
    {
      return Token::kBraceOpen;
    }
  }
  /* *********************************** */
  yyc_timestamp: {
    static const unsigned char yybm[] = {
        0, 0, 0, 0, 0, 0,   0,   0,   0,   64,  0,   0,   0,   0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
    };
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy47;
    }
    if (yych <= 0x08)
      goto yy46;
    if (yych <= '\n')
      goto yy48;
    if (yych <= '/')
      goto yy46;
    if (yych <= '9')
      goto yy49;
  yy46: { return Token::kInvalid; }
  yy47:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 64) {
      goto yy47;
    }
    {
      return Token::kWhitespace;
    }
  yy48:
    ++cursor_ptr_;
    condition_ = yycinit;
    {
      return Token::kLinebreak;
    }
  yy49:
    ++cursor_ptr_;
    if (limit_ptr_ <= cursor_ptr_) {
      if (limit_ptr_ == cursor_ptr_) {
        return Token::kEOF;
      }
    }
    yych = *cursor_ptr_;
    if (yybm[0 + yych] & 128) {
      goto yy49;
    }
    {
      return Token::kTimestamp;
    }
  }
  }
}
// NOLINTEND

}  // namespace PromPP::Prometheus::textparse::Prometheus
